<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>文件下载，搞懂这9种场景就够了 | duangdong的note</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.a427ee9b.css" as="style"><link rel="preload" href="/assets/js/app.6df8e219.js" as="script"><link rel="preload" href="/assets/js/2.e21ead49.js" as="script"><link rel="preload" href="/assets/js/143.45031fa6.js" as="script"><link rel="prefetch" href="/assets/js/10.e0bdad61.js"><link rel="prefetch" href="/assets/js/100.82a4c820.js"><link rel="prefetch" href="/assets/js/101.f5d94e3b.js"><link rel="prefetch" href="/assets/js/102.7f36fa51.js"><link rel="prefetch" href="/assets/js/103.085df24a.js"><link rel="prefetch" href="/assets/js/104.76789169.js"><link rel="prefetch" href="/assets/js/105.9efb3db9.js"><link rel="prefetch" href="/assets/js/106.22337f5b.js"><link rel="prefetch" href="/assets/js/107.ac8e17b4.js"><link rel="prefetch" href="/assets/js/108.5fe47bcc.js"><link rel="prefetch" href="/assets/js/109.cf88a409.js"><link rel="prefetch" href="/assets/js/11.e801cea9.js"><link rel="prefetch" href="/assets/js/110.603c3bd4.js"><link rel="prefetch" href="/assets/js/111.26f89c7d.js"><link rel="prefetch" href="/assets/js/112.1ad5bc54.js"><link rel="prefetch" href="/assets/js/113.cde31a40.js"><link rel="prefetch" href="/assets/js/114.a1a2a895.js"><link rel="prefetch" href="/assets/js/115.31c25d8b.js"><link rel="prefetch" href="/assets/js/116.8ed4b493.js"><link rel="prefetch" href="/assets/js/117.c802c1ce.js"><link rel="prefetch" href="/assets/js/118.15aead28.js"><link rel="prefetch" href="/assets/js/119.c26b6aad.js"><link rel="prefetch" href="/assets/js/12.9ed8f981.js"><link rel="prefetch" href="/assets/js/120.c3410f53.js"><link rel="prefetch" href="/assets/js/121.357fc3f4.js"><link rel="prefetch" href="/assets/js/122.6ecee0a8.js"><link rel="prefetch" href="/assets/js/123.6b38e86a.js"><link rel="prefetch" href="/assets/js/124.463231bb.js"><link rel="prefetch" href="/assets/js/125.dc9f9675.js"><link rel="prefetch" href="/assets/js/126.97f340de.js"><link rel="prefetch" href="/assets/js/127.080209f1.js"><link rel="prefetch" href="/assets/js/128.dd7fed27.js"><link rel="prefetch" href="/assets/js/129.e9a49c7b.js"><link rel="prefetch" href="/assets/js/13.fb60e043.js"><link rel="prefetch" href="/assets/js/130.86b31ea7.js"><link rel="prefetch" href="/assets/js/131.be4dca8f.js"><link rel="prefetch" href="/assets/js/132.a4e032bd.js"><link rel="prefetch" href="/assets/js/133.545d53fa.js"><link rel="prefetch" href="/assets/js/134.ef4512f0.js"><link rel="prefetch" href="/assets/js/135.b15ec030.js"><link rel="prefetch" href="/assets/js/136.14e63782.js"><link rel="prefetch" href="/assets/js/137.671e87f8.js"><link rel="prefetch" href="/assets/js/138.b3d28a52.js"><link rel="prefetch" href="/assets/js/139.bc5e381c.js"><link rel="prefetch" href="/assets/js/14.63057fe7.js"><link rel="prefetch" href="/assets/js/140.ce3a69fc.js"><link rel="prefetch" href="/assets/js/141.09737b5b.js"><link rel="prefetch" href="/assets/js/142.49e3bb24.js"><link rel="prefetch" href="/assets/js/144.458e287e.js"><link rel="prefetch" href="/assets/js/145.9d21ff24.js"><link rel="prefetch" href="/assets/js/146.88d47473.js"><link rel="prefetch" href="/assets/js/147.277b5759.js"><link rel="prefetch" href="/assets/js/148.0dd5c138.js"><link rel="prefetch" href="/assets/js/149.d638ab21.js"><link rel="prefetch" href="/assets/js/15.3ac2cfb4.js"><link rel="prefetch" href="/assets/js/150.834eb5ca.js"><link rel="prefetch" href="/assets/js/151.0b833f48.js"><link rel="prefetch" href="/assets/js/152.d212207c.js"><link rel="prefetch" href="/assets/js/153.e8b1311a.js"><link rel="prefetch" href="/assets/js/154.74eb8531.js"><link rel="prefetch" href="/assets/js/16.f2129a31.js"><link rel="prefetch" href="/assets/js/17.27a38c73.js"><link rel="prefetch" href="/assets/js/18.ec5b4213.js"><link rel="prefetch" href="/assets/js/19.553ed8c2.js"><link rel="prefetch" href="/assets/js/20.c1bf3bbb.js"><link rel="prefetch" href="/assets/js/21.5790bc21.js"><link rel="prefetch" href="/assets/js/22.29894e1b.js"><link rel="prefetch" href="/assets/js/23.bae1a497.js"><link rel="prefetch" href="/assets/js/24.1edc62bc.js"><link rel="prefetch" href="/assets/js/25.69b254ca.js"><link rel="prefetch" href="/assets/js/26.df57f236.js"><link rel="prefetch" href="/assets/js/27.9ae48125.js"><link rel="prefetch" href="/assets/js/28.d42d4bb6.js"><link rel="prefetch" href="/assets/js/29.f3630e2f.js"><link rel="prefetch" href="/assets/js/3.5c47a171.js"><link rel="prefetch" href="/assets/js/30.40cf5507.js"><link rel="prefetch" href="/assets/js/31.99b2787c.js"><link rel="prefetch" href="/assets/js/32.eef578d9.js"><link rel="prefetch" href="/assets/js/33.6755a6d2.js"><link rel="prefetch" href="/assets/js/34.add65d5c.js"><link rel="prefetch" href="/assets/js/35.3e4a0da9.js"><link rel="prefetch" href="/assets/js/36.9d4bd3f9.js"><link rel="prefetch" href="/assets/js/37.98506fd6.js"><link rel="prefetch" href="/assets/js/38.44bce283.js"><link rel="prefetch" href="/assets/js/39.62bf281f.js"><link rel="prefetch" href="/assets/js/4.8f6f0475.js"><link rel="prefetch" href="/assets/js/40.3a389edd.js"><link rel="prefetch" href="/assets/js/41.a309beb7.js"><link rel="prefetch" href="/assets/js/42.4e87216c.js"><link rel="prefetch" href="/assets/js/43.c6f6922b.js"><link rel="prefetch" href="/assets/js/44.fda8b3de.js"><link rel="prefetch" href="/assets/js/45.5a1c5b3b.js"><link rel="prefetch" href="/assets/js/46.289cbb81.js"><link rel="prefetch" href="/assets/js/47.81850ce8.js"><link rel="prefetch" href="/assets/js/48.e986629d.js"><link rel="prefetch" href="/assets/js/49.d04a41c3.js"><link rel="prefetch" href="/assets/js/5.8b87f02a.js"><link rel="prefetch" href="/assets/js/50.727fb121.js"><link rel="prefetch" href="/assets/js/51.a10ac8b0.js"><link rel="prefetch" href="/assets/js/52.4fffa0ef.js"><link rel="prefetch" href="/assets/js/53.03ab34e0.js"><link rel="prefetch" href="/assets/js/54.f05ee208.js"><link rel="prefetch" href="/assets/js/55.f90df177.js"><link rel="prefetch" href="/assets/js/56.86a4d03e.js"><link rel="prefetch" href="/assets/js/57.c8cee71c.js"><link rel="prefetch" href="/assets/js/58.0b503f53.js"><link rel="prefetch" href="/assets/js/59.c4daebc4.js"><link rel="prefetch" href="/assets/js/6.2f86309f.js"><link rel="prefetch" href="/assets/js/60.b9584ba1.js"><link rel="prefetch" href="/assets/js/61.fa6e5de3.js"><link rel="prefetch" href="/assets/js/62.4f67908f.js"><link rel="prefetch" href="/assets/js/63.0c9d8ccc.js"><link rel="prefetch" href="/assets/js/64.2754e515.js"><link rel="prefetch" href="/assets/js/65.f2bd6dd5.js"><link rel="prefetch" href="/assets/js/66.299c952c.js"><link rel="prefetch" href="/assets/js/67.2ccaf3ef.js"><link rel="prefetch" href="/assets/js/68.b6e197f0.js"><link rel="prefetch" href="/assets/js/69.b821ea5d.js"><link rel="prefetch" href="/assets/js/7.f1cc41de.js"><link rel="prefetch" href="/assets/js/70.7beae76c.js"><link rel="prefetch" href="/assets/js/71.d452a791.js"><link rel="prefetch" href="/assets/js/72.f3fd5168.js"><link rel="prefetch" href="/assets/js/73.0804c5f0.js"><link rel="prefetch" href="/assets/js/74.cdcdfbcc.js"><link rel="prefetch" href="/assets/js/75.e8e01c97.js"><link rel="prefetch" href="/assets/js/76.6801837d.js"><link rel="prefetch" href="/assets/js/77.04408d97.js"><link rel="prefetch" href="/assets/js/78.9130c8b3.js"><link rel="prefetch" href="/assets/js/79.dcf60589.js"><link rel="prefetch" href="/assets/js/8.89fa1943.js"><link rel="prefetch" href="/assets/js/80.efe0c1a1.js"><link rel="prefetch" href="/assets/js/81.8220fef3.js"><link rel="prefetch" href="/assets/js/82.ae2099d2.js"><link rel="prefetch" href="/assets/js/83.c563f161.js"><link rel="prefetch" href="/assets/js/84.e365194b.js"><link rel="prefetch" href="/assets/js/85.15de0cdb.js"><link rel="prefetch" href="/assets/js/86.b99959c5.js"><link rel="prefetch" href="/assets/js/87.6fccf3fc.js"><link rel="prefetch" href="/assets/js/88.9bc0613a.js"><link rel="prefetch" href="/assets/js/89.89530022.js"><link rel="prefetch" href="/assets/js/9.7637f327.js"><link rel="prefetch" href="/assets/js/90.53d12303.js"><link rel="prefetch" href="/assets/js/91.c55896d7.js"><link rel="prefetch" href="/assets/js/92.0fe1f724.js"><link rel="prefetch" href="/assets/js/93.d681c01d.js"><link rel="prefetch" href="/assets/js/94.ed89d267.js"><link rel="prefetch" href="/assets/js/95.96e675de.js"><link rel="prefetch" href="/assets/js/96.5ad7361e.js"><link rel="prefetch" href="/assets/js/97.e7f32727.js"><link rel="prefetch" href="/assets/js/98.c3a03e67.js"><link rel="prefetch" href="/assets/js/99.31f54446.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427ee9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/principle/" class="nav-link">
  JS执行
</a></div><div class="nav-item"><a href="/design-mode/" class="nav-link">
  JS设计模式
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/advanced-function/" class="nav-link">
  高阶函数
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/eight-essay/" class="nav-link">
  八股文
</a></div><div class="nav-item"><a href="/hand-writing/" class="nav-link">
  手写实现
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/tools/" class="nav-link router-link-active">
  工具方法
</a></div><div class="nav-item"><a href="https://link.qdzhou.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/principle/" class="nav-link">
  JS执行
</a></div><div class="nav-item"><a href="/design-mode/" class="nav-link">
  JS设计模式
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/advanced-function/" class="nav-link">
  高阶函数
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/eight-essay/" class="nav-link">
  八股文
</a></div><div class="nav-item"><a href="/hand-writing/" class="nav-link">
  手写实现
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/tools/" class="nav-link router-link-active">
  工具方法
</a></div><div class="nav-item"><a href="https://link.qdzhou.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/tools/" aria-current="page" class="sidebar-link">八股文</a></li><li><a href="/tools/15分钟学会Immutable.html" class="sidebar-link">15分钟学会Immutable</a></li><li><a href="/tools/JS 图片压缩.html" class="sidebar-link">ZooTeam</a></li><li><a href="/tools/axios怎么封装.html" class="sidebar-link">axios怎么封装，才能提升效率？</a></li><li><a href="/tools/rc-form.html" class="sidebar-link">最熟悉的陌生人rc-form</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>代码片段</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/tools/位运算.html" class="sidebar-link">JS中运算符</a></li><li><a href="/tools/如何从 0 到 1 搭建代码全局检索系统.html" class="sidebar-link">如何从 0 到 1 搭建代码全局检索系统</a></li><li><a href="/tools/如何实现高性能的在线 PDF 预览.html" class="sidebar-link">如何实现高性能的在线 PDF 预览</a></li><li><a href="/tools/手写一个虚拟DOM库.html" class="sidebar-link">手写一个虚拟DOM库，彻底让你理解diff算法</a></li><li><a href="/tools/文件下载.html" class="active sidebar-link">文件下载，搞懂这9种场景就够了</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="文件下载-搞懂这9种场景就够了"><a href="#文件下载-搞懂这9种场景就够了" class="header-anchor">#</a> 文件下载，搞懂这9种场景就够了</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/R43JRj1e3XWFsxK5fQ30Bw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/R43JRj1e3XWFsxK5fQ30Bw<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>一般在我们工作中，主要会涉及到 9 种文件下载的场景，每一种场景背后都使用不同的技术，其中也有很多细节需要我们额外注意。今天阿宝哥就来带大家总结一下这 9 种场景，让大家能够轻松地应对各种下载场景。阅读本文后，你将会了解以下的内容：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruRbQVsfnaI8hPV253hnNmWCTrbAJcricI4XqbfspQkb2Ho2HuQm4Rdtw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>在浏览器端处理文件的时候，我们经常会用到 Blob 。比如图片本地预览、图片压缩、大文件分块上传及文件下载。在浏览器端文件下载的场景中，比如我们今天要讲到的 <strong>a 标签下载</strong>、<strong>showSaveFilePicker API 下载</strong>、<strong>Zip 下载</strong> 等场景中，都会使用到 Blob ，所以我们有必要在学习具体应用前，先掌握它的相关知识，这样可以帮助我们更好地了解示例代码。</p> <h3 id="一、基础知识"><a href="#一、基础知识" class="header-anchor">#</a> 一、基础知识</h3> <h4 id="_1-1-了解-blob"><a href="#_1-1-了解-blob" class="header-anchor">#</a> 1.1 了解 Blob</h4> <p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示一个不可变、原始数据的类文件对象。</strong> 它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 用于数据操作。</p> <p><code>Blob</code> 对象由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">在 JavaScript 中你可以通过 Blob 的构造函数来创建 Blob 对象，Blob 构造函数的语法如下：</p> <div class="language- extra-class"><pre class="language-text"><code>const aBlob = new Blob(blobParts, options);
</code></pre></div><p>相关的参数说明如下：</p> <ul><li><p>blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。</p></li> <li><p>options：一个可选的对象，包含以下两个属性：</p></li> <li><ul><li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li> <li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。 它是以下两个值中的一个： <code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li></ul></li></ul> <h4 id="_1-2-了解-blob-url"><a href="#_1-2-了解-blob-url" class="header-anchor">#</a> 1.2 了解 Blob URL</h4> <p>Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像、下载二进制数据链接等的 URL 源。在浏览器中，我们使用 <code>URL.createObjectURL</code> 方法来创建 Blob URL，该方法接收一个 <code>Blob</code> 对象，并为其创建一个唯一的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code>，对应的示例如下：</p> <div class="language- extra-class"><pre class="language-text"><code>blob:http://localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59
</code></pre></div><p>浏览器内部为每个通过 <code>URL.createObjectURL</code> 生成的 URL 存储了一个 <strong>URL → Blob</strong> 映射。因此，此类 URL 较短，但可以访问 <code>Blob</code>。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 <code>&lt;img&gt;</code>、<code>&lt;a&gt;</code> 中的 <code>Blob</code>，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p> <p>上述的 Blob URL 看似很不错，但实际上它也有副作用。 <strong>虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放</strong>。但是，如果应用程序寿命很长，那么 Blob 在短时间内将无法被浏览器释放。因此，如果你创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。</p> <p>针对这个问题，你可以调用 <code>URL.revokeObjectURL(url)</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p> <p>现在你已经了解了 Blob 和 Blob URL，如果你还意犹未尽，想深入理解 Blob 的话，可以阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247484522&amp;idx=1&amp;sn=7028aa65a4dec0f2d0cb847838703bc3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">你不知道的 Blob<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章。下面我们开始介绍客户端文件下载的场景。</p> <p>随着 Web 技术的不断发展，浏览器的功能也越来越强大。这些年出现了很多在线 Web 设计工具，比如在线 PS、在线海报设计器或在线自定义表单设计器等。这些 Web 设计器允许用户在完成设计之后，把生成的文件保存到本地，其中有一部分设计器就是利用浏览器提供的 Web API 来实现客户端文件下载。下面阿宝哥先来介绍客户端下载中，最常见的 <strong>a 标签下载</strong>方案。</p> <h3 id="二、a-标签下载"><a href="#二、a-标签下载" class="header-anchor">#</a> 二、a 标签下载</h3> <p><strong>html</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;a 标签下载示例&lt;/h3&gt;
&lt;div&gt;
  &lt;img src=&quot;../images/body.png&quot; /&gt;
  &lt;img src=&quot;../images/eyes.png&quot; /&gt;
  &lt;img src=&quot;../images/mouth.png&quot; /&gt;
&lt;/div&gt;
&lt;img id=&quot;mergedPic&quot; src=&quot;http://via.placeholder.com/256&quot; /&gt;
&lt;button onclick=&quot;merge()&quot;&gt;图片合成&lt;/button&gt;
&lt;button onclick=&quot;download()&quot;&gt;图片下载&lt;/button&gt;
</code></pre></div><p>在以上代码中，我们通过 <code>img</code> 标签引用了以下 3 张素材：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>当用户点击 <strong>图片合成</strong> 按钮时，会将合成的图片显示在 <code>img#mergedPic</code> 容器中。在图片成功合成之后，用户可以通过点击 <strong>图片下载</strong> 按钮把已合成的图片下载到本地。对应的操作流程如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>由上图可知，整体的操作流程相对简单。接下来，我们来看一下 <strong>图片合成</strong> 和 <strong>图片下载</strong> 的实现逻辑。</p> <p><strong>js</strong></p> <p>图片合成的功能，阿宝哥是直接使用 Github 上 merge-images 这个第三方库来实现。利用该库提供的 <code>mergeImages(images, [options])</code> 方法，我们可以轻松地实现图片合成的功能。调用该方法后，会返回一个 Promise 对象，当异步操作完成后，合成的图片会以 Data URLs 的格式返回。</p> <div class="language- extra-class"><pre class="language-text"><code>const mergePicEle = document.querySelector(&quot;#mergedPic&quot;);
const images = [&quot;/body.png&quot;, &quot;/eyes.png&quot;, &quot;/mouth.png&quot;].map(
  (path) =&gt; &quot;../images&quot; + path
);
let imgDataUrl = null;

async function merge() {
  imgDataUrl = await mergeImages(images);
  mergePicEle.src = imgDataUrl;
}
</code></pre></div><p>而图片下载的功能是借助 <code>dataUrlToBlob</code> 和 <code>saveFile</code> 这两个函数来实现。它们分别用于实现 <strong>Data URLs =&gt; Blob</strong> 的转换和文件的保存，具体的代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>function dataUrlToBlob(base64, mimeType) {
  let bytes = window.atob(base64.split(&quot;,&quot;)[1]);
  let ab = new ArrayBuffer(bytes.length);
  let ia = new Uint8Array(ab);
  for (let i = 0; i &lt; bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeType });
}

// 保存文件
function saveFile(blob, filename) {
  const a = document.createElement(&quot;a&quot;);
  a.download = filename;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href)
}
</code></pre></div><p>因为本文的主题是介绍文件下载，所以我们来重点分析 <code>saveFile</code> 函数。在该函数内部，我们使用了 <strong>HTMLAnchorElement.download</strong> 属性，该属性值表示下载文件的名称。如果该名称不是操作系统的有效文件名，浏览器将会对其进行调整。此外，该属性的作用是表明链接的资源将被下载，而不是显示在浏览器中。</p> <p>需要注意的是，<code>download</code> 属性存在兼容性问题，比如 IE 11 及以下的版本不支持该属性，具体如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>（图片来源：https://caniuse.com/download）</p> <p>当设置好 a 元素的 <code>download</code> 属性之后，我们会调用 <code>URL.createObjectURL</code> 方法来创建 Object URL，并把返回的 URL 赋值给 a 元素的 <code>href</code> 属性。接着通过调用 a 元素的 <code>click</code> 方法来触发文件的下载操作，最后还会调用一次 <code>URL.revokeObjectURL</code> 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。</p> <p>关于 <strong>a 标签下载</strong> 的内容就介绍到这，下面我们来介绍如何使用新的 Web API —— <code>showSaveFilePicker</code> 实现文件下载。</p> <blockquote><p>a 标签下载示例：a-tag</p> <p>https://github.com/semlinker/file-download-demos/tree/main/a-tag</p></blockquote> <h3 id="三、showsavefilepicker-api-下载"><a href="#三、showsavefilepicker-api-下载" class="header-anchor">#</a> 三、showSaveFilePicker API 下载</h3> <p>showSaveFilePicker API 是 <code>Window</code> 接口中定义的方法，调用该方法后会显示允许用户选择保存路径的文件选择器。该方法的签名如下所示：</p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>let FileSystemFileHandle = Window.showSaveFilePicker(options);
</code></pre></div></blockquote> <p>showSaveFilePicker 方法支持一个对象类型的可选参数，可包含以下属性：</p> <ul><li><p><code>excludeAcceptAllOption</code>：布尔类型，默认值为 <code>false</code>。默认情况下，选择器应包含一个不应用任何文件类型过滤器的选项（由下面的 <code>types</code> 选项启用）。将此选项设置为 <code>true</code> 意味着 <code>types</code> 选项不可用。</p></li> <li><p><code>types</code>：数组类型，表示允许保存的文件类型列表。数组中的每一项是包含以下属性的配置对象：</p></li> <li><ul><li><code>description（可选）</code>：用于描述允许保存文件类型类别。</li> <li><code>accept</code>：是一个对象，该对象的 <code>key</code> 是 MIME 类型，值是文件扩展名列表。</li></ul></li></ul> <p>调用 showSaveFilePicker 方法之后，会返回一个 FileSystemFileHandle 对象。有了该对象，你就可以调用该对象上的方法来操作文件。比如调用该对象上的 createWritable 方法之后，就会返回 FileSystemWritableFileStream 对象，就可以把数据写入到文件中。具体的使用方式如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>async function saveFile(blob, filename) {
  try {
    const handle = await window.showSaveFilePicker({
      suggestedName: filename,
      types: [
        {
          description: &quot;PNG file&quot;,
          accept: {
            &quot;image/png&quot;: [&quot;.png&quot;],
          },
        },
        {
          description: &quot;Jpeg file&quot;,
          accept: {
            &quot;image/jpeg&quot;: [&quot;.jpeg&quot;],
          },
         },
      ],
     });
    const writable = await handle.createWritable();
    await writable.write(blob);
    await writable.close();
    return handle;
  } catch (err) {
     console.error(err.name, err.message);
  }
}

function download() {
  if (!imgDataUrl) {
    alert(&quot;请先合成图片&quot;);
    return;
  }
  const imgBlob = dataUrlToBlob(imgDataUrl, &quot;image/png&quot;);
  saveFile(imgBlob, &quot;face.png&quot;);
}
</code></pre></div><p>当你使用以上更新后的 <code>saveFile</code> 函数，来保存已合成的图片时，会显示以下保存文件选择器：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruoaM2spbCVGicI8oAjbMwxRxr3S4pGVIpAGVibCC4vFKaibrkSUkZeyrYQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>由上图可知，相比 <strong>a 标签下载</strong> 的方式，showSaveFilePicker API 允许你选择文件的下载目录、选择文件的保存格式和更改存储的文件名称。看到这里是不是觉得 showSaveFilePicker API 功能挺强大的，不过可惜的是该 API 目前的兼容性还不是很好，具体如下图所示：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruibAfheTAklQBHdibHhr50xPzqJXWcXMYdx2rib2yVorH2icZiaNCp25A2Lg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>（图片来源：https://caniuse.com/?search=showSaveFilePicker）</p> <p>其实 showSaveFilePicker 是 File System Access API 中定义的方法，除了 showSaveFilePicker 之外，还有 showOpenFilePicker 和 showDirectoryPicker 等方法。如果你想在实际项目中使用这些 API 的话，可以考虑使用 <strong>GoogleChromeLabs</strong> 开源的 browser-fs-access 这个库，该库可以让你在支持平台上更方便地使用 File System Access API，对于不支持的平台会自动降级使用 <code>&lt;input type=&quot;file&quot;&gt;</code> 和 <code>&lt;a download&gt;</code> 的方式。</p> <p>可能大家对 browser-fs-access 这个库会比较陌生，但是如果换成是 FileSaver.js  这个库的话，应该就比较熟悉了。接下来，我们来介绍如何利用 FileSaver.js 这个库实现客户端文件下载。</p> <blockquote><p>showSaveFilePicker API 下载示例：save-file-picker</p> <p>https://github.com/semlinker/file-download-demos/tree/main/save-file-picker</p></blockquote> <h3 id="四、filesaver-下载"><a href="#四、filesaver-下载" class="header-anchor">#</a> 四、FileSaver 下载</h3> <p>FileSaver.js 是在客户端保存文件的解决方案，非常适合在客户端上生成文件的 Web 应用程序。它是 HTML5 版本的 saveAs() FileSaver 实现，支持大多数主流的浏览器，其兼容性如下图所示：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruiasMiaW6jTgMT8ynYZ1ES1P4EvFDBIibXrVZN1ldw6BjP5Pndiadiap8QsQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>（图片来源：https://github.com/eligrey/FileSaver.js）</p> <p>在引入 FileSaver.js 这个库之后，我们就可以使用它提供的 <code>saveAs</code> 方法来保存文件。该方法对应的签名如下所示：</p> <blockquote><div class="language- extra-class"><pre class="language-text"><code>FileSaver saveAs(
 Blob/File/Url, 
 optional DOMString filename, 
 optional Object { autoBom }
)
</code></pre></div></blockquote> <p>saveAs 方法支持 3 个参数，第 1 个参数表示它支持 <code>Blob/File/Url</code> 三种类型，第 2 个参数表示文件名（可选），而第 3 个参数表示配置对象（可选）。如果你需要 FlieSaver.js 自动提供 Unicode 文本编码提示（参考：字节顺序标记），则需要设置 <code>{ autoBom: true}</code>。</p> <p>了解完 saveAs 方法之后，我们来举 3 个具体的使用示例：</p> <p><strong>1. 保存文本</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let blob = new Blob([&quot;大家好，我是阿宝哥!&quot;], { type: &quot;text/plain;charset=utf-8&quot; });
saveAs(blob, &quot;hello.txt&quot;);
</code></pre></div><p><strong>2. 保存线上资源</strong></p> <div class="language- extra-class"><pre class="language-text"><code>saveAs(&quot;https://httpbin.org/image&quot;, &quot;image.jpg&quot;);
</code></pre></div><p>如果下载的 URL 地址与当前站点是同域的，则将使用 <code>a[download]</code> 方式下载。否则，会先使用 <strong>同步的 HEAD 请求</strong> 来判断是否支持 CORS 机制，若支持的话，将进行数据下载并使用 Blob URL 实现文件下载。如果不支持 CORS 机制的话，将会尝试使用 <code>a[download]</code>方式下载。</p> <p>标准的 W3C File API Blob 接口并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 Blob.js 来解决兼容性问题。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruCuOj2S2NNwtV4WCrYTkp0Vbpmsb2W0kl7Oq3aQBbH8aQMpw0katAQg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>（图片来源：https://caniuse.com/?search=blob）</p> <p><strong>3. 保存 canvas 画布内容</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let canvas = document.getElementById(&quot;my-canvas&quot;);
canvas.toBlob(function(blob) {
  saveAs(blob, &quot;abao.png&quot;);
});
</code></pre></div><p>需要注意的是 <code>canvas.toBlob()</code> 方法并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 canvas-toBlob.js 来解决兼容性问题。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ru0najESdoiaUyt2XEWlYXibrAibuv4F4D5fOeMd90KzIDXu96AibYEOGjUA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>（图片来源：https://caniuse.com/?search=toBlob）</p> <p>介绍完 saveAs 方法的使用示例之后，我们来更新前面示例中的 <code>download</code> 方法：</p> <div class="language- extra-class"><pre class="language-text"><code>function download() {
  if (!imgDataUrl) {
    alert(&quot;请先合成图片&quot;);
    return;
  }
  const imgBlob = dataUrlToBlob(imgDataUrl, &quot;image/png&quot;);
  saveAs(imgBlob, &quot;face.png&quot;);
}
</code></pre></div><p>很明显，使用 saveAs 方法之后，下载已合成的图片就很简单了。如果你对 FileSaver.js 的工作原理感兴趣的话，可以阅读 聊一聊 15.5K 的 FileSaver，是如何工作的？ 这篇文章。前面介绍的场景都是直接下载单个文件，其实我们也可以在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包并下载到本地。</p> <blockquote><p>FileSaver 下载示例：file-saver</p> <p>https://github.com/semlinker/file-download-demos/tree/main/file-saver</p></blockquote> <h3 id="五、zip-下载"><a href="#五、zip-下载" class="header-anchor">#</a> 五、Zip 下载</h3> <p>在 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247493294&amp;idx=1&amp;sn=85642a71feae9f1df2abf1110f721054&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">文件上传，搞懂这8种场景就够了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章中，阿宝哥介绍了如何利用 JSZip 这个库提供的 API，把待上传目录下的所有文件压缩成 ZIP 文件，然后再把生成的 ZIP 文件上传到服务器。同样，利用 JSZip 这个库，我们可以实现在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包，并下载到本地的功能。对应的操作流程如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>在以上 Gif 图中，阿宝哥演示了把 3 张素材图，打包成 Zip 文件并下载到本地的过程。接下来，我们来介绍如何使用 JSZip 这个库实现以上的功能。</p> <p><strong>html</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;Zip 下载示例&lt;/h3&gt;
&lt;div&gt;
  &lt;img src=&quot;../images/body.png&quot; /&gt;
  &lt;img src=&quot;../images/eyes.png&quot; /&gt;
  &lt;img src=&quot;../images/mouth.png&quot; /&gt;
&lt;/div&gt;
&lt;button onclick=&quot;download()&quot;&gt;打包下载&lt;/button&gt;
</code></pre></div><p><strong>js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const images = [&quot;body.png&quot;, &quot;eyes.png&quot;, &quot;mouth.png&quot;];
const imageUrls = images.map((name) =&gt; &quot;../images/&quot; + name);

async function download() {
  let zip = new JSZip();
  Promise.all(imageUrls.map(getFileContent)).then((contents) =&gt; {
    contents.forEach((content, i) =&gt; {
      zip.file(images[i], content);
    });
    zip.generateAsync({ type: &quot;blob&quot; }).then(function (blob) {
      saveAs(blob, &quot;material.zip&quot;);
    });
  });
}

// 从指定的url上下载文件内容
function getFileContent(fileUrl) {
  return new JSZip.external.Promise(function (resolve, reject) {
    // 调用jszip-utils库提供的getBinaryContent方法获取文件内容
    JSZipUtils.getBinaryContent(fileUrl, function (err, data) {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}
</code></pre></div><p>在以上代码中，当用户点击 <strong>打包下载</strong> 按钮时，就会调用 <code>download</code> 函数。在该函数内部，会先调用 <code>JSZip</code> 构造函数创建 <code>JSZip</code> 对象，然后使用 Promise.all 函数来确保所有的文件都下载完成后，再调用 <code>file(name, data [,options])</code> 方法，把已下载的文件添加到前面创建的 <code>JSZip</code> 对象中。最后通过 <code>zip.generateAsync</code> 函数来生成 Zip 文件并使用 FileSaver.js 提供的 <code>saveAs</code> 方法保存 Zip 文件。</p> <blockquote><p>Zip 下载示例：Zip</p> <p>https://github.com/semlinker/file-download-demos/tree/main/jszip</p></blockquote> <h3 id="六、附件形式下载"><a href="#六、附件形式下载" class="header-anchor">#</a> 六、附件形式下载</h3> <p>在服务端下载的场景中，附件形式下载是一种比较常见的场景。在该场景下，我们通过设置 <code>Content-Disposition</code> 响应头来指示响应的内容以何种形式展示，是以内联（inline）的形式，还是以附件（attachment）的形式下载并保存到本地。</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Disposition: inline
Content-Disposition: attachment
Content-Disposition: attachment; filename=&quot;mouth.png&quot;
</code></pre></div><p>而在 HTTP 表单的场景下， <code>Content-Disposition</code> 也可以作为 <strong>multipart body</strong> 中的消息头：</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Disposition: form-data
Content-Disposition: form-data; name=&quot;fieldName&quot;
Content-Disposition: form-data; name=&quot;fieldName&quot;; filename=&quot;filename.jpg&quot;
</code></pre></div><p>第 1 个参数总是固定不变的 <code>form-data</code>；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号（<code>=</code>）连接，参数值用双引号括起来。参数之间用分号（<code>;</code>）分隔。</p> <p>了解完 <code>Content-Disposition</code> 的作用之后，我们来看一下如何实现以附件形式下载的功能。Koa 是一个简单易用的 Web 框架，它的特点是优雅、简洁、轻量、自由度高。所以我们选择它来搭建文件服务，并使用 @koa/router 中间件来处理路由：</p> <div class="language- extra-class"><pre class="language-text"><code>// attachment/file-server.js
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const Koa = require(&quot;koa&quot;);
const Router = require(&quot;@koa/router&quot;);

const app = new Koa();
const router = new Router();
const PORT = 3000;
const STATIC_PATH = path.join(__dirname, &quot;./static/&quot;);

// http://localhost:3000/file?filename=mouth.png
router.get(&quot;/file&quot;, async (ctx, next) =&gt; {
  const { filename } = ctx.query;
  const filePath = STATIC_PATH + filename;
  const fStats = fs.statSync(filePath);
  ctx.set({
    &quot;Content-Type&quot;: &quot;application/octet-stream&quot;,
    &quot;Content-Disposition&quot;: `attachment; filename=${filename}`,
    &quot;Content-Length&quot;: fStats.size,
  });
  ctx.body = fs.createReadStream(filePath);
});

// 注册中间件
app.use(async (ctx, next) =&gt; {
  try {
    await next();
  } catch (error) {
    // ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录
    ctx.status = error.code === &quot;ENOENT&quot; ? 404 : 500;
    ctx.body = error.code === &quot;ENOENT&quot; ? &quot;文件不存在&quot; : &quot;服务器开小差&quot;;
  }
});
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, () =&gt; {
  console.log(`应用已经启动：http://localhost:${PORT}/`);
});
</code></pre></div><p>以上的代码被保存在 <code>attachment</code> 目录下的 <code>file-server.js</code> 文件中，该目录下还有一个 <code>static</code> 子目录用于存放静态资源。目前 <code>static</code> 目录下包含以下 3 个 png 文件。</p> <div class="language- extra-class"><pre class="language-text"><code>├── file-server.js
└── static
    ├── body.png
    ├── eyes.png
    └── mouth.png
</code></pre></div><p>当你运行 <code>node file-server.js</code> 命令成功启动文件服务器之后，就可以通过正确的 URL 地址来下载 <code>static</code> 目录下的文件。比如在浏览器中打开 <code>http://localhost:3000/file?filename=mouth.png</code> 这个地址，你就会开始下载 <code>mouth.png</code> 文件。而如果指定的文件不存在的话，就会返回文件不存在。</p> <p>Koa 内核很简洁，扩展功能都是通过中间件来实现。比如常用的路由、CORS、静态资源处理等功能都是通过中间件实现。因此要想掌握 Koa 这个框架，核心是掌握它的中间件机制。若你想深入了解 Koa 的话，可以阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247486886&amp;idx=1&amp;sn=63bffec358b77986558e868d1adc2183&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">如何更好地理解中间件和洋葱模型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章。</p> <p>在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 Data URLs 的特性，允许使用 Base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。所以文件也可以通过 Base64 的格式进行传输，接下来我们将介绍如何下载 Base64 格式的图片。</p> <blockquote><p>附件形式下载示例：attachment</p> <p>https://github.com/semlinker/file-download-demos/tree/main/attachment</p></blockquote> <h3 id="七、base64-格式下载"><a href="#七、base64-格式下载" class="header-anchor">#</a> 七、base64 格式下载</h3> <p><strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2⁶ = 64 ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。相应的转换过程如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><strong>Base64 常用在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong> 在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。</p> <p>Base64 的相关内容就先介绍到这，如果你想进一步了解 Base64 的话，可以阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247489632&amp;idx=1&amp;sn=68f123f9be1ac5a47528bf0b682e8bfe&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">一文读懂base64编码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章。下面我们来看一下具体实现代码：</p> <h4 id="_7-1-前端代码"><a href="#_7-1-前端代码" class="header-anchor">#</a> 7.1 前端代码</h4> <p><strong>html</strong></p> <p>在以下 HTML 代码中，我们通过 <code>select</code> 元素来让用户选择要下载的图片。当用户切换不同的图片时，<code>img#imgPreview</code> 元素中显示的图片会随之发生变化。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;base64 下载示例&lt;/h3&gt;
&lt;img id=&quot;imgPreview&quot; src=&quot;./static/body.png&quot; /&gt;
&lt;select id=&quot;picSelect&quot;&gt;
   &lt;option value=&quot;body&quot;&gt;body.png&lt;/option&gt;
   &lt;option value=&quot;eyes&quot;&gt;eyes.png&lt;/option&gt;
   &lt;option value=&quot;mouth&quot;&gt;mouth.png&lt;/option&gt;
&lt;/select&gt;
&lt;button onclick=&quot;download()&quot;&gt;下载&lt;/button&gt;
</code></pre></div><p><strong>js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const picSelectEle = document.querySelector(&quot;#picSelect&quot;);
const imgPreviewEle = document.querySelector(&quot;#imgPreview&quot;);

picSelectEle.addEventListener(&quot;change&quot;, (event) =&gt; {
  imgPreviewEle.src = &quot;./static/&quot; + picSelectEle.value + &quot;.png&quot;;
});

const request = axios.create({
  baseURL: &quot;http://localhost:3000&quot;,
  timeout: 60000,
});

async function download() {
  const response = await request.get(&quot;/file&quot;, {
    params: {
      filename: picSelectEle.value + &quot;.png&quot;,
    },
  });
  if (response &amp;&amp; response.data &amp;&amp; response.data.code === 1) {
    const fileData = response.data.data;
    const { name, type, content } = fileData;
    const imgBlob = base64ToBlob(content, type);
    saveAs(imgBlob, name);
  }
}
</code></pre></div><p>在用户选择好需要下载的图片并点击下载按钮时，就会调用以上代码中的 <code>download</code> 函数。在该函数内部，我们利用 axios 实例的 <code>get</code> 方法发起 HTTP 请求来获取指定的图片。因为返回的是 base64 格式的图片，所以在调用 FileSaver 提供的 <code>saveAs</code> 方法前，我们需要将 base64 字符串转换成 blob 对象，该转换是通过以下的 <code>base64ToBlob</code> 函数来完成，该函数的具体实现如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>function base64ToBlob(base64, mimeType) {
  let bytes = window.atob(base64);
  let ab = new ArrayBuffer(bytes.length);
  let ia = new Uint8Array(ab);
  for (let i = 0; i &lt; bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeType });
}
</code></pre></div><h4 id="_7-2-服务端代码"><a href="#_7-2-服务端代码" class="header-anchor">#</a> 7.2 服务端代码</h4> <div class="language- extra-class"><pre class="language-text"><code>// base64/file-server.js
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const mime = require(&quot;mime&quot;);
const Koa = require(&quot;koa&quot;);
const cors = require(&quot;@koa/cors&quot;);
const Router = require(&quot;@koa/router&quot;);

const app = new Koa();
const router = new Router();
const PORT = 3000;
const STATIC_PATH = path.join(__dirname, &quot;./static/&quot;);

router.get(&quot;/file&quot;, async (ctx, next) =&gt; {
  const { filename } = ctx.query;
  const filePath = STATIC_PATH + filename;
  const fileBuffer = fs.readFileSync(filePath);
  ctx.body = {
    code: 1,
    data: {
      name: filename,
      type: mime.getType(filename),
      content: fileBuffer.toString(&quot;base64&quot;),
    },
  };
});

// 注册中间件
app.use(async (ctx, next) =&gt; {
  try {
    await next();
  } catch (error) {
    ctx.body = {
      code: 0,
      msg: &quot;服务器开小差&quot;,
    };
  }
});
app.use(cors());
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, () =&gt; {
  console.log(`应用已经启动：http://localhost:${PORT}/`);
});
</code></pre></div><p>在以上代码中，对图片进行 Base64 编码的操作是定义在 <code>/file</code> 路由对应的路由处理器中。当该服务器接收到客户端发起的文件下载请求，比如 <code>GET /file?filename=body.png HTTP/1.1</code> 时，就会从 <code>ctx.query</code> 对象上获取 <code>filename</code> 参数。该参数表示文件的名称，在获取到文件的名称之后，我们就可以拼接出文件的绝对路径，然后通过 Node.js 平台提供的 <code>fs.readFileSync</code> 方法读取文件的内容，该方法会返回一个 Buffer 对象。在成功读取文件的内容之后，我们会继续调用 Buffer 对象的 <code>toString</code> 方法对文件内容进行 Base64 编码，最终所下载的图片将以 Base64 格式返回到客户端。</p> <blockquote><p>base64 格式下载示例：base64</p> <p>https://github.com/semlinker/file-download-demos/tree/main/base64</p></blockquote> <h3 id="八、chunked-下载"><a href="#八、chunked-下载" class="header-anchor">#</a> 八、chunked 下载</h3> <p>分块传输编码主要应用于如下场景，即要传输大量的数据，但是在请求在没有被处理完之前响应的长度是无法获得的。例如，当需要用从数据库中查询获得的数据生成一个大的 HTML 表格的时候，或者需要传输大量的图片的时候。</p> <p>要使用分块传输编码，则需要在响应头配置 <code>Transfer-Encoding</code> 字段，并设置它的值为 <code>chunked</code> 或 <code>gzip, chunked</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>Transfer-Encoding: chunked
Transfer-Encoding: gzip, chunked
</code></pre></div><p>响应头 <code>Transfer-Encoding</code> 字段的值为 <code>chunked</code>，表示数据以一系列分块的形式进行发送。需要注意的是 <code>Transfer-Encoding</code> 和 <code>Content-Length</code> 这两个字段是互斥的，也就是说响应报文中这两个字段不能同时出现。下面我们来看一下分块传输的编码规则：</p> <ul><li>每个分块包含分块长度和数据块两个部分；</li> <li>分块长度使用 16 进制数字表示，以 <code>\r\n</code> 结尾；</li> <li>数据块紧跟在分块长度后面，也使用 <code>\r\n</code> 结尾，但数据不包含 <code>\r\n</code>；</li> <li>终止块是一个常规的分块，表示块的结束。不同之处在于其长度为 0，即 <code>0\r\n\r\n</code>。</li></ul> <p>了解完分块传输的编码规则，我们来看如何利用分块传输编码实现文件下载。</p> <h4 id="_8-1-前端代码"><a href="#_8-1-前端代码" class="header-anchor">#</a> 8.1 前端代码</h4> <p><strong>html5</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;chunked 下载示例&lt;/h3&gt;
&lt;button onclick=&quot;download()&quot;&gt;下载&lt;/button&gt;
</code></pre></div><p><strong>js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const chunkedUrl = &quot;http://localhost:3000/file?filename=file.txt&quot;;

function download() {
  return fetch(chunkedUrl)
    .then(processChunkedResponse)
    .then(onChunkedResponseComplete)
    .catch(onChunkedResponseError);
}

function processChunkedResponse(response) {
  let text = &quot;&quot;;
  let reader = response.body.getReader();
  let decoder = new TextDecoder();

  return readChunk();

  function readChunk() {
    return reader.read().then(appendChunks);
  }

  function appendChunks(result) {
    let chunk = decoder.decode(result.value || new Uint8Array(), {
      stream: !result.done,
    });
    console.log(&quot;已接收到的数据：&quot;, chunk);
    console.log(&quot;本次已成功接收&quot;, chunk.length, &quot;bytes&quot;);
    text += chunk;
    console.log(&quot;目前为止共接收&quot;, text.length, &quot;bytes\n&quot;);
    if (result.done) {
      return text;
    } else {
      return readChunk();
    }
  }
}

function onChunkedResponseComplete(result) {
  let blob = new Blob([result], {
    type: &quot;text/plain;charset=utf-8&quot;,
  });
  saveAs(blob, &quot;hello.txt&quot;);
}

function onChunkedResponseError(err) {
  console.error(err);
}
</code></pre></div><p>当用户点击 <strong>下载</strong> 按钮时，就会调用以上代码中的 <code>download</code> 函数。在该函数内部，我们会使用 Fetch API 来执行下载操作。因为服务端的数据是以一系列分块的形式进行发送，所以在浏览器端我们是通过流的形式进行接收。即通过 <code>response.body</code> 获取可读的 ReadableStream，然后用 <code>ReadableStream.getReader()</code> 创建一个读取器，最后调用 <code>reader.read</code> 方法来读取已返回的分块数据。</p> <p>因为 <code>file.txt</code> 文件的内容是普通文本，且 <code>result.value</code> 的值是 Uint8Array 类型的数据，所以在处理返回的分块数据时，我们使用了 TextDecoder 文本解码器。一个解码器只支持一种特定文本编码，例如 <code>utf-8</code>、<code>iso-8859-2</code>、<code>koi8</code>、<code>cp1261</code>，<code>gbk</code> 等等。</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>如果收到的分块非 <strong>终止块</strong>，<code>result.done</code> 的值是 <code>false</code>，则会继续调用 <code>readChunk</code>方法来读取分块数据。而当接收到 <strong>终止块</strong> 之后，表示分块数据已传输完成。此时，<code>result.done</code> 属性就会返回 <code>true</code>。从而会自动调用 <code>onChunkedResponseComplete</code> 函数，在该函数内部，我们以解码后的文本作为参数来创建 Blob 对象。之后，继续使用 FileSaver 库提供的 <code>saveAs</code> 方法实现文件下载。</p> <p>这里我们用 <strong>Wireshark</strong> 网络包分析工具，抓了个数据包。具体如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>从图中我们可以清楚地看到在 <strong>HTTP chunked response</strong> 下面包含了 **Data chunk（数据块）**和 <strong>End of chunked encoding（终止块）</strong>。接下来，我们来看一下服务端的代码。</p> <h4 id="_8-2-服务端代码"><a href="#_8-2-服务端代码" class="header-anchor">#</a> 8.2 服务端代码</h4> <div class="language- extra-class"><pre class="language-text"><code>const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const Koa = require(&quot;koa&quot;);
const cors = require(&quot;@koa/cors&quot;);
const Router = require(&quot;@koa/router&quot;);

const app = new Koa();
const router = new Router();
const PORT = 3000;

router.get(&quot;/file&quot;, async (ctx, next) =&gt; {
  const { filename } = ctx.query;
  const filePath = path.join(__dirname, filename);
  ctx.set({
    &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,
  });
  ctx.body = fs.createReadStream(filePath);
});

// 注册中间件
app.use(async (ctx, next) =&gt; {
  try {
    await next();
  } catch (error) {
    // ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录
    ctx.status = error.code === &quot;ENOENT&quot; ? 404 : 500;
    ctx.body = error.code === &quot;ENOENT&quot; ? &quot;文件不存在&quot; : &quot;服务器开小差&quot;;
  }
});
app.use(cors());
app.use(router.routes()).use(router.allowedMethods());

app.listen(PORT, () =&gt; {
  console.log(`应用已经启动：http://localhost:${PORT}/`);
});
</code></pre></div><p>在 <code>/file</code> 路由处理器中，我们先通过 <code>ctx.query</code> 获得 <code>filename</code> 文件名，接着拼接出该文件的绝对路径，然后通过 Node.js 平台提供的 <code>fs.createReadStream</code> 方法创建可读流。最后把已创建的可读流赋值给 <code>ctx.body</code> 属性，从而向客户端返回图片数据。</p> <p>现在我们已经知道可以利用分块传输编码（Transfer-Encoding）实现数据的分块传输，那么有没有办法获取指定范围内的文件数据呢？对于这个问题，我们可以利用 HTTP 协议的范围请求。接下来，我们将介绍如何利用 HTTP 范围请求来下载指定范围的数据。</p> <blockquote><p>chunked 下载示例：chunked</p> <p>https://github.com/semlinker/file-download-demos/tree/main/chunked</p></blockquote> <h3 id="九、范围下载"><a href="#九、范围下载" class="header-anchor">#</a> 九、范围下载</h3> <p>HTTP 协议范围请求允许服务器只发送 HTTP 消息的一部分到客户端。范围请求在传送大的媒体文件，或者与文件下载的断点续传功能搭配使用时非常有用。如果在响应中存在 <code>Accept-Ranges</code> 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。</p> <p>在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 <strong>206 Partial Content</strong> 状态码。假如所请求的范围不合法，那么服务器会返回 <strong>416 Range Not Satisfiable</strong> 状态码，表示客户端错误。服务器允许忽略 Range 首部，从而返回整个文件，状态码用 200 。</p> <p><strong>Range 语法：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Range: &lt;unit&gt;=&lt;range-start&gt;-
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;
</code></pre></div><ul><li><code>unit</code>：范围请求所采用的单位，通常是字节（bytes）。</li> <li><code>&lt;range-start&gt;</code>：一个整数，表示在特定单位下，范围的起始值。</li> <li><code>&lt;range-end&gt;</code>：一个整数，表示在特定单位下，范围的结束值。<strong>这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</strong></li></ul> <p>了解完 <code>Range</code> 语法之后，我们来看一下实际的使用示例：</p> <div class="language- extra-class"><pre class="language-text"><code># 单一范围
$ curl http://i.imgur.com/z4d4kWk.jpg -i -H &quot;Range: bytes=0-1023&quot;
# 多重范围
$ curl http://www.example.com -i -H &quot;Range: bytes=0-50, 100-150&quot;
</code></pre></div><h4 id="_9-1-前端代码"><a href="#_9-1-前端代码" class="header-anchor">#</a> 9.1 前端代码</h4> <p><strong>html</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;范围下载示例&lt;/h3&gt;
&lt;button onclick=&quot;download()&quot;&gt;下载&lt;/button&gt;
</code></pre></div><p><strong>js</strong></p> <div class="language- extra-class"><pre class="language-text"><code>async function download() {
  try {
    let rangeContent = await getBinaryContent(
      &quot;http://localhost:3000/file.txt&quot;,
       0, 100, &quot;text&quot;
    );
    const blob = new Blob([rangeContent], {
      type: &quot;text/plain;charset=utf-8&quot;,
    });
    saveAs(blob, &quot;hello.txt&quot;);
  } catch (error) {
    console.error(error);
  }
}

function getBinaryContent(url, start, end, responseType = &quot;arraybuffer&quot;) {
  return new Promise((resolve, reject) =&gt; {
    try {
      let xhr = new XMLHttpRequest();
      xhr.open(&quot;GET&quot;, url, true);
      xhr.setRequestHeader(&quot;range&quot;, `bytes=${start}-${end}`);
      xhr.responseType = responseType;
      xhr.onload = function () {
        resolve(xhr.response);
      };
        xhr.send();
    } catch (err) {
        reject(new Error(err));
    }
  });
}
</code></pre></div><p>当用户点击 <strong>下载</strong> 按钮时，就会调用 <code>download</code> 函数。在该函数内部会通过调用 <code>getBinaryContent</code> 函数来发起范围请求。对应的 HTTP 请求报文如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>GET /file.txt HTTP/1.1
Host: localhost:3000
Connection: keep-alive
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36
Accept: */*
Accept-Encoding: identity
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,id;q=0.7
Range: bytes=0-100
</code></pre></div><p>而当服务器接收到该范围请求之后，会返回对应的 HTTP 响应报文：</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 206 Partial Content
Vary: Origin
Access-Control-Allow-Origin: null
Accept-Ranges: bytes
Last-Modified: Fri, 09 Jul 2021 00:17:00 GMT
Cache-Control: max-age=0
Content-Type: text/plain; charset=utf-8
Date: Sat, 10 Jul 2021 02:19:39 GMT
Connection: keep-alive
Content-Range: bytes 0-100/2590
Content-Length: 101
</code></pre></div><p>从以上的 HTTP 响应报文中，我们见到了前面介绍的 <strong>206</strong> 状态码和 <strong>Accept-Ranges</strong> 首部。此外，通过 <code>Content-Range</code> 首部，我们就知道了文件的总大小。在成功获取到范围请求的响应体之后，我们就可以使用返回的内容作为参数，调用 Blob 构造函数创建对应的 Blob 对象，进而使用 FileSaver 库提供的 saveAs 方法来下载文件了。</p> <h4 id="_9-2-服务端代码"><a href="#_9-2-服务端代码" class="header-anchor">#</a> 9.2 服务端代码</h4> <div class="language- extra-class"><pre class="language-text"><code>const Koa = require(&quot;koa&quot;);
const cors = require(&quot;@koa/cors&quot;);
const serve = require(&quot;koa-static&quot;);
const range = require(&quot;koa-range&quot;);

const PORT = 3000;
const app = new Koa();

// 注册中间件
app.use(cors());
app.use(range);
app.use(serve(&quot;.&quot;));

app.listen(PORT, () =&gt; {
  console.log(`应用已经启动：http://localhost:${PORT}/`);
});
</code></pre></div><p>服务端的代码相对比较简单，范围请求是通过 koa-range 中间件来实现的。由于篇幅有限，阿宝哥就不展开介绍了。感兴趣的小伙伴，可以自行阅读该中间件的源码。其实范围请求还可以应用在大文件下载的场景，如果文件服务器支持范围请求的话，客户端在下载大文件的时候，就可以考虑使用大文件分块下载的方案。</p> <blockquote><p>范围下载示例：range</p> <p>https://github.com/semlinker/file-download-demos/tree/main/range</p></blockquote> <h3 id="十、大文件分块下载"><a href="#十、大文件分块下载" class="header-anchor">#</a> 十、大文件分块下载</h3> <p>相信有些小伙伴已经了解大文件上传的解决方案，在上传大文件时，为了提高上传的效率，我们一般会使用 Blob.slice 方法对大文件按照指定的大小进行切割，然后在开启多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并。</p> <p>那么对大文件下载来说，我们能否采用类似的思想呢？其实在服务端支持 <code>Range</code> 请求首部的条件下，我们也是可以实现大文件分块下载的功能，具体处理方案如下图所示：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>因为在 JavaScript 中如何实现大文件并发下载？ 这篇文章中，阿宝哥已经详细介绍了大文件并发下载的方案，所以这里就不展开介绍了。我们只回顾一下大文件并发下载的完整流程：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>其实在大文件分块下载的场景中，我们使用了 async-pool 这个库来实现并发控制。该库提供了 ES7 和 ES6 两种不同版本的实现，代码很简洁优雅。如果你想了解 async-pool 是如何实现并发控制的，可以阅读 JavaScript 中如何实现并发控制？ 这篇文章。</p> <blockquote><p>大文件分块下载示例：big-file</p> <p>https://github.com/semlinker/file-download-demos/tree/main/big-file</p></blockquote> <h3 id="十一、总结"><a href="#十一、总结" class="header-anchor">#</a> 十一、总结</h3> <p>本文阿宝哥详细介绍了文件下载的 9 种场景，希望阅读完本文后，你对 9 种场景背后使用的技术有一定的了解。其实在传输文件的过程中，为了提高传输效率，我们可以使用 <code>gzip</code>、<code>deflate</code> 或 <code>br</code> 等压缩算法对文件进行压缩。由于篇幅有限，阿宝哥就不展开介绍了，如果你感兴趣的话，可以阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247492234&amp;idx=1&amp;sn=f4d0ae2014cd90845e08eb8ffb8422c2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">HTTP 传输大文件的几种方案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章。</p> <p>有了文件下载的场景，怎么能缺少文件上传的场景呢？如果你还没阅读过 <a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247493294&amp;idx=1&amp;sn=85642a71feae9f1df2abf1110f721054&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">文件上传，搞懂这 8 种场景就够了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 这篇文章，建议你有空的时候，可以一起了解一下。这里再次感谢掘友们一直以来的支持，如果你们还想了解其他方面的内容，欢迎给阿宝哥留言哟。</p> <h3 id="十二、参考资源"><a href="#十二、参考资源" class="header-anchor">#</a> 十二、参考资源</h3> <ul><li>MDN — showSaveFilePicker</li> <li>MDN — Content-Disposition</li> <li>The File System Access API: simplifying access to local files</li> <li>Reading and writing files and directories with the browser-fs-access library</li> <li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247493294&amp;idx=1&amp;sn=85642a71feae9f1df2abf1110f721054&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">文件上传，搞懂这8种场景就够了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&amp;mid=2247490849&amp;idx=1&amp;sn=9d062c04baeb629d9b69a9fb4e7c3599&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">JavaScript 中如何实现大文件并发下载？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/27/2022, 9:04:59 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tools/手写一个虚拟DOM库.html" class="prev">
        手写一个虚拟DOM库，彻底让你理解diff算法
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.6df8e219.js" defer></script><script src="/assets/js/2.e21ead49.js" defer></script><script src="/assets/js/143.45031fa6.js" defer></script>
  </body>
</html>
