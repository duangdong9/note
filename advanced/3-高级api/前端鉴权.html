<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端鉴权必须了解的5个兄弟：cookie、session、token、jwt、单点登录 | duangdong的note</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.png">
    <link rel="manifest" href="/manifest.json">
    <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?0088ce24040b03f2947322ab31d23414";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
    <script>
  var _hmt = _hmt || [];
  _hmt.push(['_requirePlugin', 'UrlChangeTracker', {
    shouldTrackUrlChange: function (newPath, oldPath) {
      newPath = newPath.split('#')[0];
      oldPath = oldPath.split('#')[0];
      return newPath != oldPath;
    }}
  ]);
  </script>
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="qd-blog,node,vuepress,leetcode,algorithm">
    
    <link rel="preload" href="/assets/css/0.styles.a427ee9b.css" as="style"><link rel="preload" href="/assets/js/app.6df8e219.js" as="script"><link rel="preload" href="/assets/js/2.e21ead49.js" as="script"><link rel="preload" href="/assets/js/22.29894e1b.js" as="script"><link rel="prefetch" href="/assets/js/10.e0bdad61.js"><link rel="prefetch" href="/assets/js/100.82a4c820.js"><link rel="prefetch" href="/assets/js/101.f5d94e3b.js"><link rel="prefetch" href="/assets/js/102.7f36fa51.js"><link rel="prefetch" href="/assets/js/103.085df24a.js"><link rel="prefetch" href="/assets/js/104.76789169.js"><link rel="prefetch" href="/assets/js/105.9efb3db9.js"><link rel="prefetch" href="/assets/js/106.22337f5b.js"><link rel="prefetch" href="/assets/js/107.ac8e17b4.js"><link rel="prefetch" href="/assets/js/108.5fe47bcc.js"><link rel="prefetch" href="/assets/js/109.cf88a409.js"><link rel="prefetch" href="/assets/js/11.e801cea9.js"><link rel="prefetch" href="/assets/js/110.603c3bd4.js"><link rel="prefetch" href="/assets/js/111.26f89c7d.js"><link rel="prefetch" href="/assets/js/112.1ad5bc54.js"><link rel="prefetch" href="/assets/js/113.cde31a40.js"><link rel="prefetch" href="/assets/js/114.a1a2a895.js"><link rel="prefetch" href="/assets/js/115.31c25d8b.js"><link rel="prefetch" href="/assets/js/116.8ed4b493.js"><link rel="prefetch" href="/assets/js/117.c802c1ce.js"><link rel="prefetch" href="/assets/js/118.15aead28.js"><link rel="prefetch" href="/assets/js/119.c26b6aad.js"><link rel="prefetch" href="/assets/js/12.9ed8f981.js"><link rel="prefetch" href="/assets/js/120.c3410f53.js"><link rel="prefetch" href="/assets/js/121.357fc3f4.js"><link rel="prefetch" href="/assets/js/122.6ecee0a8.js"><link rel="prefetch" href="/assets/js/123.6b38e86a.js"><link rel="prefetch" href="/assets/js/124.463231bb.js"><link rel="prefetch" href="/assets/js/125.dc9f9675.js"><link rel="prefetch" href="/assets/js/126.97f340de.js"><link rel="prefetch" href="/assets/js/127.080209f1.js"><link rel="prefetch" href="/assets/js/128.dd7fed27.js"><link rel="prefetch" href="/assets/js/129.e9a49c7b.js"><link rel="prefetch" href="/assets/js/13.fb60e043.js"><link rel="prefetch" href="/assets/js/130.86b31ea7.js"><link rel="prefetch" href="/assets/js/131.be4dca8f.js"><link rel="prefetch" href="/assets/js/132.a4e032bd.js"><link rel="prefetch" href="/assets/js/133.545d53fa.js"><link rel="prefetch" href="/assets/js/134.ef4512f0.js"><link rel="prefetch" href="/assets/js/135.b15ec030.js"><link rel="prefetch" href="/assets/js/136.14e63782.js"><link rel="prefetch" href="/assets/js/137.671e87f8.js"><link rel="prefetch" href="/assets/js/138.b3d28a52.js"><link rel="prefetch" href="/assets/js/139.bc5e381c.js"><link rel="prefetch" href="/assets/js/14.63057fe7.js"><link rel="prefetch" href="/assets/js/140.ce3a69fc.js"><link rel="prefetch" href="/assets/js/141.09737b5b.js"><link rel="prefetch" href="/assets/js/142.49e3bb24.js"><link rel="prefetch" href="/assets/js/143.45031fa6.js"><link rel="prefetch" href="/assets/js/144.458e287e.js"><link rel="prefetch" href="/assets/js/145.9d21ff24.js"><link rel="prefetch" href="/assets/js/146.88d47473.js"><link rel="prefetch" href="/assets/js/147.277b5759.js"><link rel="prefetch" href="/assets/js/148.0dd5c138.js"><link rel="prefetch" href="/assets/js/149.d638ab21.js"><link rel="prefetch" href="/assets/js/15.3ac2cfb4.js"><link rel="prefetch" href="/assets/js/150.834eb5ca.js"><link rel="prefetch" href="/assets/js/151.0b833f48.js"><link rel="prefetch" href="/assets/js/152.d212207c.js"><link rel="prefetch" href="/assets/js/153.e8b1311a.js"><link rel="prefetch" href="/assets/js/154.74eb8531.js"><link rel="prefetch" href="/assets/js/16.f2129a31.js"><link rel="prefetch" href="/assets/js/17.27a38c73.js"><link rel="prefetch" href="/assets/js/18.ec5b4213.js"><link rel="prefetch" href="/assets/js/19.553ed8c2.js"><link rel="prefetch" href="/assets/js/20.c1bf3bbb.js"><link rel="prefetch" href="/assets/js/21.5790bc21.js"><link rel="prefetch" href="/assets/js/23.bae1a497.js"><link rel="prefetch" href="/assets/js/24.1edc62bc.js"><link rel="prefetch" href="/assets/js/25.69b254ca.js"><link rel="prefetch" href="/assets/js/26.df57f236.js"><link rel="prefetch" href="/assets/js/27.9ae48125.js"><link rel="prefetch" href="/assets/js/28.d42d4bb6.js"><link rel="prefetch" href="/assets/js/29.f3630e2f.js"><link rel="prefetch" href="/assets/js/3.5c47a171.js"><link rel="prefetch" href="/assets/js/30.40cf5507.js"><link rel="prefetch" href="/assets/js/31.99b2787c.js"><link rel="prefetch" href="/assets/js/32.eef578d9.js"><link rel="prefetch" href="/assets/js/33.6755a6d2.js"><link rel="prefetch" href="/assets/js/34.add65d5c.js"><link rel="prefetch" href="/assets/js/35.3e4a0da9.js"><link rel="prefetch" href="/assets/js/36.9d4bd3f9.js"><link rel="prefetch" href="/assets/js/37.98506fd6.js"><link rel="prefetch" href="/assets/js/38.44bce283.js"><link rel="prefetch" href="/assets/js/39.62bf281f.js"><link rel="prefetch" href="/assets/js/4.8f6f0475.js"><link rel="prefetch" href="/assets/js/40.3a389edd.js"><link rel="prefetch" href="/assets/js/41.a309beb7.js"><link rel="prefetch" href="/assets/js/42.4e87216c.js"><link rel="prefetch" href="/assets/js/43.c6f6922b.js"><link rel="prefetch" href="/assets/js/44.fda8b3de.js"><link rel="prefetch" href="/assets/js/45.5a1c5b3b.js"><link rel="prefetch" href="/assets/js/46.289cbb81.js"><link rel="prefetch" href="/assets/js/47.81850ce8.js"><link rel="prefetch" href="/assets/js/48.e986629d.js"><link rel="prefetch" href="/assets/js/49.d04a41c3.js"><link rel="prefetch" href="/assets/js/5.8b87f02a.js"><link rel="prefetch" href="/assets/js/50.727fb121.js"><link rel="prefetch" href="/assets/js/51.a10ac8b0.js"><link rel="prefetch" href="/assets/js/52.4fffa0ef.js"><link rel="prefetch" href="/assets/js/53.03ab34e0.js"><link rel="prefetch" href="/assets/js/54.f05ee208.js"><link rel="prefetch" href="/assets/js/55.f90df177.js"><link rel="prefetch" href="/assets/js/56.86a4d03e.js"><link rel="prefetch" href="/assets/js/57.c8cee71c.js"><link rel="prefetch" href="/assets/js/58.0b503f53.js"><link rel="prefetch" href="/assets/js/59.c4daebc4.js"><link rel="prefetch" href="/assets/js/6.2f86309f.js"><link rel="prefetch" href="/assets/js/60.b9584ba1.js"><link rel="prefetch" href="/assets/js/61.fa6e5de3.js"><link rel="prefetch" href="/assets/js/62.4f67908f.js"><link rel="prefetch" href="/assets/js/63.0c9d8ccc.js"><link rel="prefetch" href="/assets/js/64.2754e515.js"><link rel="prefetch" href="/assets/js/65.f2bd6dd5.js"><link rel="prefetch" href="/assets/js/66.299c952c.js"><link rel="prefetch" href="/assets/js/67.2ccaf3ef.js"><link rel="prefetch" href="/assets/js/68.b6e197f0.js"><link rel="prefetch" href="/assets/js/69.b821ea5d.js"><link rel="prefetch" href="/assets/js/7.f1cc41de.js"><link rel="prefetch" href="/assets/js/70.7beae76c.js"><link rel="prefetch" href="/assets/js/71.d452a791.js"><link rel="prefetch" href="/assets/js/72.f3fd5168.js"><link rel="prefetch" href="/assets/js/73.0804c5f0.js"><link rel="prefetch" href="/assets/js/74.cdcdfbcc.js"><link rel="prefetch" href="/assets/js/75.e8e01c97.js"><link rel="prefetch" href="/assets/js/76.6801837d.js"><link rel="prefetch" href="/assets/js/77.04408d97.js"><link rel="prefetch" href="/assets/js/78.9130c8b3.js"><link rel="prefetch" href="/assets/js/79.dcf60589.js"><link rel="prefetch" href="/assets/js/8.89fa1943.js"><link rel="prefetch" href="/assets/js/80.efe0c1a1.js"><link rel="prefetch" href="/assets/js/81.8220fef3.js"><link rel="prefetch" href="/assets/js/82.ae2099d2.js"><link rel="prefetch" href="/assets/js/83.c563f161.js"><link rel="prefetch" href="/assets/js/84.e365194b.js"><link rel="prefetch" href="/assets/js/85.15de0cdb.js"><link rel="prefetch" href="/assets/js/86.b99959c5.js"><link rel="prefetch" href="/assets/js/87.6fccf3fc.js"><link rel="prefetch" href="/assets/js/88.9bc0613a.js"><link rel="prefetch" href="/assets/js/89.89530022.js"><link rel="prefetch" href="/assets/js/9.7637f327.js"><link rel="prefetch" href="/assets/js/90.53d12303.js"><link rel="prefetch" href="/assets/js/91.c55896d7.js"><link rel="prefetch" href="/assets/js/92.0fe1f724.js"><link rel="prefetch" href="/assets/js/93.d681c01d.js"><link rel="prefetch" href="/assets/js/94.ed89d267.js"><link rel="prefetch" href="/assets/js/95.96e675de.js"><link rel="prefetch" href="/assets/js/96.5ad7361e.js"><link rel="prefetch" href="/assets/js/97.e7f32727.js"><link rel="prefetch" href="/assets/js/98.c3a03e67.js"><link rel="prefetch" href="/assets/js/99.31f54446.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a427ee9b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">duangdong的note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/principle/" class="nav-link">
  JS执行
</a></div><div class="nav-item"><a href="/design-mode/" class="nav-link">
  JS设计模式
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  JS进阶
</a></div><div class="nav-item"><a href="/advanced-function/" class="nav-link">
  高阶函数
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/eight-essay/" class="nav-link">
  八股文
</a></div><div class="nav-item"><a href="/hand-writing/" class="nav-link">
  手写实现
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/tools/" class="nav-link">
  工具方法
</a></div><div class="nav-item"><a href="https://link.qdzhou.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/principle/" class="nav-link">
  JS执行
</a></div><div class="nav-item"><a href="/design-mode/" class="nav-link">
  JS设计模式
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link router-link-active">
  JS进阶
</a></div><div class="nav-item"><a href="/advanced-function/" class="nav-link">
  高阶函数
</a></div><div class="nav-item"><a href="/typescript/" class="nav-link">
  TS
</a></div><div class="nav-item"><a href="/eight-essay/" class="nav-link">
  八股文
</a></div><div class="nav-item"><a href="/hand-writing/" class="nav-link">
  手写实现
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/tools/" class="nav-link">
  工具方法
</a></div><div class="nav-item"><a href="https://link.qdzhou.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/advanced/" aria-current="page" class="sidebar-link">js 进阶</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2-动画</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>3-高级api</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/advanced/3-高级api/JSB 原理与实践.html" class="sidebar-link">JSB 原理与实践</a></li><li><a href="/advanced/3-高级api/axios是如何封装HTTP请求的.html" class="sidebar-link">axios 是如何封装 HTTP 请求的</a></li><li><a href="/advanced/3-高级api/mutation-observer.html" class="sidebar-link">DOM 变动观察器（Mutation observer）</a></li><li><a href="/advanced/3-高级api/《You-Dont-Know-JS》笔记小计.html" class="sidebar-link">《You-Dont-Know-JS》笔记小计</a></li><li><a href="/advanced/3-高级api/前端鉴权.html" class="active sidebar-link">前端鉴权必须了解的5个兄弟：cookie、session、token、jwt、单点登录</a></li><li><a href="/advanced/3-高级api/发布订阅模式.html" class="sidebar-link">JavaScript的发布订阅模式</a></li><li><a href="/advanced/3-高级api/图解JavaScript继承.html" class="sidebar-link">图解 JavaScript 继承，一文搞定继承相关知识</a></li><li><a href="/advanced/3-高级api/基于js管理大文件上传以及断点续传.html" class="sidebar-link">基于js管理大文件上传以及断点续传</a></li><li><a href="/advanced/3-高级api/手写简易版的axios.html" class="sidebar-link">面试官不要再问我axios了？我能手写简易版的axios</a></li><li><a href="/advanced/3-高级api/页面生命周期.html" class="sidebar-link">页面生命周期：DOMContentLoaded，load，beforeunload，unload</a></li></ul></section></li><li><a href="/advanced/CORS完全手册之CORS详解.html" class="sidebar-link">CORS 完全手册之 CORS 详解</a></li><li><a href="/advanced/ES12新特性.html" class="sidebar-link">JavaScriptES12新特性抢先体验</a></li><li><a href="/advanced/前端模块化.html" class="sidebar-link">彻底掌握前端模块化</a></li><li><a href="/advanced/变量和类型-1.html" class="sidebar-link">变量和类型</a></li><li><a href="/advanced/变量和类型-2.html" class="sidebar-link">变量和类型-2</a></li><li><a href="/advanced/深入分析 JavaScript 模块循环引用.html" class="sidebar-link">深入分析 JavaScript 模块循环引用</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前端鉴权必须了解的5个兄弟-cookie、session、token、jwt、单点登录"><a href="#前端鉴权必须了解的5个兄弟-cookie、session、token、jwt、单点登录" class="header-anchor">#</a> 前端鉴权必须了解的5个兄弟：cookie、session、token、jwt、单点登录</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/GlSpsx3KY6oPLzS3HzGXPw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/GlSpsx3KY6oPLzS3HzGXPw<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>本文你将看到：</p> <ul><li>基于 HTTP 的前端鉴权背景</li> <li>cookie 为什么是最方便的存储方案，有哪些操作 cookie 的方式</li> <li>session 方案是如何实现的，存在哪些问题</li> <li>token 方案是如何实现的，如何进行编码和防篡改？jwt 是做什么的？refresh token 的实现和意义</li> <li>session 和 token 有什么异同和优缺点</li> <li>单点登录是什么？实现思路和在浏览器下的处理</li></ul> <hr> <h1 id="从状态说起"><a href="#从状态说起" class="header-anchor">#</a> 从状态说起</h1> <p><strong>「HTTP 无状态」</strong></p> <p>我们知道，HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。</p> <p>但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</p> <p><strong>「标记」</strong></p> <p>那解决办法是什么呢？::标记::。</p> <blockquote><p>在学校或公司，入学入职那一天起，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要刷这张卡。</p></blockquote> <p><strong>「前端存储」</strong></p> <p>这就涉及到一发、一存、一带，发好办，登陆接口直接返回给前端，存储就需要前端想办法了。</p> <blockquote><p>前提是，你要把卡带在身上。</p></blockquote> <p>前端的存储方式有很多。</p> <ul><li>最矬的，挂到全局变量上，但这是个「体验卡」，一次刷新页面就没了</li> <li>高端点的，存到 cookie、localStorage 等里，这属于「会员卡」，无论怎么刷新，只要浏览器没清掉或者过期，就一直拿着这个状态。</li></ul> <p>前端存储这里不展开了。</p> <p>有地方存了，请求的时候就可以拼到参数里带给接口了。</p> <hr> <h1 id="基石-cookie"><a href="#基石-cookie" class="header-anchor">#</a> 基石：cookie</h1> <blockquote><p>可是前端好麻烦啊，又要自己存，又要想办法带出去，有没有不用操心的？</p></blockquote> <p>有，cookie。</p> <p>cookie 也是前端存储的一种，但相比于 localStorage 等其他方式，借助 HTTP 头、浏览器能力，cookie 可以做到前端无感知。</p> <p>一般过程是这样的：</p> <ul><li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li> <li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li></ul> <p><strong>「配置：Domain / Path」</strong></p> <blockquote><p>你不能拿清华的校园卡进北大。</p></blockquote> <p>cookie 是要限制::「空间范围」::的，通过 Domain（域）/ Path（路径）两级。</p> <blockquote><p>Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 www.example.com 会设为 example.com，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。</p> <p>Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p> <p>—— Cookie — JavaScript 标准参考教程（alpha）</p></blockquote> <p><strong>「配置：Expires / Max-Age」</strong></p> <blockquote><p>你毕业了卡就不好使了。</p></blockquote> <p>cookie 还可以限制::「时间范围」::，通过 Expires、Max-Age 中的一种。</p> <blockquote><p>Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p> <p>Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p> <p>如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。</p> <p>如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p> <p>—— Cookie — JavaScript 标准参考教程（alpha）</p></blockquote> <p><strong>「配置：Secure / HttpOnly」</strong></p> <blockquote><p>有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。</p></blockquote> <p>cookie 可以限制::「使用方式」::。</p> <blockquote><p>Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p> <p>HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p> <p>—— Cookie — JavaScript 标准参考教程（alpha）</p></blockquote> <p><strong>「HTTP 头对 cookie 的读写」</strong></p> <p>回过头来，HTTP 是如何写入和传递 cookie 及其配置的呢？</p> <p>HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：</p> <div class="language- extra-class"><pre class="language-text"><code>Set-Cookie: username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 
</code></pre></div><p>那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）</p> <div class="language- extra-class"><pre class="language-text"><code>Set-Cookie: username=jimu; domain=jimu.com
Set-Cookie: height=180; domain=me.jimu.com
Set-Cookie: weight=80; domain=me.jimu.com 
</code></pre></div><p>HTTP 请求的 Cookie 头用于浏览器把符合当前「空间、时间、使用方式」配置的所有 cookie 一并发给服务端。因为由浏览器做了筛选判断，就不需要归还配置内容了，只要发送键值就可以。</p> <div class="language- extra-class"><pre class="language-text"><code>Cookie: username=jimu; height=180; weight=80 
</code></pre></div><p><strong>「前端对 cookie 的读写」</strong></p> <p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p> <p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p> <div class="language- extra-class"><pre class="language-text"><code>document.cookie = 'username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly'; 
</code></pre></div><p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code> cookie。</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(document.cookie);
// username=jimu; height=180; weight=80 
</code></pre></div><p>（就一个 cookie 属性，为什么读写行为不一样？get / set 了解下）</p> <p><strong>「cookie 是维持 HTTP 请求状态的基石」</strong></p> <p>了解了 cookie 后，我们知道 cookie 是最便捷的维持 HTTP 请求状态的方式，大多数前端鉴权问题都是靠 cookie 解决的。当然也可以选用别的存储方式（后面也会多多少少提到）。</p> <p>那有了存储工具，接下来怎么做呢？</p> <hr> <h1 id="应用方案-服务端-session"><a href="#应用方案-服务端-session" class="header-anchor">#</a> 应用方案：服务端 session</h1> <p>现在回想下，你刷卡的时候发生了什么？</p> <blockquote><p>其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。</p></blockquote> <p>这种操作，在前后端鉴权系统中，叫 session。</p> <p>典型的 session 登陆/验证流程：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhSL9SSvlVyK9rZpYbMEce09OVXcUR7ME0lRty0c2g2gzAdiasgqZMicvw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <ul><li>浏览器登录发送账号密码，服务端查用户库，校验用户</li> <li>服务端把用户登录状态存为 Session，生成一个 sessionId</li> <li>通过登录接口返回，把 sessionId set 到 cookie 上</li> <li>此后浏览器再请求业务接口，sessionId 随 cookie 带上</li> <li>服务端查 sessionId 校验 session</li> <li>成功后正常做业务处理，返回结果</li></ul> <p><strong>「Session 的存储方式」</strong></p> <p>显然，服务端只是给 cookie 一个 sessionId，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：</p> <ul><li>Redis（推荐）：内存型数据库，redis中文官方网站。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。</li> <li>内存：直接放到变量里。一旦服务重启就没了</li> <li>数据库：普通数据库。性能不高。</li></ul> <p><strong>「Session 的过期和销毁」</strong></p> <p>很简单，只要把存储的 session 数据销毁就可以。</p> <p><strong>「Session 的分布式问题」</strong></p> <p>通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？</p> <p>这个问题现在有几种解决方式。</p> <ul><li>一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。</li> <li>二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。</li></ul> <p>但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。</p> <p><strong>「node.js 下的 session 处理」</strong></p> <p>前面的图很清楚了，服务端要实现对 cookie 和 session 的存取，实现起来要做的事还是很多的。在<code>npm</code>中，已经有封装好的中间件，比如 express-session - npm，用法就不贴了。</p> <p>这是它种的 cookie：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhRjOeeRW5D9pOZ9eFQAriaYPBLOOFvVeLWLR25dbsFBPNuHjMIbe9vaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>express-session - npm 主要实现了：</p> <ul><li>封装了对cookie的读写操作，并提供配置项配置字段、加密方式、过期时间等。</li> <li>封装了对session的存取操作，并提供配置项配置session存储方式（内存/redis）、存储规则等。</li> <li>给req提供了session属性，控制属性的set/get并响应到cookie和session存取上，并给req.session提供了一些方法。</li></ul> <hr> <h1 id="应用方案-token"><a href="#应用方案-token" class="header-anchor">#</a> 应用方案：token</h1> <p>session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？</p> <blockquote><p>我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。</p></blockquote> <p>回过头来想想，一个登录场景，也不必往 session 存太多东西，那为什么不直接打包到 cookie 中呢？这样服务端不用存了，每次只要核验 cookie 带的「证件」有效性就可以了，也可以携带一些轻量的信息。</p> <p>这种方式通常被叫做 token。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh1pp5jQibGiafq4a1Fbzf8of4KJONMrkl05WgoWQUc5nicY6ENibJoqCoIw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>token 的流程是这样的：</p> <ul><li>用户登录，服务端校验账号密码，获得用户信息</li> <li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li> <li>此后用户请求业务接口，通过 cookie 携带 token</li> <li>接口校验 token 有效性，进行正常业务接口处理</li></ul> <p><strong>「客户端 token 的存储方式」</strong></p> <p>在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，对 cookie 的管理能力依赖较小，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心。</p> <p><strong>「token 的过期」</strong></p> <p>那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好。</p> <h2 id="token-的编码"><a href="#token-的编码" class="header-anchor">#</a> token 的编码</h2> <p>编码的方式丰俭由人。</p> <p><strong>「base64」</strong></p> <p>比如 node 端的 cookie-session - npm 库</p> <blockquote><p>不要纠结名字，其实是个 token 库，但保持了和 express-session - npm 高度一致的用法，把要存的数据挂在 session 上</p></blockquote> <p>默认配置下，当我给他一个 userid，他会存成这样：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh847kRibkcoibrtVwU5OcaVT3YibNicicSVkwXF5xehjHiac9lV9n633G51QQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>这里的 <code>eyJ1c2VyaWQiOiJhIn0=</code>，就是 <code>{&quot;userid&quot;:&quot;abb”}</code> 的 base64 而已。</p> <p><strong>「防篡改」</strong></p> <blockquote><p>那问题来了，如果用户 cdd 拿<code>{&quot;userid&quot;:&quot;abb”}</code>转了个 base64，再手动修改了自己的 token 为 <code>eyJ1c2VyaWQiOiJhIn0=</code>，是不是就能直接访问到 abb 的数据了？</p></blockquote> <p>是的。所以看情况，如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。</p> <p>解决方案就是给 token 加签名，来识别 token 是否被篡改过。例如在 cookie-session - npm 库中，增加两项配置：</p> <div class="language- extra-class"><pre class="language-text"><code>secret: 'iAmSecret',
signed: true, 
</code></pre></div><p>这样会多种一个 .sig cookie，里面的值就是 <code>{&quot;userid&quot;:&quot;abb”}</code> 和 <code>iAmSecret</code>通过加密算法计算出来的，常见的比如HMACSHA256 类 (System.Security.Cryptography) | Microsoft Docs。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhGQnmqNyYKagPYWBVJnet30xhia2ibslMtsEEyE6YUqeHC0NdxztaBfsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>好了，现在 cdd 虽然能伪造出<code>eyJ1c2VyaWQiOiJhIn0=</code>，但伪造不出 sig 的内容，因为他不知道 secret。</p> <p><strong>「JWT」</strong></p> <p>但上面的做法额外增加了 cookie 数量，数据本身也没有规范的格式，所以 JSON Web Token Introduction - jwt.io 横空出世了。</p> <blockquote><p>JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。</p></blockquote> <p>它是一种成熟的 token 字符串生成方案，包含了我们前面提到的数据、签名。不如直接看一下一个 JWT token 长什么样：</p> <div class="language- extra-class"><pre class="language-text"><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo 
</code></pre></div><p>这串东西是怎么生成的呢？看图：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>类型、加密算法的选项，以及 JWT 标准数据字段，可以参考 RFC 7519 - JSON Web Token (JWT)</p> <p>node 上同样有相关的库实现：express-jwt - npm koa-jwt - npm</p> <h2 id="refresh-token"><a href="#refresh-token" class="header-anchor">#</a> refresh token</h2> <p>token，作为权限守护者，最重要的就是「安全」。</p> <p>业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？</p> <p>一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。</p> <p>另外一种办法是，再来一个 token，一个专门生成 access token 的 token，我们称为 refresh token。</p> <ul><li>access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活</li> <li>refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理</li></ul> <p>有了 refresh token 后，几种情况的请求流程变成这样：</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhqMOSEzXmktNe3rW4aBpG2k1Ao6pmBkT6S2vEBhWkTZJsHmqHialv2gw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>如果 refresh token 也过期了，就只能重新登录了。</p> <h2 id="session-和-token"><a href="#session-和-token" class="header-anchor">#</a> session 和 token</h2> <p>session 和 token 都是边界很模糊的概念，就像前面说的，refresh token 也可能以 session 的形式组织维护。</p> <p>狭义上，我们通常认为 session 是「种在 cookie 上、数据存在服务端」的认证方案，token 是「客户端存哪都行、数据存在 token 里」的认证方案。对 session 和 token 的对比本质上是「客户端存 cookie / 存别地儿」、「服务端存数据 / 不存数据」的对比。</p> <p><strong>「客户端存 cookie / 存别地儿」</strong></p> <p>存 cookie 固然方便不操心，但问题也很明显：</p> <ul><li>在浏览器端，可以用 cookie（实际上 token 就常用 cookie），但出了浏览器端，没有 cookie 怎么办？</li> <li>cookie 是浏览器在域下自动携带的，这就容易引发 CSRF 攻击（前端安全系列（二）：如何防止CSRF攻击？- 美团技术团队）</li></ul> <p>存别的地方，可以解决没有 cookie 的场景；通过参数等方式手动带，可以避免 CSRF 攻击。</p> <p><strong>「服务端存数据 / 不存数据」</strong></p> <ul><li>存数据：请求只需携带 id，可以大幅缩短认证字符串长度，减小请求体积</li> <li>不存数据：不需要服务端整套的解决方案和分布式处理，降低硬件成本；避免查库带来的验证延迟</li></ul> <hr> <h1 id="单点登录"><a href="#单点登录" class="header-anchor">#</a> 单点登录</h1> <p>前面我们已经知道了，在同域下的客户端/服务端认证系统中，通过客户端携带凭证，维持一段时间内的登录状态。</p> <p>但当我们业务线越来越多，就会有更多业务系统分散到不同域名下，就需要「一次登录，全线通用」的能力，叫做「单点登录」。</p> <h2 id="虚假-的单点登录-主域名相同"><a href="#虚假-的单点登录-主域名相同" class="header-anchor">#</a> “虚假”的单点登录（主域名相同）</h2> <p>简单的，如果业务系统都在同一主域名下，比如<code>wenku.baidu.com``tieba.baidu.com</code>，就好办了。可以直接把 cookie domain 设置为主域名 <code>baidu.com</code>，百度也就是这么干的。</p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhpW7unnFC7LfJnWefCTqckpzrib7gbe1BJbiboUoJJ89TfibK2fQpKA0NQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h2 id="真实-的单点登录-主域名不同"><a href="#真实-的单点登录-主域名不同" class="header-anchor">#</a> “真实”的单点登录（主域名不同）</h2> <p>比如滴滴这么潮的公司，同时拥有<code>didichuxing.com</code> <code>xiaojukeji.com``didiglobal.com</code>等域名，种 cookie 是完全绕不开的。</p> <p>这要能实现「一次登录，全线通用」，才是真正的单点登录。</p> <p>这种场景下，我们需要独立的认证服务，通常被称为 SSO。</p> <p><strong>「一次「从 A 系统引发登录，到 B 系统不用登录」的完整流程」</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhibSxiaEbDxZ7Q8g2KT6MyrQQr2xjTZjUjrfWNe3xqJFyWs2lZQ9QXCCg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <ul><li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO</li> <li>SSO 没登录过，也就没有 sso 系统下没有凭证（注意这个和前面 A ticket 是两回事），输入账号密码登录</li> <li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket</li> <li>客户端拿到 ticket，保存起来，带着请求系统 A 接口</li> <li>系统 A 校验 ticket，成功后正常处理业务请求</li> <li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO</li> <li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket</li> <li>客户端拿到 ticket，保存起来，带着请求系统 B 接口</li></ul> <p><strong>「完整版本：考虑浏览器的场景」</strong></p> <p>上面的过程看起来没问题，实际上很多 APP 等端上这样就够了。但在浏览器下不见得好用。</p> <p>看这里：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>对浏览器来说，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。</p> <p>这就需要也只能由 A 提供 A 域下存储凭证的能力。一般我们是这么做的：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>图中我们通过颜色把浏览器当前所处的域名标记出来。注意图中灰底文字说明部分的变化。</p> <ul><li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定</li> <li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket</li> <li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效</li> <li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功</li> <li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好</li> <li>访问 B 系统也是一样</li></ul> <hr> <h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <ul><li>HTTP 是无状态的，为了维持前后请求，需要前端存储标记</li> <li>cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石</li> <li>session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题</li> <li>token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性</li> <li>token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案</li> <li>在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验</li> <li>session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比</li> <li>单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/27/2022, 9:04:59 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/advanced/3-高级api/《You-Dont-Know-JS》笔记小计.html" class="prev">
        《You-Dont-Know-JS》笔记小计
      </a></span> <span class="next"><a href="/advanced/3-高级api/发布订阅模式.html">
        JavaScript的发布订阅模式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.6df8e219.js" defer></script><script src="/assets/js/2.e21ead49.js" defer></script><script src="/assets/js/22.29894e1b.js" defer></script>
  </body>
</html>
