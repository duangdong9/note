(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{431:function(e,n,t){"use strict";t.r(n);var s=t(18),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"axios-是如何封装-http-请求的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-是如何封装-http-请求的"}},[e._v("#")]),e._v(" axios 是如何封装 HTTP 请求的")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/Wbcjp3Lh44nrInFc3IX85w",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/Wbcjp3Lh44nrInFc3IX85w"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("Axios 毋庸多说大家在前端开发中常用的一个发送 HTTP 请求的库，用过的都知道。本文用来整理项目中常用的 Axios 的封装使用。同时学习源码，手写实现 Axios 的核心代码。")]),e._v(" "),t("h3",{attrs:{id:"axios-常用封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-常用封装"}},[e._v("#")]),e._v(" Axios 常用封装")]),e._v(" "),t("h4",{attrs:{id:"是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[e._v("#")]),e._v(" 是什么")]),e._v(" "),t("p",[e._v("Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。它的特性：")]),e._v(" "),t("ul",[t("li",[e._v("从浏览器中创建 "),t("code",[e._v("XMLHttpRequests")])]),e._v(" "),t("li",[e._v("从 node.js 创建 "),t("code",[e._v("http")]),e._v(" 请求")]),e._v(" "),t("li",[e._v("支持 "),t("code",[e._v("Promise")]),e._v(" API")]),e._v(" "),t("li",[e._v("拦截请求和响应")]),e._v(" "),t("li",[e._v("转换请求数据和响应数据")]),e._v(" "),t("li",[e._v("取消请求")]),e._v(" "),t("li",[e._v("自动转换 JSON 数据")]),e._v(" "),t("li",[e._v("客户端支持防御 XSRF官网地址：http://www.axios-js.com/zh-cn/docs/#axios-config")])]),e._v(" "),t("p",[e._v("Axios 使用方式有两种：一种是直接使用全局的 Axios 对象；另外一种是通过 "),t("code",[e._v("axios.create(config)")]),e._v(" 方法创建一个实例对象，使用该对象。两种方式的区别是通过第二种方式创建的实例对象更清爽一些；全局的 Axios 对象其实也是创建的实例对象导出的，它本身上加载了很多默认属性。后面源码学习的时候会再详细说明。")]),e._v(" "),t("h4",{attrs:{id:"请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求"}},[e._v("#")]),e._v(" 请求")]),e._v(" "),t("p",[e._v("Axios 这个 HTTP 的库比较灵活，给用户多种发送请求的方式，以至于有些混乱。细心整理会发现，全局的 Axios（或者 "),t("code",[e._v("axios.create(config)")]),e._v("创建的对象） 既可以当作对象使用，也可以当作函数使用：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// axios 当作对象使用\naxios.request(config)\naxios.get(url[, config])\naxios.post(url[, data[, config]])\n// axios() 当作函数使用。 发送 POST 请求\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n});\n")])])]),t("p",[e._v("后面源码学习的时候会再详细说明为什么 Axios 可以实现两种方式的使用。")]),e._v(" "),t("h4",{attrs:{id:"取消请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#取消请求"}},[e._v("#")]),e._v(" 取消请求")]),e._v(" "),t("p",[e._v("可以使用 "),t("code",[e._v("CancelToken.source")]),e._v(" 工厂方法创建 cancel token：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\n\naxios.get('/user/12345', {\n  cancelToken: source.token\n}).catch(function(thrown) {\n  if (axios.isCancel(thrown)) {\n    console.log('Request canceled', thrown.message);\n  } else {\n     // 处理错误\n  }\n});\n\n// 取消请求（message 参数是可选的）\nsource.cancel('Operation canceled by the user.');\n")])])]),t("p",[e._v("source 有两个属性：一个是 "),t("code",[e._v("source.token")]),e._v(" 标识请求；另一个是 "),t("code",[e._v("source.cancel()")]),e._v(" 方法，该方法调用后，可以让 CancelToken 实例的 promise 状态变为 "),t("code",[e._v("resolved")]),e._v("，从而触发 xhr 对象的 abort() 方法，取消请求。")]),e._v(" "),t("h4",{attrs:{id:"拦截"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拦截"}},[e._v("#")]),e._v(" 拦截")]),e._v(" "),t("p",[e._v("Axios 还有一个奇妙的功能点，可以在发送请求前对请求进行拦截，对相应结果进行拦截。结合业务场景的话，在中台系统中完成登录后，获取到后端返回的 token，可以将 token 添加到 header 中，以后所有的请求自然都会加上这个自定义 header。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//拦截1 请求拦截\ninstance.interceptors.request.use(function(config){\n    //在发送请求之前做些什么\n    const token = sessionStorage.getItem('token');\n    if(token){\n        const newConfig = {\n            ...config,\n            headers: {\n                token: token\n            }\n        }\n        return newConfig;\n    }else{\n        return config;\n    }\n}, function(error){\n    //对请求错误做些什么\n    return Promise.reject(error);\n});\n")])])]),t("p",[e._v("我们还可以利用请求拦截功能实现 "),t("strong",[e._v("取消重复请求")]),e._v("，也就是在前一个请求还没有返回之前，用户重新发送了请求，需要先取消前一次请求，再发送新的请求。比如搜索框自动查询，当用户修改了内容重新发送请求的时候需要取消前一次请求，避免请求和响应混乱。再比如表单提交按钮，用户多次点击提交按钮，那么我们就需要取消掉之前的请求，保证只有一次请求的发送和响应。")]),e._v(" "),t("p",[e._v("实现原理是使用一个对象记录已经发出去的请求，在请求拦截函数中先判断这个对象中是否记录了本次请求信息，如果已经存在，则取消之前的请求，将本次请求添加进去对象中；如果没有记录过本次请求，则将本次请求信息添加进对象中。最后请求完成后，在响应拦截函数中执行删除本次请求信息的逻辑。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 拦截2   重复请求，取消前一个请求\nconst promiseArr = {};\ninstance.interceptors.request.use(function(config){\n    console.log(Object.keys(promiseArr).length)\n    //在发送请求之前做些什么\n    let source=null;\n    if(config.cancelToken){\n        // config 配置中带了 source 信息\n        source = config.source;\n    }else{\n        const CancelToken = axios.CancelToken;\n        source = CancelToken.source();\n        config.cancelToken = source.token;\n    }\n    const currentKey = getRequestSymbol(config);\n    if(promiseArr[currentKey]){\n        const tmp = promiseArr[currentKey];\n        tmp.cancel("取消前一个请求");\n        delete promiseArr[currentKey];\n        promiseArr[currentKey] = source;\n    }else{\n        promiseArr[currentKey] = source;\n    }\n    return config;\n\n}, function(error){\n    //对请求错误做些什么\n    return Promise.reject(error);\n});\n// 根据 url、method、params 生成唯一标识，大家可以自定义自己的生成规则\nfunction getRequestSymbol(config){\n    const arr = [];\n    if(config.params){\n        const data = config.params;\n        for(let key of Object.keys(data)){\n            arr.push(key+"&"+data[key]);\n        }\n        arr.sort();\n    }\n    return config.url+config.method+arr.join("");\n}\n\ninstance.interceptors.response.use(function(response){\n    const currentKey = getRequestSymbol(response.config);\n    delete promiseArr[currentKey];\n    return response;\n}, function(error){\n    //对请求错误做些什么\n    return Promise.reject(error);\n});\n')])])]),t("p",[e._v("最后，我们可以在响应拦截函数中统一处理返回码的逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 响应拦截\ninstance.interceptors.response.use(function(response){\n    // 401 没有登录跳转到登录页面\n    if(response.data.code===401){\n        window.location.href = "http://127.0.0.1:8080/#/login";\n    }else if(response.data.code===403){\n        // 403 无权限跳转到无权限页面\n        window.location.href = "http://127.0.0.1:8080/#/noAuth";\n    }\n    return response;\n}, function(error){\n    //对请求错误做些什么\n    return Promise.reject(error);\n})\n')])])]),t("h4",{attrs:{id:"文件下载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件下载"}},[e._v("#")]),e._v(" 文件下载")]),e._v(" "),t("p",[e._v("通常文件下载有两种方式：一种是通过文件在服务器上的对外地址直接下载；还有一种是通过接口将文件以二进制流的形式下载。")]),e._v(" "),t("p",[e._v("第一种："),t("strong",[e._v("同域名")]),e._v(" 下使用 "),t("code",[e._v("a")]),e._v(" 标签下载：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// httpServer.js\nconst express = require("express");\nconst path = require(\'path\');\nconst app = express();\n\n//静态文件地址\napp.use(express.static(path.join(__dirname, \'public\')))\napp.use(express.static(path.join(__dirname, \'../\')));\napp.listen(8081, () => {\n  console.log("服务器启动成功！")\n});\n// index.html\n<a href="test.txt" download="test.txt">下载</a>\n')])])]),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("第二种：二进制文件流的形式传递，我们直接访问该接口并不能下载文件，一定程度保证了数据的安全性。比较多的场景是：后端接收到查询参数，查询数据库然后通过插件动态生成 excel 文件，以文件流的方式让前端下载。")]),e._v(" "),t("p",[e._v("这时候，我们可以将请求文件下载的逻辑进行封装。将二进制文件流存在 "),t("code",[e._v("Blob")]),e._v(" 对象中，再将其转为 url 对象，最后通过 a 标签下载。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//封装下载\nexport function downLoadFetch(url, params = {}, config={}) {\n    //取消\n    const downSource = axios.CancelToken.source();\n    document.getElementById('downAnimate').style.display = 'block';\n    document.getElementById('cancelBtn').addEventListener('click', function(){\n        downSource.cancel(\"用户取消下载\");\n        document.getElementById('downAnimate').style.display = 'none';\n    }, false);\n    //参数\n    config.params = params;\n    //超时时间\n    config.timeout = config.timeout ? config.timeout : defaultDownConfig.timeout;\n    //类型\n    config.responseType = defaultDownConfig.responseType;\n    //取消下载\n    config.cancelToken = downSource.token;\n    return instance.get(url, config).then(response=>{\n        const content = response.data;\n        const url = window.URL.createObjectURL(new Blob([content]));\n        //创建 a 标签\n        const link = document.createElement('a');\n        link.style.display = 'none';\n        link.href = url;\n        //文件名  Content-Disposition: attachment; filename=download.txt\n        const filename = response.headers['content-disposition'].split(\";\")[1].split(\"=\")[1];\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        return {\n            status: 200,\n            success: true\n        }\n    })\n}\n")])])]),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("https://juejin.cn/post/6878912072780873742")]),e._v(" "),t("h3",{attrs:{id:"手写-axios-核心代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手写-axios-核心代码"}},[e._v("#")]),e._v(" 手写 Axios 核心代码")]),e._v(" "),t("p",[e._v("写了这么多用法终于到正题了，手写 Axios 核心代码。Axios 这个库源码不难阅读，没有特别复杂的逻辑，大家可以放心阅读 😂 。")]),e._v(" "),t("p",[e._v("源码入口是这样查找：在项目 "),t("code",[e._v("node_modules")]),e._v(" 目录下，找到 "),t("code",[e._v("axios")]),e._v(" 模块的 "),t("code",[e._v("package.json")]),e._v(" 文件，其中 "),t("code",[e._v('"main": "index.js",')]),e._v(" 就是文件入口。一步步我们可以看到源码是怎么串起来的。")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("模仿上面的目录结构，我们创建自己的目录结构：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("axios-js\n│  index.html\n│  \n└─lib\n        adapter.js\n        Axios.js\n        axiosInstance.js\n        CancelToken.js\n        InterceptorManager.js\n")])])]),t("h4",{attrs:{id:"axios-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios-是什么"}},[e._v("#")]),e._v(" Axios 是什么")]),e._v(" "),t("p",[e._v("上面有提到我们使用的全局 Axios 对象其实也是构造出来的 axios，既可以当对象使用调用 get、post 等方法，也可以直接当作函数使用。这是因为全局的 Axios 其实是函数对象 "),t("code",[e._v("instance")]),e._v(" 。源码位置在 axios/lib/axios.js 中。具体代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// axios/lib/axios.js\n//创建 axios 实例\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  //instance 对象是 bind 返回的函数\n  var instance = bind(Axios.prototype.request, context);\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n  // Copy context to instance\n  utils.extend(instance, context);\n  return instance;\n}\n\n// 实例一个 axios\nvar axios = createInstance(defaults);\n\n// 向这个实例添加 Axios 属性\naxios.Axios = Axios;\n\n// 向这个实例添加 create 方法\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n// 向这个实例添加 CancelToken 方法\naxios.CancelToken = require('./cancel/CancelToken');\n// 导出实例 axios\nmodule.exports.default = axios;\n")])])]),t("p",[e._v("根据上面的源码，我们可以简写一下自己实现 Axios.js 和 axiosInstance.js：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// Axios.js\n//Axios 主体\nfunction Axios(config){\n}\n\n// 核心方法，发送请求\nAxios.prototype.request = function(config){\n}\n\nAxios.prototype.get = function(url, config={}){\n    return this.request({url: url, method: 'GET', ...config});\n}\n\nAxios.prototype.post = function(url, data, config={}){\n    return this.request({url: url, method: 'POST', data: data, ...config})\n}\nexport default Axios;\n")])])]),t("p",[e._v("在 axiosInstance.js 文件中，实例化一个 Axios 得到 context，再将原型对象上的方法绑定到 instance 对象上，同时将 context 的属性添加到 instance 上。这样 instance 就成为了一个函数对象。既可以当作对象使用，也可以当作函数使用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// axiosInstance.js\n//创建实例\nfunction createInstance(config){\n    const context = new Axios(config);\n    var instance = Axios.prototype.request.bind(context);\n    //将 Axios.prototype 属性扩展到 instance 上\n    for(let k of Object.keys(Axios.prototype)){\n        instance[k] = Axios.prototype[k].bind(context);\n    }\n    //将 context 属性扩展到 instance 上\n    for(let k of Object.keys(context)){\n        instance[k] = context[k]\n    }\n    return instance;\n}\n\nconst axios = createInstance({});\naxios.create = function(config){\n    return createInstance(config);\n}\nexport default axios;\n")])])]),t("p",[e._v("也就是说 axios.js 中导出的 axios 对象并不是 "),t("code",[e._v("new Axios()")]),e._v(" 方法返回的对象 context，而是 "),t("code",[e._v("Axios.prototype.request.bind(context)")]),e._v(" 执行返回的 "),t("code",[e._v("instance")]),e._v("，通过遍历 "),t("code",[e._v("Axios.prototype")]),e._v(" 并改变其 this 指向到 context；遍历 context 对象让 instance 对象具有 context 的所有属性。这样 instance 对象就无敌了，😎 既拥有了 "),t("code",[e._v("Axios.prototype")]),e._v(" 上的所有方法，又具有了 context 的所有属性。")]),e._v(" "),t("h4",{attrs:{id:"请求实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求实现"}},[e._v("#")]),e._v(" 请求实现")]),e._v(" "),t("p",[e._v("我们知道 Axios 在浏览器中会创建 XMLHttpRequest 对象，在 node.js 环境中创建 http 发送请求。"),t("code",[e._v("Axios.prototype.request()")]),e._v(" 是发送请求的核心方法，这个方法其实调用的是 "),t("code",[e._v("dispatchRequest")]),e._v(" 方法，而 "),t("code",[e._v("dispatchRequest")]),e._v(" 方法调用的是 "),t("code",[e._v("config.adapter || defaults.adapter")]),e._v(" 也就是自定义的 adapter 或者默认的 "),t("code",[e._v("defaults.adapter")]),e._v("，默认"),t("code",[e._v("defaults.adapter")]),e._v(" 调用的是 getDefaultAdapter 方法，源码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n")])])]),t("p",[e._v("哈哈哈，getDefaultAdapter 方法最终根据当前的环境返回不同的实现方法，这里用到了 "),t("strong",[e._v("适配器模式")]),e._v("。我们只用实现 xhr 发送请求即可：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//适配器 adapter.js\nfunction getDefaultAdapter(){\n    var adapter;\n    if(typeof XMLHttpRequest !== 'undefined'){\n        //导入 XHR 对象请求\n        adapter = (config)=>{\n            return xhrAdapter(config);\n        }\n    }\n    return adapter;\n}\nfunction xhrAdapter(config){\n    return new Promise((resolve, reject)=>{\n        var xhr = new XMLHttpRequest();\n        xhr.open(config.method, config.url, true);\n        xhr.send();\n        xhr.onreadystatechange = ()=>{\n            if(xhr.readyState===4){\n                if(xhr.status>=200&&xhr.status<300){\n                    resolve({\n                        data: {},\n                        status: xhr.status,\n                        statusText: xhr.statusText,\n                        xhr: xhr\n                    })\n                }else{\n                    reject({\n                        status: xhr.status\n                    })\n                }\n            }\n        };\n    })\n}\nexport default getDefaultAdapter;\n")])])]),t("p",[e._v("这样就理顺了，getDefaultAdapter 方法每次执行会返回一个 Promise 对象，这样 Axios.prototype.request 方法可以得到执行 xhr 发送请求的 Promise 对象。")]),e._v(" "),t("p",[e._v("给我们的 Axios.js 添加发送请求的方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//Axios.js\nimport getDefaultAdapter from './adapter.js';\nAxios.prototype.request = function(config){\n    const adapter = getDefaultAdapter(config);\n    var promise = Promise.resolve(config);\n    var chain = [adapter, undefined];\n    while(chain.length){\n        promise = promise.then(chain.shift(), chain.shift());\n    }\n    return promise;\n}\n")])])]),t("h4",{attrs:{id:"拦截器实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拦截器实现"}},[e._v("#")]),e._v(" 拦截器实现")]),e._v(" "),t("p",[e._v("拦截器的原理在于 "),t("code",[e._v("Axios.prototype.request")]),e._v(" 方法中的 "),t("code",[e._v("chain")]),e._v(" 数组，把请求拦截函数添加到 "),t("code",[e._v("chain")]),e._v(" 数组前面，把响应拦截函数添加到数组后面。这样就可以实现发送前拦截和响应后拦截的效果。"),t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("创建 InterceptorManager.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//InterceptorManager.js \n//拦截器\nfunction InterceptorManager(){\n    this.handlers = [];\n}\nInterceptorManager.prototype.use = function(fulfilled, rejected){\n    this.handlers.push({\n        fulfilled: fulfilled,\n        rejected: rejected\n    });\n    return this.handlers.length -1;\n}\n\nexport default InterceptorManager;\n")])])]),t("p",[e._v("在 Axios.js 文件中，构造函数有 "),t("code",[e._v("interceptors")]),e._v("属性：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//Axios.js\nfunction Axios(config){\n    this.interceptors = {\n        request: new InterceptorManager(),\n        response: new InterceptorManager()\n    }\n}\n")])])]),t("p",[e._v("这样我们在 Axios.prototype.request 方法中对拦截器添加处理：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//Axios.js\nAxios.prototype.request = function(config){\n    const adapter = getDefaultAdapter(config);\n    var promise = Promise.resolve(config);\n    var chain = [adapter, undefined];\n    //请求拦截\n    this.interceptors.request.handlers.forEach(item=>{\n        chain.unshift(item.rejected);\n        chain.unshift(item.fulfilled);\n        \n    });\n    //响应拦截\n    this.interceptors.response.handlers.forEach(item=>{\n        chain.push(item.fulfilled);\n        chain.push(item.rejected)\n    });\n    console.dir(chain);\n    while(chain.length){\n        promise = promise.then(chain.shift(), chain.shift());\n    }\n    return promise;\n}\n")])])]),t("p",[e._v("所以拦截器的执行顺序是："),t("code",[e._v("请求拦截2 -> 请求拦截1 -> 发送请求 -> 响应拦截1 -> 响应拦截2")])]),e._v(" "),t("h4",{attrs:{id:"取消请求-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#取消请求-2"}},[e._v("#")]),e._v(" 取消请求")]),e._v(" "),t("p",[e._v("来到 Axios 最精彩的部分了，取消请求。我们知道 xhr 的 "),t("code",[e._v("xhr.abort();")]),e._v(" 函数可以取消请求。那么什么时候执行这个取消请求的操作呢？得有一个信号告诉 xhr 对象什么时候执行取消操作。取消请求就是未来某个时候要做的事情，你能想到什么呢？对，就是 Promise。Promise 的 "),t("code",[e._v("then")]),e._v("方法只有 Promise 对象的状态变为 resolved 的时候才会执行。我们可以利用这个特点，在 Promise 对象的 then 方法中执行取消请求的操作。看代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//CancelToken.js\n// 取消请求\nfunction CancelToken(executor){\n    if(typeof executor !== 'function'){\n        throw new TypeError('executor must be a function.')\n    }\n    var resolvePromise;\n    this.promise = new Promise((resolve)=>{\n        resolvePromise = resolve;\n    });\n    executor(resolvePromise)\n}\nCancelToken.source = function(){\n    var cancel;\n    var token = new CancelToken((c)=>{\n        cancel = c;\n    })\n    return {\n        token,\n        cancel\n    };\n}\nexport default CancelToken;\n")])])]),t("p",[e._v("当我们执行 "),t("code",[e._v("const source = CancelToken.source()")]),e._v("的时候，source 对象有两个字段，一个是 token 对象，另一个是 cancel 函数。在 xhr 请求中：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('//适配器\n// adapter.js\nfunction xhrAdapter(config){\n    return new Promise((resolve, reject)=>{\n        ...\n        //取消请求\n        if(config.cancelToken){\n            // 只有 resolved 的时候才会执行取消操作\n            config.cancelToken.promise.then(function onCanceled(cancel){\n                if(!xhr){\n                    return;\n                }\n                xhr.abort();\n                reject("请求已取消");\n                // clean up xhr\n                xhr = null;\n            })\n        }\n    })\n}\n')])])]),t("p",[e._v("CancelToken 的构造函数中需要传入一个函数，而这个函数的作用其实是为了将能控制内部 Promise 的 resolve 函数暴露出去，暴露给 source 的 cancel 函数。这样内部的 Promise 状态就可以通过 "),t("code",[e._v("source.cancel()")]),e._v(" 方法来控制啦，秒啊~ 👍")]),e._v(" "),t("h3",{attrs:{id:"node-后端接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-后端接口"}},[e._v("#")]),e._v(" node 后端接口")]),e._v(" "),t("p",[e._v("node 后端简单的接口代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const express = require("express");\nconst bodyParser = require(\'body-parser\');\nconst app = express();\nconst router = express.Router();\n//文件下载\nconst fs = require("fs");\n// get 请求\nrouter.get("/getCount", (req, res)=>{\n  setTimeout(()=>{\n    res.json({\n      success: true,\n      code: 200,\n      data: 100\n    })\n  }, 1000)\n})\n\n\n// 二进制文件流\nrouter.get(\'/downFile\', (req, res, next) => {\n  var name = \'download.txt\';\n  var path = \'./\' + name;\n  var size = fs.statSync(path).size;\n  var f = fs.createReadStream(path);\n  res.writeHead(200, {\n    \'Content-Type\': \'application/force-download\',\n    \'Content-Disposition\': \'attachment; filename=\' + name,\n    \'Content-Length\': size\n  });\n  f.pipe(res);\n})\n\n// 设置跨域访问\napp.all("*", function (request, response, next) {\n  // 设置跨域的域名，* 代表允许任意域名跨域；http://localhost:8080 表示前端请求的 Origin 地址\n  response.header("Access-Control-Allow-Origin", "http://127.0.0.1:5500");\n  //设置请求头 header 可以加那些属性\n  response.header(\'Access-Control-Allow-Headers\', \'Content-Type, Content-Length, Authorization, Accept, X-Requested-With\');\n  //暴露给 axios https://blog.csdn.net/w345731923/article/details/114067074\n  response.header("Access-Control-Expose-Headers", "Content-Disposition");\n  // 设置跨域可以携带 Cookie 信息\n  response.header(\'Access-Control-Allow-Credentials\', "true");\n  //设置请求头哪些方法是合法的\n  response.header(\n    "Access-Control-Allow-Methods",\n    "PUT,POST,GET,DELETE,OPTIONS"\n  );\n  response.header("Content-Type", "application/json;charset=utf-8");\n  next();\n});\n\n// 接口数据解析\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({\n  extended: false\n}))\napp.use(\'/api\', router) // 路由注册\n\napp.listen(8081, () => {\n  console.log("服务器启动成功！")\n});\n')])])]),t("h3",{attrs:{id:"git-地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git-地址"}},[e._v("#")]),e._v(" git 地址")]),e._v(" "),t("p",[e._v("如果大家能够跟着源码敲一遍，相信一定会有很多收获。")]),e._v(" "),t("p",[e._v("手写 Axios 核心代码 github 地址：https://github.com/YY88Xu/axios-js\nAxios 封装：https://github.com/YY88Xu/vue2-component")]),e._v(" "),t("p",[e._v("- EOF -")]),e._v(" "),t("p",[e._v("推荐阅读 点击标题可跳转")]),e._v(" "),t("p",[e._v("1、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651578212&idx=2&sn=3a4bdc17b0c1808f2b5649d84eff93a1&chksm=802508a5b75281b366dca8441c3ab2dc63b93adcd139ec5bb002dc8b10fef80efa49d49d92c2&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 中 Axios 的封装和 API 接口的管理"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("2、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651576212&idx=2&sn=b1c3fac9534f01f4d7c68f7b88800d5c&chksm=80250055b75289430570c54ba104675cbc6e5cf15cd35154a63f1d89b9f7211fb2f88f232e0f&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Axios 如何取消重复请求？"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("3、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651576184&idx=2&sn=58e01488d9c22b3de224e88df91ca93e&chksm=802500b9b75289afb55f9a448c6e3d3767fa5d0fba526696dea07e0f9bf167a4cd32791f373d&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("经得住拷问的 HTTPS 原理解析"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=a.exports}}]);