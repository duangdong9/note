(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{439:function(e,n,a){"use strict";a.r(n);var t=a(18),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"基于js管理大文件上传以及断点续传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于js管理大文件上传以及断点续传"}},[e._v("#")]),e._v(" 基于js管理大文件上传以及断点续传")]),e._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/jWGbhXEV0KtJu2pGfN4Hsg",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/jWGbhXEV0KtJu2pGfN4Hsg"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),a("blockquote",[a("p",[e._v('前端小伙伴们平常在开发过程中文件上传是经常遇到的一个问题，也许你能够实现相关的功能，但是做完后回想代码实现上是不是有点"力不从心"呢？你真的了解文件上传吗？如何做到大文件上传以及断电续传呢，前后端通讯常用的格式，文件上传进度管控，服务端是如何实现的？接下来让我们开启手摸手系列的学习吧！！！如有不足之处，望不吝指教，接下来按照下图进行学习探讨')])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQz67vZFmU6qBFDwXicqIIKOk8gZNFfvnIqmpVxbVXsAn0W662McpNuhmE38v0F1pqBTeOxN1QGlrA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("一切就绪，开始吧！！！")]),e._v(" "),a("h2",{attrs:{id:"前端结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端结构"}},[e._v("#")]),e._v(" 前端结构")]),e._v(" "),a("ul",[a("li",[e._v("页面展示")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQz67vZFmU6qBFDwXicqIIKOP0hS0iayf0ISRQia06vPDRVG0NNcsm7CfxaeSUQicDWPPQJMSPjaUibr1A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("image.png")]),e._v(" "),a("ul",[a("li",[e._v("项目依赖")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQz67vZFmU6qBFDwXicqIIKOuvDXcXKwY5Ln5VOKzziaFceKicTW2P57gmWMy9icnEHLlOpyOoIcy4olA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("依赖.png")]),e._v(" "),a("h2",{attrs:{id:"后端结构-node-express"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后端结构-node-express"}},[e._v("#")]),e._v(" 后端结构(node + express)")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("目录结构")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/pfCCZhlbMQQz67vZFmU6qBFDwXicqIIKOWIBicicW83Aicoavo1foT4pdhWnWUytN7kMUud228STQs4vShgUV2m8Gw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),e._v("后台代码.png")])]),e._v(" "),a("li",[a("p",[e._v("Axios的简单封装")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let instance = axios.create();\ninstance.defaults.baseURL = 'http://127.0.0.1:8888';\ninstance.defaults.headers['Content-Type'] = 'multipart/form-data';\ninstance.defaults.transformRequest = (data, headers) => {\n  const contentType = headers['Content-Type'];\n  if (contentType === \"application/x-www-form-urlencoded\") return Qs.stringify(data);\n  return data;\n};\ninstance.interceptors.response.use(response => {\n  return response.data;\n});\n复制代码\n")])])])])]),e._v(" "),a("p",[a("strong",[e._v("文件上传一般是基于两种方式，"),a("code",[e._v("FormData")]),e._v("以及"),a("code",[e._v("Base64")])])]),e._v(" "),a("h2",{attrs:{id:"基于formdata实现文件上传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于formdata实现文件上传"}},[e._v("#")]),e._v(" 基于FormData实现文件上传")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" //前端代码\n    // 主要展示基于ForData实现上传的核心代码\n    upload_button_upload.addEventListener('click', function () {\n            if (upload_button_upload.classList.contains('disable') || upload_button_upload.classList.contains('loading')) return;\n            if (!_file) {\n                alert('请您先选择要上传的文件~~');\n                return;\n            }\n            changeDisable(true);\n            // 把文件传递给服务器：FormData\n            let formData = new FormData();\n            // 根据后台需要提供的字段进行添加\n            formData.append('file', _file);\n            formData.append('filename', _file.name);\n            instance.post('/upload_single', formData).then(data => {\n                if (+data.code === 0) {\n                    alert(`文件已经上传成功~~,您可以基于 ${data.servicePath} 访问这个资源~~`);\n                    return;\n                }\n                return Promise.reject(data.codeText);\n            }).catch(reason => {\n                alert('文件上传失败，请您稍后再试~~');\n            }).finally(() => {\n                clearHandle();\n                changeDisable(false);\n            });\n        });\n复制代码\n")])])]),a("h2",{attrs:{id:"基于base64实现文件上传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于base64实现文件上传"}},[e._v("#")]),e._v(" 基于BASE64实现文件上传")]),e._v(" "),a("h3",{attrs:{id:"base64具体方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base64具体方法"}},[e._v("#")]),e._v(" BASE64具体方法")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("首先需要把文件流转为BASE64，这里可以封装一个方法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("export changeBASE64(file) => {\n return new Promise(resolve => {\n  let fileReader = new FileReader();\n  fileReader.readAsDataURL(file);\n  fileReader.onload = ev => {\n      resolve(ev.target.result);\n  };\n});\n};\n复制代码\n")])])])]),e._v(" "),a("li",[a("p",[e._v("具体实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("upload_inp.addEventListener('change', async function () {\n      let file = upload_inp.files[0],\n          BASE64,\n          data;\n      if (!file) return;\n      if (file.size > 2 * 1024 * 1024) {\n          alert('上传的文件不能超过2MB~~');\n          return;\n      }\n      upload_button_select.classList.add('loading');\n      // 获取Base64\n      BASE64 = await changeBASE64(file);\n      try {\n          data = await instance.post('/upload_single_base64', {\n          // encodeURIComponent(BASE64) 防止传输过程中特殊字符乱码，同时后端需要用decodeURIComponent进行解码\n              file: encodeURIComponent(BASE64),\n              filename: file.name\n          }, {\n              headers: {\n                  'Content-Type': 'application/x-www-form-urlencoded'\n              }\n          });\n          if (+data.code === 0) {\n              alert(`恭喜您，文件上传成功，您可以基于 ${data.servicePath} 地址去访问~~`);\n              return;\n          }\n          throw data.codeText;\n      } catch (err) {\n          alert('很遗憾，文件上传失败，请您稍后再试~~');\n      } finally {\n          upload_button_select.classList.remove('loading');\n      }\n  **});**\n复制代码\n")])])])])]),e._v(" "),a("p",[a("strong",[e._v("上面这个例子中后端收到前端传过来的文件会对它进行生成一个随机的名字，存下来，但是有些公司会将这一步放在前端进行，生成名字后一起发给后端，接下来我们来实现这个功能")])]),e._v(" "),a("h3",{attrs:{id:"前端生成文件名传给后端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端生成文件名传给后端"}},[e._v("#")]),e._v(" 前端生成文件名传给后端")]),e._v(" "),a("p",[e._v("这里就需要用到上面提到的插件"),a("strong",[e._v("SparkMD5")]),e._v("[1],具体怎么用就不做赘述了，请参考文档")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("封装读取文件流的方法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const changeBuffer = file => {\n  return new Promise(resolve => {\n      let fileReader = new FileReader();\n      fileReader.readAsArrayBuffer(file);\n      fileReader.onload = ev => {\n          let buffer = ev.target.result,\n              spark = new SparkMD5.ArrayBuffer(),\n              HASH,\n              suffix;\n          spark.append(buffer);\n          // 得到文件名\n          HASH = spark.end();\n          // 获取后缀名\n          suffix = /\\.([a-zA-Z0-9]+)$/.exec(file.name)[1];\n          resolve({\n              buffer,\n              HASH,\n              suffix,\n              filename: `${HASH}.${suffix}`\n          });\n      };\n  });\n};\n复制代码\n")])])])]),e._v(" "),a("li",[a("p",[e._v("上传服务器相关代码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("upload_button_upload.addEventListener('click', async function () {\n      if (checkIsDisable(this)) return;\n      if (!_file) {\n          alert('请您先选择要上传的文件~~');\n          return;\n      }\n      changeDisable(true);\n      // 生成文件的HASH名字\n      let {\n          filename\n      } = await changeBuffer(_file);\n      let formData = new FormData();\n      formData.append('file', _file);\n      formData.append('filename', filename);\n      instance.post('/upload_single_name', formData).then(data => {\n          if (+data.code === 0) {\n              alert(`文件已经上传成功~~,您可以基于 ${data.servicePath} 访问这个资源~~`);\n              return;\n          }\n          return Promise.reject(data.codeText);\n      }).catch(reason => {\n          alert('文件上传失败，请您稍后再试~~');\n      }).finally(() => {\n          changeDisable(false);\n          upload_abbre.style.display = 'none';\n          upload_abbre_img.src = '';\n          _file = null;\n      });\n  });\n复制代码\n")])])])])]),e._v(" "),a("h2",{attrs:{id:"上传进度管控"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上传进度管控"}},[e._v("#")]),e._v(" 上传进度管控")]),e._v(" "),a("p",[e._v("这个功能相对来说比较简单，文中用到的请求库是axios,进度管控主要基于axios提供的onUploadProgress函数进行实现，这里一起看下这个函数的实现原理")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("监听xhr.upload.onprogress")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("监听.png")])]),e._v(" "),a("li",[a("p",[e._v("文件上传后得到的对象")]),e._v(" "),a("p",[a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("xhr.png")])]),e._v(" "),a("li",[a("p",[e._v("具体实现")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("(function () {\n  let upload = document.querySelector('#upload4'),\n      upload_inp = upload.querySelector('.upload_inp'),\n      upload_button_select = upload.querySelector('.upload_button.select'),\n      upload_progress = upload.querySelector('.upload_progress'),\n      upload_progress_value = upload_progress.querySelector('.value');\n\n  // 验证是否处于可操作性状态\n  const checkIsDisable = element => {\n      let classList = element.classList;\n      return classList.contains('disable') || classList.contains('loading');\n  };\n\n  upload_inp.addEventListener('change', async function () {\n      let file = upload_inp.files[0],\n          data;\n      if (!file) return;\n      upload_button_select.classList.add('loading');\n      try {\n          let formData = new FormData();\n          formData.append('file', file);\n          formData.append('filename', file.name);\n          data = await instance.post('/upload_single', formData, {\n              // 文件上传中的回调函数 xhr.upload.onprogress\n              onUploadProgress(ev) {\n                  let {\n                      loaded,\n                      total\n                  } = ev;\n                  upload_progress.style.display = 'block';\n                  upload_progress_value.style.width = `${loaded/total*100}%`;\n              }\n          });\n          if (+data.code === 0) {\n              upload_progress_value.style.width = `100%`;\n              alert(`恭喜您，文件上传成功，您可以基于 ${data.servicePath} 访问该文件~~`);\n              return;\n          }\n          throw data.codeText;\n      } catch (err) {\n          alert('很遗憾，文件上传失败，请您稍后再试~~');\n      } finally {\n          upload_button_select.classList.remove('loading');\n          upload_progress.style.display = 'none';\n          upload_progress_value.style.width = `0%`;\n      }\n  });\n\n  upload_button_select.addEventListener('click', function () {\n      if (checkIsDisable(this)) return;\n      upload_inp.click();\n  });\n})();\n复制代码\n")])])])])]),e._v(" "),a("h2",{attrs:{id:"大文件上传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大文件上传"}},[e._v("#")]),e._v(" 大文件上传")]),e._v(" "),a("p",[e._v("大文件上传一般采用切片上传的方式，这样可以提高文件上传的速度，前端拿到文件流后进行切片，然后与后端进行通讯传输，一般还会结合断点继传，这时后端一般提供三个接口，第一个接口获取已经上传的切片信息，第二个接口将前端切片文件进行传输，第三个接口是将所有切片上传完成后告诉后端进行文件合并"),a("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),a("ul",[a("li",[a("p",[e._v("进行切片，切片的方式分为固定数量以及固定大小，我们这里两者结合一下")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 实现文件切片处理 「固定数量 & 固定大小」\nlet max = 1024 * 100,\n  count = Math.ceil(file.size / max),\n  index = 0,\n  chunks = [];\nif (count > 100) {\n  max = file.size / 100;\n  count = 100;\n}\nwhile (index < count) {\n  chunks.push({\n  // file文件本身就具有slice方法，见下图\n      file: file.slice(index * max, (index + 1) * max),\n      filename: `${HASH}_${index+1}.${suffix}`\n  });\n  index++;\n}\n复制代码\n")])])])]),e._v(" "),a("li",[a("p",[e._v("发送至服务端")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("chunks.forEach(chunk => {\n  let fm = new FormData;\n  fm.append('file', chunk.file);\n  fm.append('filename', chunk.filename);\n  instance.post('/upload_chunk', fm).then(data => {\n      if (+data.code === 0) {\n          complate();\n          return;\n      }\n      return Promise.reject(data.codeText);\n  }).catch(() => {\n      alert('当前切片上传失败，请您稍后再试~~');\n      clear();\n  });\n });\n复制代码\n")])])])]),e._v(" "),a("li",[a("p",[e._v("文件上传 + 断电续传 + 进度管控")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  upload_inp.addEventListener('change', async function () {\n      let file = upload_inp.files[0];\n      if (!file) return;\n      upload_button_select.classList.add('loading');\n      upload_progress.style.display = 'block';\n\n      // 获取文件的HASH\n      let already = [],\n          data = null,\n          {\n              HASH,\n              suffix\n          } = await changeBuffer(file);\n\n      // 获取已经上传的切片信息\n      try {\n          data = await instance.get('/upload_already', {\n              params: {\n                  HASH\n              }\n          });\n          if (+data.code === 0) {\n              already = data.fileList;\n          }\n      } catch (err) {}\n\n      // 实现文件切片处理 「固定数量 & 固定大小」\n      let max = 1024 * 100,\n          count = Math.ceil(file.size / max),\n          index = 0,\n          chunks = [];\n      if (count > 100) {\n          max = file.size / 100;\n          count = 100;\n      }\n      while (index < count) {\n          chunks.push({\n              file: file.slice(index * max, (index + 1) * max),\n              filename: `${HASH}_${index+1}.${suffix}`\n          });\n          index++;\n      }\n\n      // 上传成功的处理\n      index = 0;\n      const clear = () => {\n          upload_button_select.classList.remove('loading');\n          upload_progress.style.display = 'none';\n          upload_progress_value.style.width = '0%';\n      };\n      const complate = async () => {\n          // 管控进度条\n          index++;\n          upload_progress_value.style.width = `${index/count*100}%`;\n\n          // 当所有切片都上传成功，我们合并切片\n          if (index < count) return;\n          upload_progress_value.style.width = `100%`;\n          try {\n              data = await instance.post('/upload_merge', {\n                  HASH,\n                  count\n              }, {\n                  headers: {\n                      'Content-Type': 'application/x-www-form-urlencoded'\n                  }\n              });\n              if (+data.code === 0) {\n                  alert(`恭喜您，文件上传成功，您可以基于 ${data.servicePath} 访问该文件~~`);\n                  clear();\n                  return;\n              }\n              throw data.codeText;\n          } catch (err) {\n              alert('切片合并失败，请您稍后再试~~');\n              clear();\n          }\n      };\n\n      // 把每一个切片都上传到服务器上\n      chunks.forEach(chunk => {\n          // 已经上传的无需在上传\n          if (already.length > 0 && already.includes(chunk.filename)) {\n              complate();\n              return;\n          }\n          let fm = new FormData;\n          fm.append('file', chunk.file);\n          fm.append('filename', chunk.filename);\n          instance.post('/upload_chunk', fm).then(data => {\n              if (+data.code === 0) {\n                  complate();\n                  return;\n              }\n              return Promise.reject(data.codeText);\n          }).catch(() => {\n              alert('当前切片上传失败，请您稍后再试~~');\n              clear();\n          });\n      });\n  });\n复制代码\n")])])])])]),e._v(" "),a("h2",{attrs:{id:"服务端代码-大文件上传-断点续传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端代码-大文件上传-断点续传"}},[e._v("#")]),e._v(" 服务端代码(大文件上传+断点续传)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" // 大文件切片上传 & 合并切片\n    const merge = function merge(HASH, count) {\n        return new Promise(async (resolve, reject) => {\n            let path = `${uploadDir}/${HASH}`,\n                fileList = [],\n                suffix,\n                isExists;\n            isExists = await exists(path);\n            if (!isExists) {\n                reject('HASH path is not found!');\n                return;\n            }\n            fileList = fs.readdirSync(path);\n            if (fileList.length < count) {\n                reject('the slice has not been uploaded!');\n                return;\n            }\n            fileList.sort((a, b) => {\n                let reg = /_(\\d+)/;\n                return reg.exec(a)[1] - reg.exec(b)[1];\n            }).forEach(item => {\n                !suffix ? suffix = /\\.([0-9a-zA-Z]+)$/.exec(item)[1] : null;\n                fs.appendFileSync(`${uploadDir}/${HASH}.${suffix}`, fs.readFileSync(`${path}/${item}`));\n                fs.unlinkSync(`${path}/${item}`);\n            });\n            fs.rmdirSync(path);\n            resolve({\n                path: `${uploadDir}/${HASH}.${suffix}`,\n                filename: `${HASH}.${suffix}`\n            });\n        });\n    };\n    app.post('/upload_chunk', async (req, res) => {\n        try {\n            let {\n                fields,\n                files\n            } = await multiparty_upload(req);\n            let file = (files.file && files.file[0]) || {},\n                filename = (fields.filename && fields.filename[0]) || \"\",\n                path = '',\n                isExists = false;\n            // 创建存放切片的临时目录\n            let [, HASH] = /^([^_]+)_(\\d+)/.exec(filename);\n            path = `${uploadDir}/${HASH}`;\n            !fs.existsSync(path) ? fs.mkdirSync(path) : null;\n            // 把切片存储到临时目录中\n            path = `${uploadDir}/${HASH}/${filename}`;\n            isExists = await exists(path);\n            if (isExists) {\n                res.send({\n                    code: 0,\n                    codeText: 'file is exists',\n                    originalFilename: filename,\n                    servicePath: path.replace(__dirname, HOSTNAME)\n                });\n                return;\n            }\n            writeFile(res, path, file, filename, true);\n        } catch (err) {\n            res.send({\n                code: 1,\n                codeText: err\n            });\n        }\n    });\n    app.post('/upload_merge', async (req, res) => {\n        let {\n            HASH,\n            count\n        } = req.body;\n        try {\n            let {\n                filename,\n                path\n            } = await merge(HASH, count);\n            res.send({\n                code: 0,\n                codeText: 'merge success',\n                originalFilename: filename,\n                servicePath: path.replace(__dirname, HOSTNAME)\n            });\n        } catch (err) {\n            res.send({\n                code: 1,\n                codeText: err\n            });\n        }\n    });\n    app.get('/upload_already', async (req, res) => {\n        let {\n            HASH\n        } = req.query;\n        let path = `${uploadDir}/${HASH}`,\n            fileList = [];\n        try {\n            fileList = fs.readdirSync(path);\n            fileList = fileList.sort((a, b) => {\n                let reg = /_(\\d+)/;\n                return reg.exec(a)[1] - reg.exec(b)[1];\n            });\n            res.send({\n                code: 0,\n                codeText: '',\n                fileList: fileList\n            });\n        } catch (err) {\n            res.send({\n                code: 0,\n                codeText: '',\n                fileList: fileList\n            });\n        }\n    });\n复制代码\n")])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),a("p",[a("strong",[e._v("综上是我对文件上传的总结，能力有限，如有错误，望不吝指教，最后送上一句话：")])]),e._v(" "),a("blockquote",[a("p",[e._v("夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落")])]),e._v(" "),a("p",[e._v("关于本文")]),e._v(" "),a("h1",{attrs:{id:"来源-麦忙"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#来源-麦忙"}},[e._v("#")]),e._v(" 来源：麦忙")]),e._v(" "),a("p",[e._v("https://juejin.cn/post/7000654161297539079")])])}),[],!1,null,null,null);n.default=s.exports}}]);