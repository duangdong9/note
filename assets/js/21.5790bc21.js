(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{434:function(t,e,n){"use strict";n.r(e);var a=n(18),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"《you-dont-know-js》笔记小计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#《you-dont-know-js》笔记小计"}},[t._v("#")]),t._v(" 《You-Dont-Know-JS》笔记小计")]),t._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/VFbZgJagqXRlWteGvEDW0A",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://mp.weixin.qq.com/s/VFbZgJagqXRlWteGvEDW0A"),n("OutboundLink")],1)])]),t._v(" "),n("h2",{attrs:{id:"types-grammer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#types-grammer"}},[t._v("#")]),t._v(" types & grammer")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("判断以下结果")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" s "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ns"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" l "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nl"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("l"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("blockquote",[n("p",[n("code",[t._v("string")]),t._v(" 及其包装对象 (Boxed Object) 是不可变 (immutable) 类型，因此不能改变它本身(modify in place)，所以 "),n("code",[t._v("String")]),t._v(" 的所有方法都是返回一个新的字符串，而不会改变自身。")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("You-Dont-Know-JS")])])]),t._v(" "),n("li",[n("p",[t._v("如何逆序一个字符串？")]),t._v(" "),n("blockquote",[n("p",[n("code",[t._v("s.split('').reverse().join('')")])])])]),t._v(" "),n("li",[n("p",[t._v("接上，为什么不能直接使用 "),n("code",[t._v("Array.prototype.reverse.call(s)")]),t._v(" 逆序字符串？")]),t._v(" "),n("blockquote",[n("p",[t._v("当一个数组逆序时 "),n("code",[t._v("l.reverse()")]),t._v(" 会改变 l 本身。正如第一题，"),n("code",[t._v("string")]),t._v(" 不能改变自身。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果，为什么会出现这样的情况，如何做出正确的比较？")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("0.1 + 0.2 === 0.3;\n0.8 - 0.6 === 0.2;\n")])])]),n("blockquote",[n("p",[t._v("浮点数根据 IEEE 754 标准存储64 bit 双精度，能够表示 2^64 个数，而浮点数是无穷的，代表有些浮点数必会有精度的损失，0.1，0.2 表示为二进制会有精度的损失。比较时引入一个很小的数值 "),n("code",[t._v("Number.EPSILON")]),t._v(" 容忍误差，其值为 "),n("code",[t._v("2^-52")]),t._v("。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function equal (a, b) {\n  return Math.abs(a - b) < Number.EPSILON\n}\n")])])])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("You-Dont-Know-JS")]),t._v(" "),n("li",[t._v("知乎")])])]),t._v(" "),n("li",[n("p",[t._v("如何判断一个数值为整数？")]),t._v(" "),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// ES6\nNumber.isInteger(num);\n\n// ES5\nif (!Number.isInteger) {\n  Number.isInteger = function(num) {\n    return typeof num == "number" && num % 1 == 0;\n  };\n}\n')])])])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("You-Dont-Know-JS#user-content-testing-for-integers")])])]),t._v(" "),n("li",[n("p",[t._v("如何判断一个数值为 +0？")]),t._v(" "),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function isPosZero (n) {\n  return n === 0 && 1 / n === Infinity\n}\n")])])])])]),t._v(" "),n("li",[n("p",[n("code",[t._v("'abc'.toUpperCase()")]),t._v(" 中 'abc' 作为 primitive value，如何访问 "),n("code",[t._v("toUpperCase")]),t._v(" 方法")]),t._v(" "),n("blockquote",[n("p",[t._v("当 "),n("code",[t._v("primitive value")]),t._v(" 访问属性或者方法时，会自动转化为它的包装对象。另外也可以使用 "),n("code",[t._v("Object.prototype.valueOf()")]),t._v(" 解包装(Unboxing)。")])]),t._v(" "),n("blockquote")]),t._v(" "),n("li",[n("ul",[n("li",[t._v("You-Dont-Know-JS#user-content-boxing-wrappers")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Boxing Wrappers)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function foo() {\n  console.log(this)\n}\n\nfoo.call(3);\n")])])]),n("blockquote",[n("p",[t._v("Number(3)。理由如上。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Array.isArray(Array.prototype)\n")])])]),n("blockquote",[n("p",[t._v("true 内置对象的 prototype 都不是纯对象，比如 "),n("code",[t._v("Date.prototype")]),t._v(" 是 Date，"),n("code",[t._v("Set.prototype")]),t._v(" 是 Set。")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("You-Dont-Know-JS#user-content-native-prototypes")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Boolean(new Boolean(false));\nBoolean(document.all);\n\n[] == '';\n[3] == 3;\n[] == false;\n42 == true;\n")])])]),n("blockquote",[n("p",[t._v("new Boolean() 返回 object，为 true document.all，历史问题，参考这里Falsy value 指会被强制转化为 false 的值，有以下五种。除此之外全部会转化为 true")]),t._v(" "),n("p",[t._v("You-Dont-Know-JS#user-content-toboolean")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("undefined")]),t._v(" "),n("li",[t._v("null")]),t._v(" "),n("li",[t._v("false")]),t._v(" "),n("li",[t._v("+0, -0, and NaN")]),t._v(" "),n("li",[t._v('""')])])]),t._v(" "),n("li",[n("p",[t._v("找出以下代码问题 (TDZ)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a = 3;\nlet a;\n")])])]),n("blockquote",[n("p",[t._v("这是暂时性死域(Temporal Dead Zone)的问题，let a 声明之前，不能使用 a。")])])]),t._v(" "),n("li",[n("p",[t._v("找出以下代码问题 (TDZ)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var x = 3;\n\nfunction foo (x=x) {\n    // ..\n}\n\nfoo()\n")])])]),n("blockquote",[n("p",[t._v("同样，在函数默认参数中，也有 TDZ。")])])])]),t._v(" "),n("h2",{attrs:{id:"scope-closures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#scope-closures"}},[t._v("#")]),t._v(" scope & closures")]),t._v(" "),n("ol",[n("li",[n("p",[n("code",[t._v("var a = 2")]),t._v(" 中，"),n("code",[t._v("Engine")]),t._v("，"),n("code",[t._v("Scope")]),t._v("，"),n("code",[t._v("Compiler")]),t._v(" 做了什么工作")])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Lexical Scope)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var scope = 'global scope';\nfunction checkScope () {\n  var scope = 'local scope';\n  function f() {\n    return scope; \n  }\n  return f;\n}\n\ncheckScope()();\n")])])]),n("blockquote",[n("p",[t._v("'local scope'")]),t._v(" "),n("p",[t._v("由于 js 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果查找不到则在嵌套作用域中查找，直到找到。如果找不到，则报 "),n("code",[t._v("ReferenceError")]),t._v("。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Hoisting)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(a);\nvar a = 3;\n")])])]),n("blockquote",[n("p",[t._v("undefined")]),t._v(" "),n("p",[t._v("以上代码会被编译器理解为")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a;\nconsole.log(a);\na = 3;\n")])])])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Function First)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = 1;\nfunction foo () {\n\n}\nconsole.log(foo);\n")])])]),n("blockquote",[n("p",[t._v("1。函数也会有提升，所以会被赋值覆盖。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (IIFE & Function First)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = 1;\n(function () {\n  foo = 2;\n  function foo () {}\n\n  console.log(foo);\n})()\n\nconsole.log(foo);\n")])])]),n("blockquote",[n("p",[t._v("2，1")]),t._v(" "),n("p",[t._v("以上代码会被编译器理解为如下形式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = 1;\n(function () {\n  var foo;\n  function foo () {\n  }\n\n  foo = 2;\n  console.log(foo);\n})()\n\nconsole.log(foo);\n")])])])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果，如何按序输出 (Closure)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("for (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 1000)\n}\n")])])]),n("blockquote",[n("p",[t._v("大约 1s 之后连续输出 10 个 10。因为没有块级作用域，可以把 var 改成 let，也可以给 setTimeout 包装一层 IIFE。")])])])]),t._v(" "),n("h2",{attrs:{id:"this-object-prototypes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this-object-prototypes"}},[t._v("#")]),t._v(" this & object prototypes")]),t._v(" "),n("blockquote",[n("p",[t._v("注意：以下均为浏览器环境中")])]),t._v(" "),n("ol",[n("li",[n("p",[t._v("判断以下结果 (Default Binding)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function foo() {\n  "use strict";\n  console.log( this.a );\n}\n\nvar a = 2;\n\nfoo();\n')])])]),n("blockquote",[n("p",[t._v("会报错，在函数的严格模式下，默认绑定其中的 this 指向 undefined。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('"use strict";\nvar a = 2;\nlet b = 3;\n\nconsole.log(this.a, this.b);\n')])])]),n("blockquote",[n("p",[t._v("2, undefined")]),t._v(" "),n("p",[t._v("在浏览器环境中 this 指向 window，而 var 声明的变量会被挂在 window 上。而 let 声明的变量不会挂在 window 上。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Strict Mode & Default Binding)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function foo() {\n  console.log( this.a );\n}\n\nvar a = 2;\n\n(function(){\n  "use strict";\n\n  foo();\n})();\n')])])]),n("blockquote",[n("p",[t._v("2")]),t._v(" "),n("p",[t._v("只有存在 this 的函数中设置严格模式，this 为 undefined。因此会正常输出。")])])]),t._v(" "),n("li",[n("p",[t._v("判断以下结果 (Hard Binding)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function foo () {\n  console.log(this.a);\n}\n\nconst o1 = { a: 3 };\nconst o2 = { a: 4 };\n\nfoo.bind(o1).bind(o2)();\n")])])]),n("blockquote",[n("p",[t._v("3")]),t._v(" "),n("p",[t._v("bind 为硬绑定，第一次绑定后 this 无法再次绑定。")])])]),t._v(" "),n("li",[n("p",[t._v("如何实现 "),n("code",[t._v("Function.prototype.bind")]),t._v(" 与 "),n("code",[t._v("Function.prototype.softBind")])]),t._v(" "),n("blockquote",[n("p",[t._v("bind 为硬绑定，softBind 可以多次绑定 this。大致实现代码如下。bind 第二个参数可以预设函数参数，所以，bind 也是一个偏函数。另外，bind 也需要考虑 "),n("code",[t._v("new")]),t._v("的情况。"),n("strong",[t._v("「但以下示例主要集中在硬绑定和软绑定的差异之上。」")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Function.prototype.fakeBind = function (obj) {\n  var self = this;\n  return function () {\n    self.call(obj);\n  }\n}\n\nFunction.prototype.softBind = function(obj) {\n  var self = this;\n  return function () {\n    self.call(this === window? obj : this);\n  }\n};\n")])])])])]),t._v(" "),n("li",[n("p",[n("code",[t._v("new")]),t._v(" 的过程中发生了什么，判断以下结果 (new)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function F () {\n  this.a = 3;\n  return {\n    a: 4;\n  }\n}\n\nconst f = new F();\nconsole.log(f.a);\n")])])]),n("blockquote",[n("p",[t._v("4")]),t._v(" "),n("p",[n("code",[t._v("new")]),t._v(" 的过程大致为如下几个步骤")]),t._v(" "),n("p",[t._v("因为函数最后显式返回了一个对象，所以打印为 4")])])]),t._v(" "),n("li",[n("ol",[n("li",[t._v("创建一个新的对象")]),t._v(" "),n("li",[t._v("this 指向实例，并且执行函数")]),t._v(" "),n("li",[n("strong",[t._v("「如果没有显式返回，则默认返回这个实例」")])])])]),t._v(" "),n("li",[n("p",[t._v("什么是 "),n("code",[t._v("data descriptor")]),t._v(" 和 "),n("code",[t._v("accessor descriptor")])]),t._v(" "),n("blockquote",[n("p",[t._v("两者均通过 "),n("code",[t._v("Object.defineProperty()")]),t._v(" 定义，有两个公有的键值")]),t._v(" "),n("p",[t._v("数据描述符有以下键值")]),t._v(" "),n("p",[t._v("访问器描述符有以下键值")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const obj = {\n  get a() {},\n  set a(val) {}\n}\n")])])]),n("p",[t._v("Vue中 "),n("code",[t._v("computed")]),t._v(" 的内部原理便是"),n("code",[t._v("get")]),t._v("，而 "),n("code",[t._v("watch")]),t._v(" 的内部原理是 "),n("code",[t._v("set")])])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("set")]),t._v(" "),n("li",[t._v("get 另外，也可以通过字面量的形式表示访问器描述符")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("writable 该键是否可以更改")]),t._v(" "),n("li",[t._v("value")])])]),t._v(" "),n("li",[n("ul",[n("li",[t._v("configurable 设置该键是否可以删除")]),t._v(" "),n("li",[t._v("enumerable 设置是否可被遍历")])])]),t._v(" "),n("li",[n("p",[t._v("如何访问一个对象的属性？([[Get]])")]),t._v(" "),n("blockquote",[n("p",[t._v("访问对象的属性会触发 [[Get]] 操作，大致简述如下")]),t._v(" "),n("p",[t._v("查找过程与 Scope 查找变量很相似，只不过，对象属性找不到，返回 undefined，而变量找不到报 Reference Error。")])])]),t._v(" "),n("li",[n("ol",[n("li",[t._v("是否被 Proxy 拦截，如果拦截，查看拦截器的返回值，如果没拦截，继续下一步")]),t._v(" "),n("li",[t._v("检查自身属性，如果没找到则继续下一步")]),t._v(" "),n("li",[t._v("如果没被找到，则在原型链上查找，如果没找到，则返回 undefined")])])]),t._v(" "),n("li",[n("p",[t._v("如何对一个对象的属性赋值 ([[Put]])")]),t._v(" "),n("blockquote",[n("p",[t._v("对一个对象的属性赋值会触发 [[Put]] 操作，大致简述如下")])])]),t._v(" "),n("li",[n("ol",[n("li",[t._v("如果属性是访问描述符，则调用 setter 函数")]),t._v(" "),n("li",[t._v("如果属性是 data descriptor，则检查 writable 是否可写。如果可写，被自身属性覆盖，否则在严格模式下将会报错")]),t._v(" "),n("li",[t._v("普通属性，被自身属性覆盖")]),t._v(" "),n("li",[t._v("如果属性是访问描述符，则调用 setter 函数")]),t._v(" "),n("li",[t._v("如果属性是 data descriptor，则检查 writable 是否可写")]),t._v(" "),n("li",[t._v("普通属性，直接赋值")]),t._v(" "),n("li",[t._v("检查是否被 Proxy 拦截")]),t._v(" "),n("li",[t._v("如果该对象属性为自身属性 (obj.hasOwnProperty('a') === true)")]),t._v(" "),n("li",[t._v("如果该对象属性存在于原型链上")]),t._v(" "),n("li",[t._v("如果该对象不存在与原型链上，直接给自身属性赋值")])])]),t._v(" "),n("li",[n("p",[t._v("如何遍历一个对象 ($$iterator)")]),t._v(" "),n("blockquote",[n("p",[t._v("给对象设置 Symbol.iterator 属性")])])]),t._v(" "),n("li",[n("p",[t._v("如何实现一个继承 (Object.create & call)")]),t._v(" "),n("blockquote",[n("p",[t._v("在 ES6 时代可以简单的通过 class & extends 实现继承，ES5 时代用如下方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function A () {}\n\nfunction B () {\n  A.call(this)\n}\n\nB.prototype = Object.create(A.prototype)\n// B.prototype = new A()     不推荐\n")])])])])]),t._v(" "),n("li",[n("p",[t._v("如何实现 "),n("code",[t._v("Object.create")])]),t._v(" "),n("blockquote",[n("p",[t._v("至于为什么在继承的时候不推荐"),n("code",[t._v("new")]),t._v("，原因在于你很难保证 A 是一个纯函数，比如它会有自身属性，有可能操作 DOM 等。以下是一个简单版本的实现，省略了第二个参数。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Object.create = function (o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n")])])])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);