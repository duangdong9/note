(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{491:function(e,n,t){"use strict";t.r(n);var a=t(18),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一文帮你搞定-90-的-js-手写题-面试手写题不慌了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一文帮你搞定-90-的-js-手写题-面试手写题不慌了"}},[e._v("#")]),e._v(" 一文帮你搞定 90% 的 JS 手写题！面试手写题不慌了")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/VyBjZzrFK25B7DpLXPduhQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/VyBjZzrFK25B7DpLXPduhQ"),t("OutboundLink")],1)])]),e._v(" "),t("h3",{attrs:{id:"_1-call的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-call的实现"}},[e._v("#")]),e._v(" 1.call的实现")]),e._v(" "),t("ul",[t("li",[e._v("第一个参数为null或者undefined时，this指向全局对象window，值为原始值的指向该原始值的自动包装对象，如 String、Number、Boolean")]),e._v(" "),t("li",[e._v("为了避免函数名与上下文(context)的属性发生冲突，使用Symbol类型作为唯一值")]),e._v(" "),t("li",[e._v("将函数作为传入的上下文(context)属性执行")]),e._v(" "),t("li",[e._v("函数执行完成后删除该属性")]),e._v(" "),t("li",[e._v("返回执行结果")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Function.prototype.myCall = function(context,...args){\n    let cxt = context || window;\n    //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)\n    //新建一个唯一的Symbol变量避免重复\n    let func = Symbol() \n    cxt[func] = this;\n    args = args ? args : []\n    //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向\n    const res = args.length > 0 ? cxt[func](...args) : cxt[func]();\n    //删除该方法，不然会对传入对象造成污染（添加该方法）\n    delete cxt[func];\n    return res;\n}\n")])])]),t("h3",{attrs:{id:"_2-apply的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-apply的实现"}},[e._v("#")]),e._v(" 2.apply的实现")]),e._v(" "),t("ul",[t("li",[e._v("前部分与call一样")]),e._v(" "),t("li",[e._v("第二个参数可以不传，但类型必须为数组或者类数组")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Function.prototype.myApply = function(context,args = []){\n    let cxt = context || window;\n    //将当前被调用的方法定义在cxt.func上.(为了能以对象调用形式绑定this)\n    //新建一个唯一的Symbol变量避免重复\n    let func = Symbol()\n    cxt[func] = this;\n    //以对象调用形式调用func,此时this指向cxt 也就是传入的需要绑定的this指向\n    const res = args.length > 0 ? cxt[func](...args) : cxt[func]();\n    delete cxt[func];\n    return res;\n}\n")])])]),t("h3",{attrs:{id:"_3-bind的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-bind的实现"}},[e._v("#")]),e._v(" 3.bind的实现")]),e._v(" "),t("p",[e._v("需要考虑：")]),e._v(" "),t("ul",[t("li",[e._v("bind() 除了 this 外，还可传入多个参数；")]),e._v(" "),t("li",[e._v("bind 创建的新函数可能传入多个参数；")]),e._v(" "),t("li",[e._v("新函数可能被当做构造函数调用；")]),e._v(" "),t("li",[e._v("函数可能有返回值；")])]),e._v(" "),t("p",[e._v("实现方法：")]),e._v(" "),t("ul",[t("li",[e._v("bind 方法不会立即执行，需要返回一个待执行的函数；（闭包）")]),e._v(" "),t("li",[e._v("实现作用域绑定（apply）")]),e._v(" "),t("li",[e._v("参数传递（apply 的数组传参）")]),e._v(" "),t("li",[e._v("当作为构造函数的时候，进行原型继承")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Function.prototype.myBind = function (context, ...args) {\n    //新建一个变量赋值为this，表示当前函数\n    const fn = this\n    //判断有没有传参进来，若为空则赋值[]\n    args = args ? args : []\n    //返回一个newFn函数，在里面调用fn\n    return function newFn(...newFnArgs) {\n        if (this instanceof newFn) {\n            return new fn(...args, ...newFnArgs)\n        }\n        return fn.apply(context, [...args,...newFnArgs])\n    }\n}\n")])])]),t("ul",[t("li",[e._v("测试")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let name = '小王',age =17;\nlet obj = {\n    name:'小张',\n    age: this.age,\n    myFun: function(from,to){\n        console.log(this.name + ' 年龄 ' + this.age+'来自 '+from+'去往'+ to)\n    }\n}\nlet db = {\n    name: '德玛',\n    age: 99\n}\n\n//结果\nobj.myFun.myCall(db,'成都','上海');     // 德玛 年龄 99  来自 成都去往上海\nobj.myFun.myApply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海\nobj.myFun.myBind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海\nobj.myFun.myBind(db,['成都','上海'])();   // 德玛 年龄 99  来自 成都, 上海去往 undefined\n")])])]),t("h3",{attrs:{id:"_4-寄生式组合继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-寄生式组合继承"}},[e._v("#")]),e._v(" 4.寄生式组合继承")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function Person(obj) {\n    this.name = obj.name\n    this.age = obj.age\n}\nPerson.prototype.add = function(value){\n    console.log(value)\n}\nvar p1 = new Person({name:"番茄", age: 18})\n\nfunction Person1(obj) {\n    Person.call(this, obj)\n    this.sex = obj.sex\n}\n// 这一步是继承的关键\nPerson1.prototype = Object.create(Person.prototype);\nPerson1.prototype.constructor = Person1;\n\nPerson1.prototype.play = function(value){\n    console.log(value)\n}\nvar p2 = new Person1({name:"鸡蛋", age: 118, sex: "男"})\n')])])]),t("h3",{attrs:{id:"_5-es6继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-es6继承"}},[e._v("#")]),e._v(" 5.ES6继承")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//class 相当于es5中构造函数\n//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中\n//class中定义的所有方法是不可枚举的\n//class中只能定义方法，不能定义对象，变量等\n//class和方法内默认都是严格模式\n//es5中constructor为隐式属性\nclass People{\n  constructor(name='wang',age='27'){\n    this.name = name;\n    this.age = age;\n  }\n  eat(){\n    console.log(`${this.name} ${this.age} eat food`)\n  }\n}\n//继承父类\nclass Woman extends People{ \n   constructor(name = 'ren',age = '27'){ \n     //继承父类属性\n     super(name, age); \n   } \n    eat(){ \n     //继承父类方法\n      super.eat() \n    } \n} \nlet wonmanObj=new Woman('xiaoxiami'); \nwonmanObj.eat();\n\n//es5继承先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。 \n//es6继承是使用关键字super先创建父类的实例对象this，最后在子类class中修改this。\n")])])]),t("h3",{attrs:{id:"_6-new的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-new的实现"}},[e._v("#")]),e._v(" 6.new的实现")]),e._v(" "),t("ul",[t("li",[e._v("一个继承自 Foo.prototype 的新对象被创建。")]),e._v(" "),t("li",[e._v("使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。")]),e._v(" "),t("li",[e._v("由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。")]),e._v(" "),t("li",[e._v("一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Ctor(){\n    ....\n}\n\nfunction myNew(ctor,...args){\n    if(typeof ctor !== 'function'){\n      throw 'myNew function the first param must be a function';\n    }\n    var newObj = Object.create(ctor.prototype); //创建一个继承自ctor.prototype的新对象\n    var ctorReturnResult = ctor.apply(newObj, args); //将构造函数ctor的this绑定到newObj中\n    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;\n    var isFunction = typeof ctorReturnResult === 'function';\n    if(isObject || isFunction){\n        return ctorReturnResult;\n    }\n    return newObj;\n}\n\nlet c = myNew(Ctor);\n")])])]),t("h3",{attrs:{id:"_7-instanceof的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-instanceof的实现"}},[e._v("#")]),e._v(" 7.instanceof的实现")]),e._v(" "),t("ul",[t("li",[e._v("instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。")]),e._v(" "),t("li",[e._v("instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。")]),e._v(" "),t("li",[e._v("不能检测基本数据类型，在原型链上的结果未必准确，不能检测null,undefined")]),e._v(" "),t("li",[e._v("实现：遍历左边变量的原型链，直到找到右边变量的 prototype，如果没有找到，返回 false")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function myInstanceOf(a,b){\n    let left = a.__proto__;\n    let right = b.prototype;\n    while(true){\n        if(left == null){\n            return false\n        }\n        if(left == right){\n            return true\n        }\n        left = left.__proto__\n    }\n}\n\n//instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\nfunction myInstanceof(left, right) {\n    let proto = Object.getPrototypeOf(left), // 获取对象的原型\n    prototype = right.prototype; // 获取构造函数的 prototype 对象\n    // 判断构造函数的 prototype 对象是否在对象的原型链上\n    while (true) {\n        if (!proto) return false;\n        if (proto === prototype) return true;\n        proto = Object.getPrototypeOf(proto);\n    }\n}\n")])])]),t("h3",{attrs:{id:"_8-object-create-的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-object-create-的实现"}},[e._v("#")]),e._v(" 8.Object.create()的实现")]),e._v(" "),t("ul",[t("li",[e._v("MDN文档")]),e._v(" "),t("li",[e._v("Object.create()会将参数对象作为一个新创建的空对象的原型, 并返回这个空对象")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//简略版\nfunction myCreate(obj){\n    // 新声明一个函数\n    function C(){};\n    // 将函数的原型指向obj\n    C.prototype = obj;\n    // 返回这个函数的实力化对象\n    return new C()\n}\n//官方版Polyfill\nif (typeof Object.create !== \"function\") {\n    Object.create = function (proto, propertiesObject) {\n        if (typeof proto !== 'object' && typeof proto !== 'function') {\n            throw new TypeError('Object prototype may only be an Object: ' + proto);\n        } else if (proto === null) {\n            throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n        }\n\n        if (typeof propertiesObject !== 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\");\n\n        function F() {}\n        F.prototype = proto;\n\n        return new F();\n    };\n}\n")])])]),t("h3",{attrs:{id:"_9-实现-object-assign"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-实现-object-assign"}},[e._v("#")]),e._v(" 9.实现 Object.assign")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Object.assign2 = function(target, ...source) {\n    if (target == null) {\n        throw new TypeError('Cannot convert undefined or null to object')\n    }\n    let ret = Object(target) \n    source.forEach(function(obj) {\n        if (obj != null) {\n            for (let key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    ret[key] = obj[key]\n                }\n            }\n        }\n    })\n    return ret\n}\n")])])]),t("h3",{attrs:{id:"_10-promise的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-promise的实现"}},[e._v("#")]),e._v(" 10.Promise的实现")]),e._v(" "),t("p",[e._v("实现 Promise 需要完全读懂 Promise A+ 规范，不过从总体的实现上看，有如下几个点需要考虑到：")]),e._v(" "),t("ul",[t("li",[e._v("Promise本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从Pending -> Fulfilled 或 Pending -> Rejected，状态变更不可逆")]),e._v(" "),t("li",[e._v("then 需要支持链式调用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Promise {\n    callbacks = [];\n    state = 'pending';//增加状态\n    value = null;//保存结果\n    constructor(fn) {\n        fn(this._resolve.bind(this), this._reject.bind(this));\n    }\n    then(onFulfilled, onRejected) {\n        return new Promise((resolve, reject) => {\n            this._handle({\n                onFulfilled: onFulfilled || null,\n                onRejected: onRejected || null,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    }\n    _handle(callback) {\n        if (this.state === 'pending') {\n            this.callbacks.push(callback);\n            return;\n        }\n \n        let cb = this.state === 'fulfilled' ? callback.onFulfilled : callback.onRejected;\n \n        if (!cb) {//如果then中没有传递任何东西\n            cb = this.state === 'fulfilled' ? callback.resolve : callback.reject;\n            cb(this.value);\n            return;\n        }\n \n        let ret = cb(this.value);\n        cb = this.state === 'fulfilled' ? callback.resolve : callback.reject;\n        cb(ret);\n    }\n    _resolve(value) {\n \n        if (value && (typeof value === 'object' || typeof value === 'function')) {\n            var then = value.then;\n            if (typeof then === 'function') {\n                then.call(value, this._resolve.bind(this), this._reject.bind(this));\n                return;\n            }\n        }\n \n        this.state = 'fulfilled';//改变状态\n        this.value = value;//保存结果\n        this.callbacks.forEach(callback => this._handle(callback));\n    }\n    _reject(error) {\n        this.state = 'rejected';\n        this.value = error;\n        this.callbacks.forEach(callback => this._handle(callback));\n    }\n}\n")])])]),t("h4",{attrs:{id:"promise-resolve"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" Promise.resolve")]),e._v(" "),t("ul",[t("li",[e._v("Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.resolve(value) {\n  if (value && value instanceof Promise) {\n    return value;\n  } else if (value && typeof value === 'object' && typeof value.then === 'function') {\n    let then = value.then;\n    return new Promise(resolve => {\n      then(resolve);\n    });\n  } else if (value) {\n    return new Promise(resolve => resolve(value));\n  } else {\n    return new Promise(resolve => resolve());\n  }\n}\n")])])]),t("h4",{attrs:{id:"promise-reject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-reject"}},[e._v("#")]),e._v(" Promise.reject")]),e._v(" "),t("ul",[t("li",[e._v("和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.reject = function(reason) {\n    return new Promise((resolve, reject) => reject(reason))\n}\n")])])]),t("h4",{attrs:{id:"promise-all"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" Promise.all")]),e._v(" "),t("ul",[t("li",[e._v("传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；")]),e._v(" "),t("li",[e._v("只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；")]),e._v(" "),t("li",[e._v("只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.all = function(promiseArr) {\n    let index = 0, result = []\n    return new Promise((resolve, reject) => {\n        promiseArr.forEach((p, i) => {\n            Promise.resolve(p).then(val => {\n                index++\n                result[i] = val\n                if (index === promiseArr.length) {\n                    resolve(result)\n                }\n            }, err => {\n                reject(err)\n            })\n        })\n    })\n}\n")])])]),t("h4",{attrs:{id:"promise-race"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" Promise.race")]),e._v(" "),t("ul",[t("li",[e._v("Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise.race = function(promiseArr) {\n    return new Promise((resolve, reject) => {\n        promiseArr.forEach(p => {\n            Promise.resolve(p).then(val => {\n                resolve(val)\n            }, err => {\n                rejecte(err)\n            })\n        })\n    })\n}\n")])])]),t("h3",{attrs:{id:"_11-ajax的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-ajax的实现"}},[e._v("#")]),e._v(" 11.Ajax的实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function ajax(url,method,body,headers){\n    return new Promise((resolve,reject)=>{\n        let req = new XMLHttpRequest();\n        req.open(methods,url);\n        for(let key in headers){\n            req.setRequestHeader(key,headers[key])\n        }\n        req.onreadystatechange(()=>{\n            if(req.readystate == 4){\n                if(req.status >= '200' && req.status <= 300){\n                    resolve(req.responeText)\n                }else{\n                    reject(req)\n                }\n            }\n        })\n        req.send(body)\n    })\n}\n")])])]),t("h3",{attrs:{id:"_12-实现防抖函数-debounce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-实现防抖函数-debounce"}},[e._v("#")]),e._v(" 12.实现防抖函数（debounce）")]),e._v(" "),t("ul",[t("li",[e._v("连续触发在最后一次执行方法，场景：输入框匹配")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let debounce = (fn,time = 1000) => {\n    let timeLock = null\n\n    return function (...args){\n        clearTimeout(timeLock)\n        timeLock = setTimeout(()=>{\n            fn(...args)\n        },time)\n    }\n}\n")])])]),t("h3",{attrs:{id:"_13-实现节流函数-throttle"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-实现节流函数-throttle"}},[e._v("#")]),e._v(" 13.实现节流函数（throttle）")]),e._v(" "),t("ul",[t("li",[e._v("在一定时间内只触发一次，场景：长列表滚动节流")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let throttle = (fn,time = 1000) => {\n    let flag = true;\n\n    return function (...args){\n        if(flag){\n            flag = false;\n            setTimeout(()=>{\n                flag = true;\n                fn(...args)\n            },time)\n        }\n    }\n}\n")])])]),t("h3",{attrs:{id:"_14-深拷贝-deepclone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-深拷贝-deepclone"}},[e._v("#")]),e._v(" 14.深拷贝（deepclone）")]),e._v(" "),t("ul",[t("li",[e._v("判断类型，正则和日期直接返回新对象")]),e._v(" "),t("li",[e._v("空或者非对象类型，直接返回原值")]),e._v(" "),t("li",[e._v("考虑循环引用，判断如果hash中含有直接返回hash中的值")]),e._v(" "),t("li",[e._v("新建一个相应的new obj.constructor加入hash")]),e._v(" "),t("li",[e._v("遍历对象递归（普通key和key是symbol情况）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function deepClone(obj,hash = new WeakMap()){\n    if(obj instanceof RegExp) return new RegExp(obj);\n    if(obj instanceof Date) return new Date(obj);\n    if(obj === null || typeof obj !== 'object') return obj;\n    //循环引用的情况\n    if(hash.has(obj)){\n        return hash.get(obj)\n    }\n    //new 一个相应的对象\n    //obj为Array，相当于new Array()\n    //obj为Object，相当于new Object()\n    let constr = new obj.constructor();\n    hash.set(obj,constr);\n    for(let key in obj){\n        if(obj.hasOwnProperty(key)){\n            constr[key] = deepClone(obj[key],hash)\n        }\n    }\n    //考虑symbol的情况\n    let symbolObj = Object.getOwnPropertySymbols(obj)\n    for(let i=0;i<symbolObj.length;i++){\n        if(obj.hasOwnProperty(symbolObj[i])){\n            constr[symbolObj[i]] = deepClone(obj[symbolObj[i]],hash)\n        }\n    }\n    return constr\n}\n")])])]),t("h3",{attrs:{id:"_15-数组扁平化的实现-flat"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-数组扁平化的实现-flat"}},[e._v("#")]),e._v(" 15.数组扁平化的实现(flat)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [1,2,[3,4,[5,[6]]]]\nconsole.log(arr.flat(Infinity))//flat参数为指定要提取嵌套数组的结构深度，默认值为 1\n//用reduce实现\nfunction fn(arr){\n   return arr.reduce((prev,cur)=>{\n      return prev.concat(Array.isArray(cur)?fn(cur):cur)\n   },[])\n}\n")])])]),t("h3",{attrs:{id:"_16-函数柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-函数柯里化"}},[e._v("#")]),e._v(" 16.函数柯里化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sumFn(a,b,c){return a+ b + c};\nlet sum = curry(sumFn);\nsum(2)(3)(5)//10\nsum(2,3)(5)//10\nfunction curry(fn,...args){\n  let fnLen = fn.length,\n      argsLen = args.length;\n  //对比函数的参数和当前传入参数\n  //若参数不够就继续递归返回curry\n  //若参数够就调用函数返回相应的值\n  if(fnLen > argsLen){\n    return function(...arg2s){\n      return curry(fn,...args,...arg2s)\n    }\n  }else{\n    return fn(...args)\n  }\n}\n")])])]),t("h3",{attrs:{id:"_17-使用闭包实现每隔一秒打印-1-2-3-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-使用闭包实现每隔一秒打印-1-2-3-4"}},[e._v("#")]),e._v(" 17.使用闭包实现每隔一秒打印 1,2,3,4")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("for (var i=1; i<=5; i++) {\n  (function (i) {\n    setTimeout(() => console.log(i), 1000*i)\n  })(i)\n}\n")])])]),t("h3",{attrs:{id:"_18-手写一个-jsonp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-手写一个-jsonp"}},[e._v("#")]),e._v(" 18.手写一个 jsonp")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const jsonp = function (url, data) {\n    return new Promise((resolve, reject) => {\n        // 初始化url\n        let dataString = url.indexOf('?') === -1 ? '?' : ''\n        let callbackName = `jsonpCB_${Date.now()}`\n        url += `${dataString}callback=${callbackName}`\n        if (data) {\n            // 有请求参数，依次添加到url\n            for (let k in data) {\n                url += `${k}=${data[k]}`\n            }\n        }\n        let jsNode = document.createElement('script')\n        jsNode.src = url\n        // 触发callback，触发后删除js标签和绑定在window上的callback\n        window[callbackName] = result => {\n            delete window[callbackName]\n            document.body.removeChild(jsNode)\n            if (result) {\n                resolve(result)\n            } else {\n                reject('没有返回数据')\n            }\n        }\n        // js加载异常的情况\n        jsNode.addEventListener('error', () => {\n            delete window[callbackName]\n            document.body.removeChild(jsNode)\n            reject('JavaScript资源加载失败')\n        }, false)\n        // 添加js节点到document上时，开始请求\n        document.body.appendChild(jsNode)\n    })\n}\njsonp('http://192.168.0.103:8081/jsonp', {\n    a: 1,\n    b: 'heiheihei'\n})\n.then(result => {\n    console.log(result)\n})\n.catch(err => {\n    console.error(err)\n})\n")])])]),t("h3",{attrs:{id:"_19-手写一个观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-手写一个观察者模式"}},[e._v("#")]),e._v(" 19.手写一个观察者模式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Subject{\n  constructor(name){\n    this.name = name\n    this.observers = []\n    this.state = 'XXXX'\n  }\n  // 被观察者要提供一个接受观察者的方法\n  attach(observer){\n    this.observers.push(observer)\n  }\n\n  // 改变被观察着的状态\n  setState(newState){\n    this.state = newState\n    this.observers.forEach(o=>{\n      o.update(newState)\n    })\n  }\n}\n\nclass Observer{\n  constructor(name){\n    this.name = name\n  }\n\n  update(newState){\n    console.log(`${this.name}say:${newState}`)\n  }\n}\n\n// 被观察者 灯\nlet sub = new Subject('灯')\nlet mm = new Observer('小明')\nlet jj = new Observer('小健')\n \n// 订阅 观察者\nsub.attach(mm)\nsub.attach(jj)\n \nsub.setState('灯亮了来电了')\n")])])]),t("h3",{attrs:{id:"_20-eventemitter-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-eventemitter-实现"}},[e._v("#")]),e._v(" 20.EventEmitter 实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class EventEmitter {\n    constructor() {\n        this.events = {};\n    }\n    on(event, callback) {\n        let callbacks = this.events[event] || [];\n        callbacks.push(callback);\n        this.events[event] = callbacks;\n        return this;\n    }\n    off(event, callback) {\n        let callbacks = this.events[event];\n        this.events[event] = callbacks && callbacks.filter(fn => fn !== callback);\n        return this;\n    }\n    emit(event, ...args) {\n        let callbacks = this.events[event];\n        callbacks.forEach(fn => {\n            fn(...args);\n        });\n        return this;\n    }\n    once(event, callback) {\n        let wrapFun = function (...args) {\n            callback(...args);\n            this.off(event, wrapFun);\n        };\n        this.on(event, wrapFun);\n        return this;\n    }\n}\n")])])]),t("h3",{attrs:{id:"_21-生成随机数的各种方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-生成随机数的各种方法"}},[e._v("#")]),e._v(" 21.生成随机数的各种方法？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function getRandom(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min   \n}\n")])])]),t("h3",{attrs:{id:"_22-如何实现数组的随机排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-如何实现数组的随机排序"}},[e._v("#")]),e._v(" 22.如何实现数组的随机排序？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [2,3,454,34,324,32]\narr.sort(randomSort)\nfunction randomSort(a, b) {\n  return Math.random() > 0.5 ? -1 : 1;\n}\n")])])]),t("h3",{attrs:{id:"_23-写一个通用的事件侦听器函数。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-写一个通用的事件侦听器函数。"}},[e._v("#")]),e._v(" 23.写一个通用的事件侦听器函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const EventUtils = {\n  // 视能力分别使用dom0||dom2||IE方式 来绑定事件\n  // 添加事件\n  addEvent: function(element, type, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(type, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent("on" + type, handler);\n    } else {\n      element["on" + type] = handler;\n    }\n  },\n  // 移除事件\n  removeEvent: function(element, type, handler) {\n    if (element.removeEventListener) {\n      element.removeEventListener(type, handler, false);\n    } else if (element.detachEvent) {\n      element.detachEvent("on" + type, handler);\n    } else {\n      element["on" + type] = null;\n    }\n  },\n // 获取事件目标\n  getTarget: function(event) {\n    return event.target || event.srcElement;\n  },\n  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event\n  getEvent: function(event) {\n    return event || window.event;\n  },\n // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）\n  stopPropagation: function(event) {\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else {\n      event.cancelBubble = true;\n    }\n  },\n  // 取消事件的默认行为\n  preventDefault: function(event) {\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else {\n      event.returnValue = false;\n    }\n  }\n};\n')])])]),t("h3",{attrs:{id:"_24-使用迭代的方式实现-flatten-函数。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-使用迭代的方式实现-flatten-函数。"}},[e._v("#")]),e._v(" 24.使用迭代的方式实现 flatten 函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var arr = [1, 2, 3, [4, 5], [6, [7, [8]]]]\n/** * 使用递归的方式处理 * wrap 内保\n存结果 ret * 返回一个递归函数 **/\nfunction wrap() {\n    var ret = [];\n    return function flat(a) {\n        for (var item of\n            a) {\n                if (item.constructor === Array) {\n                    ret.concat(flat(item))\n                } else {\n                    ret.push(item)\n                }\n        }\n        return ret\n    }\n} \nconsole.log(wrap()(arr));\n")])])]),t("h3",{attrs:{id:"_25-怎么实现一个sleep"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-怎么实现一个sleep"}},[e._v("#")]),e._v(" 25.怎么实现一个sleep")]),e._v(" "),t("ul",[t("li",[e._v("sleep函数作用是让线程休眠，等到指定时间在重新唤起。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sleep(delay) {\n  var start = (new Date()).getTime();\n  while ((new Date()).getTime() - start < delay) {\n    continue;\n  }\n}\n\nfunction test() {\n  console.log('111');\n  sleep(2000);\n  console.log('222');\n}\n\ntest()\n")])])]),t("h3",{attrs:{id:"_26-实现正则切分千分位-10000-10-000"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-实现正则切分千分位-10000-10-000"}},[e._v("#")]),e._v(" 26.实现正则切分千分位（10000 => 10,000）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//无小数点\nlet num1 = '1321434322222'\nnum1.replace(/(\\d)(?=(\\d{3})+$)/g,'$1,')\n//有小数点\nlet num2 = '342243242322.3432423'\nnum2.replace(/(\\d)(?=(\\d{3})+\\.)/g,'$1,')\n")])])]),t("h3",{attrs:{id:"_27-对象数组去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-对象数组去重"}},[e._v("#")]),e._v(" 27.对象数组去重")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入:\n[{a:1,b:2,c:3},{b:2,c:3,a:1},{d:2,c:2}]\n输出:\n[{a:1,b:2,c:3},{d:2,c:2}]\n")])])]),t("ul",[t("li",[e._v("首先写一个函数把对象中的key排序，然后再转成字符串")]),e._v(" "),t("li",[e._v("遍历数组利用Set将转为字符串后的对象去重")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function objSort(obj){\n    let newObj = {}\n    //遍历对象，并将key进行排序\n    Object.keys(obj).sort().map(key => {\n        newObj[key] = obj[key]\n    })\n    //将排序好的数组转成字符串\n    return JSON.stringify(newObj)\n}\n\nfunction unique(arr){\n    let set = new Set();\n    for(let i=0;i<arr.length;i++){\n        let str = objSort(arr[i])\n        set.add(str)\n    }\n    //将数组中的字符串转回对象\n    arr = [...set].map(item => {\n        return JSON.parse(item)\n    })\n    return arr\n}\n")])])]),t("h3",{attrs:{id:"_28-解析-url-params-为对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-解析-url-params-为对象"}},[e._v("#")]),e._v(" 28.解析 URL Params 为对象")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';\nparseParam(url)\n/* 结果\n{ user: 'anonymous',\n  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n  city: '北京', // 中文需解码\n  enabled: true, // 未指定值得 key 约定为 true\n}\n*/\nfunction parseParam(url) {\n  const paramsStr = /.+\\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来\n  const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中\n  let paramsObj = {};\n  // 将 params 存到对象中\n  paramsArr.forEach(param => {\n    if (/=/.test(param)) { // 处理有 value 的参数\n      let [key, val] = param.split('='); // 分割 key 和 value\n      val = decodeURIComponent(val); // 解码\n      val = /^\\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字\n\n      if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值\n        paramsObj[key] = [].concat(paramsObj[key], val);\n      } else { // 如果对象没有这个 key，创建 key 并设置值\n        paramsObj[key] = val;\n      }\n    } else { // 处理没有 value 的参数\n      paramsObj[param] = true;\n    }\n  })\n\n  return paramsObj;\n}\n")])])]),t("h3",{attrs:{id:"_29-模板引擎实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29-模板引擎实现"}},[e._v("#")]),e._v(" 29.模板引擎实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';\nlet data = {\n  name: '姓名',\n  age: 18\n}\nrender(template, data); // 我是姓名，年龄18，性别undefined\nfunction render(template, data) {\n  const reg = /\\{\\{(\\w+)\\}\\}/; // 模板字符串正则\n  if (reg.test(template)) { // 判断模板里是否有模板字符串\n    const name = reg.exec(template)[1]; // 查找当前模板里第一个模板字符串的字段\n    template = template.replace(reg, data[name]); // 将第一个模板字符串渲染\n    return render(template, data); // 递归的渲染并返回渲染后的结构\n  }\n  return template; // 如果模板没有模板字符串直接返回\n}\n")])])]),t("h3",{attrs:{id:"_30-转化为驼峰命名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_30-转化为驼峰命名"}},[e._v("#")]),e._v(" 30.转化为驼峰命名")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var s1 = "get-element-by-id"\n// 转化为 getElementById\nvar f = function(s) {\n    return s.replace(/-\\w/g, function(x) {\n        return x.slice(1).toUpperCase();\n    })\n}\n')])])]),t("h3",{attrs:{id:"_31-查找字符串中出现最多的字符和个数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_31-查找字符串中出现最多的字符和个数"}},[e._v("#")]),e._v(" 31.查找字符串中出现最多的字符和个数")]),e._v(" "),t("ul",[t("li",[e._v("例: abbcccddddd -> 字符最多的是d，出现了5次")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let str = \"abcabcabcbbccccc\";\nlet num = 0;\nlet char = '';\n\n // 使其按照一定的次序排列\nstr = str.split('').sort().join('');\n// \"aaabbbbbcccccccc\"\n\n// 定义正则表达式\nlet re = /(\\w)\\1+/g;\nstr.replace(re,($0,$1) => {\n    if(num < $0.length){\n        num = $0.length;\n        char = $1;        \n    }\n});\nconsole.log(`字符最多的是${char}，出现了${num}次`);\n")])])]),t("h3",{attrs:{id:"_32-图片懒加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_32-图片懒加载"}},[e._v("#")]),e._v(" 32.图片懒加载")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\nconst imgLazyLoad = function() {\n    let count = 0\n    return (function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) => {\n            let rect = img.getBoundingClientRect()\n            if (rect.top < window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) => !deleteIndexList.includes(index))\n    })()\n}\n\n// 这里最好加上防抖处理\ndocument.addEventListener('scroll', imgLazyLoad)\n")])])]),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),t("ul",[t("li",[e._v("高频 JavaScript 手写")]),e._v(" "),t("li",[e._v("初、中级前端应该要掌握的手写代码实现")]),e._v(" "),t("li",[e._v("22 道高频 JavaScript 手写")]),e._v(" "),t("li",[e._v("死磕 36 个 JS 手写题（搞懂后，提升真的大）")])]),e._v(" "),t("blockquote",[t("p",[e._v("作者：xpsilvester")]),e._v(" "),t("p",[e._v("链接：https://juejin.cn/post/6963167124881670152")])]),e._v(" "),t("p",[e._v("- EOF -")]),e._v(" "),t("p",[e._v("推荐阅读 点击标题可跳转")]),e._v(" "),t("p",[e._v("1、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651578105&idx=2&sn=ace9b43370fea5359b9c6f8af587b8c1&chksm=80250938b752802e300740b2036c5f20f32c1ec50cf41b098528f50c7ebec7abb606e837ff68&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("Node.js 有难度的面试题，你能答对几个？"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("2、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651573707&idx=1&sn=2601b3e36c2476bfcfd842585764a15b&chksm=80251a0ab752931c485c432463632f94d0cc52fe3f9debea91fa25f57861159575a60d7ccff6&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("JS 语法 ES6、ES7、ES8、ES9、ES10、ES11、ES12新特性"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("3、"),t("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651577125&idx=1&sn=b2e0effb451cb7ae0faa256bf5abba1e&chksm=80250ce4b75285f2bfddf30f5a78679cbe18640b5a34c44c6c3e3519fd8d639738ad348f7181&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("原以为很简单，结果这道 Promise 面试题让我失眠好一会"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=r.exports}}]);