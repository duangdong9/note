(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{463:function(e,n,r){"use strict";r.r(n);var t=r(18),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"promise面试实战指北"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise面试实战指北"}},[e._v("#")]),e._v(" Promise面试实战指北")]),e._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/hz0P_brF8uCu2DDtW_vgVQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/hz0P_brF8uCu2DDtW_vgVQ"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"超时控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#超时控制"}},[e._v("#")]),e._v(" 超时控制")]),e._v(" "),r("h3",{attrs:{id:"背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" "),r("strong",[e._v("背景")])]),e._v(" "),r("ol",[r("li",[e._v("众所周知，fetch请求是无法设置超时时间的，因此我们需要自己去模拟一个超时控制。")]),e._v(" "),r("li",[e._v("转盘问题，一个抽奖转盘动画效果有5秒，但是一般来说向后端请求转盘结果只需要不到一秒，因此请求结果至少得等5秒才能展现给用户。")])]),e._v(" "),r("h3",{attrs:{id:"问题分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析"}},[e._v("#")]),e._v(" "),r("strong",[e._v("问题分析")])]),e._v(" "),r("p",[e._v("首先，超时控制比较简单，和Promise.race()的思想是类似，或者可以直接使用这个函数去解决。")]),e._v(" "),r("p",[e._v("然后，转盘问题如果要答好，需要考虑两种情况。")]),e._v(" "),r("ol",[r("li",[e._v("转盘动画还未完成，请求结果已经拿到了，此时要等到动画完成再展示结果给用户。")]),e._v(" "),r("li",[e._v("转盘动画完成了，请求结果还未拿到，此时需要等待结果返回（可以设置请求超时时间）。")])]),e._v(" "),r("p",[e._v("所以，转盘问题更适合用Promise.all()来解决。")]),e._v(" "),r("h3",{attrs:{id:"实战版源码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实战版源码"}},[e._v("#")]),e._v(" "),r("strong",[e._v("实战版源码")])]),e._v(" "),r("p",[e._v("代码分为多个版本，从上自下，记忆难度递增但面试成绩更优，请按需选择。")]),e._v(" "),r("p",[e._v("一、基于"),r("code",[e._v("Promise.race()")]),e._v("的超时控制。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 超时控制版本一\n */\n\n/**\n * 辅助函数，封装一个延时promise\n * @param {number} delay 延迟时间\n * @returns {Promise<any>}\n */\nfunction sleep(delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => reject(new Error("timeout")), delay);\n  });\n}\n\n/**\n * 将原promise包装成一个带超时控制的promise\n * @param {()=>Promise<any>} requestFn 请求函数\n * @param {number} timeout 最大超时时间\n * @returns {Promise<any>}\n */\nfunction timeoutPromise(requestFn, timeout) {\n  return Promise.race([requestFn(), sleep(timeout)]);\n}\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    });\n}\n\n// 超时的例子\ntimeoutPromise(createRequest(2000), 1000).catch((error) =>\n  console.error(error)\n);\n// 不超时的例子\ntimeoutPromise(createRequest(2000), 3000).then((res) => console.log(res));\n\n复制代码\n')])])]),r("p",[e._v("二、将"),r("code",[e._v("promise.race()")]),e._v("干掉。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 超时控制版本二\n */\n\n/**\n * 辅助函数，封装一个延时promise\n * @param {number} delay 延迟时间\n * @returns {Promise<any>}\n */\nfunction sleep(delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => reject(new Error("timeout")), delay);\n  });\n}\n\n/**\n * 将原promise包装成一个带超时控制的promise\n * @param {()=>Promise<any>} requestFn 请求函数\n * @param {number} timeout 最大超时时间\n * @returns {Promise<any>}\n */\nfunction timeoutPromise(requestFn, timeout) {\n  const promises = [requestFn(), sleep(timeout)];\n  return new Promise((resolve, reject) => {\n    for (const p of promises) {\n      p.then((res) => resolve(res)).catch((error) => reject(error));\n    }\n  });\n}\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    });\n}\n\n// 超时的例子\ntimeoutPromise(createRequest(2000), 1000).catch((error) =>\n  console.error(error)\n);\n// 不超时的例子\ntimeoutPromise(createRequest(2000), 3000).then((res) => console.log(res));\n\n复制代码\n')])])]),r("p",[e._v("三、基于"),r("code",[e._v("Promise.all()")]),e._v("的转盘问题（不考虑请求超时），和上面略有不同的是"),r("code",[e._v("sleep")]),e._v("函数超时后"),r("code",[e._v("Promise")]),e._v("从"),r("code",[e._v("pending")]),e._v("态转到"),r("code",[e._v("fulfilled")]),e._v("态而不是"),r("code",[e._v("rejected")]),e._v("态。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 转盘问题不考虑超时\n */\n\n/**\n * 辅助函数，封装一个延时promise\n * @param {number} delay 延迟时间\n * @returns {Promise<any>}\n */\nfunction sleep(delay) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(delay), delay);\n  });\n}\n\n/**\n * 将原promise包装成一个转盘promise\n * @param {()=>Promise<any>} requestFn 请求函数\n * @param {number} animationDuration 动画持续时间\n * @returns {Promise<any>}\n */\nfunction turntablePromise(requestFn, animationDuration) {\n  return Promise.all([requestFn(), sleep(animationDuration)]);\n}\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    });\n}\n\n// 请求比转盘动画快\nturntablePromise(createRequest(2000), 5000).then((res) => console.log(res));\n\n// 请求比转盘动画慢\nturntablePromise(createRequest(2000), 1000).then((res) => console.error(res));\n\n复制代码\n')])])]),r("p",[e._v("四：基于"),r("code",[e._v("Promise.all()")]),e._v("的转盘问题（考虑请求超时），无非就是拼刀刀没什么亮点。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 转盘问题考虑超时\n */\n\n/**\n * 将原promise包装成一个带超时控制的promise\n * @param {Promise<any>} request 你的请求\n * @param {number} timeout 最大超时时间\n * @returns {Promise<any>}\n */\nfunction timeoutPromise(request, timeout) {\n  function sleep(delay) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => reject(new Error("timeout")), delay);\n    });\n  }\n  const promises = [request, sleep(timeout)];\n  return new Promise((resolve, reject) => {\n    for (const p of promises) {\n      p.then((res) => resolve(res)).catch((error) => reject(error));\n    }\n  });\n}\n\n/**\n * 将原promise包装成一个转盘promise\n * @param {()=>Promise<any>} requestFn 请求函数\n * @param {number} timeout 超时时间\n * @param {number} animationDuration 动画持续时间\n * @returns {Promise<any>}\n */\nfunction turntablePromise(requestFn, timeout, animationDuration) {\n  function sleep(delay) {\n    return new Promise((resolve) => {\n      setTimeout(() => resolve(delay), delay);\n    });\n  }\n  return Promise.all([timeoutPromise(requestFn(), timeout), sleep(animationDuration)]);\n}\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    });\n}\n\n// 请求比转盘动画慢且超时\nturntablePromise(createRequest(2000), 1500, 1000).catch((error) =>\n  console.error(error)\n);\n\n复制代码\n')])])]),r("p",[e._v("五：干掉"),r("code",[e._v("Promise.all()")]),e._v("，这版代码没有加什么核心的东西，无非就是手写一下这个api，所以留给大家自测。")]),e._v(" "),r("h2",{attrs:{id:"取消重复请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#取消重复请求"}},[e._v("#")]),e._v(" 取消重复请求")]),e._v(" "),r("h3",{attrs:{id:"背景-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景-2"}},[e._v("#")]),e._v(" "),r("strong",[e._v("背景")])]),e._v(" "),r("p",[e._v("当用户频繁点击一个搜索Button时，会在短时间内发出大量的搜索请求，给服务器造成一定的压力，同时也会因请求响应的先后次序不同而导致渲染的数据与预期不符。这里，我们可以使用防抖来减小服务器压力，但是却没法很好地解决后面的问题。")]),e._v(" "),r("h3",{attrs:{id:"问题分析-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析-2"}},[e._v("#")]),e._v(" "),r("strong",[e._v("问题分析")])]),e._v(" "),r("p",[e._v("这个问题的本质在于，同一类请求是有序发出的（根据按钮点击的次序），但是响应顺序却是无法预测的，我们通常只希望渲染最后一次发出请求响应的数据，而其他数据则丢弃。因此，我们需要丢弃（或不处理）除最后一次请求外的其他请求的响应数据。")]),e._v(" "),r("h3",{attrs:{id:"实战版源码-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实战版源码-2"}},[e._v("#")]),e._v(" "),r("strong",[e._v("实战版源码")])]),e._v(" "),r("p",[e._v("其实axios已经有了很好的实践，大家可以配合阿宝哥的文章来食用。此处取消"),r("code",[e._v("promise")]),e._v("的实现借助了上一章节的技巧，而在"),r("code",[e._v("axios")]),e._v("中因为所有异步都是由xhr发出的，所以"),r("code",[e._v("axios")]),e._v("的实现中还借助了xhr.abort()来取消一个请求。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 取消请求\n */\n\nfunction CancelablePromise() {\n  this.pendingPromise = null;\n}\n\n// 包装一个请求并取消重复请求\nCancelablePromise.prototype.request = function (requestFn) {\n  if (this.pendingPromise) {\n    this.cancel("取消重复请求");\n  }\n  const _promise = new Promise((resolve, reject) => (this.reject = reject));\n  this.pendingPromise = Promise.race([requestFn(), _promise]);\n  return this.pendingPromise;\n};\n\n// 取消当前请求\nCancelablePromise.prototype.cancel = function (reason) {\n  this.reject(new Error(reason));\n  this.pendingPromise = null;\n};\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    });\n}\n\n\nconst cancelPromise = new CancelablePromise();\n\n// 前四个请求将被自动取消\nfor (let i = 0; i < 5; i++) {\n  cancelPromise\n    .request(createRequest(1000))\n    .then((res) => console.log(res)) // 最后一个 done\n    .catch((err) => console.error(err)); // 前四个 error: 取消重复请求\n}\n\n// 设置一个定时器等3s，让前面的请求都处理完再继续测试\nsetTimeout(() => {\n  // 手动取消最后一个请求\n  cancelPromise\n    .request(createRequest(1000))\n    .then((res) => console.log(res))\n    .catch((err) => console.error(err)); // error:手动取消\n  cancelPromise.cancel("手动取消");\n}, 3000);\n\n// 设置一个定时器等4s，让前面的请求都处理完再继续测试\nsetTimeout(() => {\n  cancelPromise\n    .request(createRequest(1000))\n    .then((res) => console.log(res)) // done\n    .catch((err) => console.error(err));\n}, 4000);\n\n复制代码\n')])])]),r("h2",{attrs:{id:"限制并发请求数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限制并发请求数"}},[e._v("#")]),e._v(" 限制并发请求数")]),e._v(" "),r("h3",{attrs:{id:"背景-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景-3"}},[e._v("#")]),e._v(" "),r("strong",[e._v("背景")])]),e._v(" "),r("p",[e._v("一般来说，我们不会刻意去控制请求的并发。只有在一些场景下可能会用到，比如，收集用户的批量操作（每个操作对应一次请求），待用户操作完成后一次性发出。另外，为了减小服务器的压力，我们还会"),r("strong",[e._v("限制并发数")]),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"问题分析-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析-3"}},[e._v("#")]),e._v(" "),r("strong",[e._v("问题分析")])]),e._v(" "),r("p",[e._v("看上去，Promise.allSettled很适合应对这样的场景，但是稍微想一下就能发现，它能控制的粒度还是太粗了。首先，它必须等待所有"),r("code",[e._v("Promise")]),e._v("都"),r("code",[e._v("resolve")]),e._v("或"),r("code",[e._v("reject")]),e._v("，其次，如果有并发限制的话用它来做还需要分批请求，实际效率也会比较低，短木板效应很明显。")]),e._v(" "),r("h3",{attrs:{id:"实战版源码-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实战版源码-3"}},[e._v("#")]),e._v(" "),r("strong",[e._v("实战版源码")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 限制并发请求数\n */\n\n/**\n * 并发请求限制并发数\n * @param {()=>Promise<any> []} requestFns 并发请求函数数组\n * @param {numer} limit 限制最大并发数\n */\nfunction concurrentRequest(requestFns, limit) {\n  // 递归函数\n  function recursion(requestFn) {\n    requestFn().finally(() => {\n      if (_requestFns.length > 0) {\n        recursion(_requestFns.pop());\n      }\n    });\n  }\n  const _requestFns = [...requestFns];\n  // 限制最大并发量\n  for (let i = 0; i < limit && _requestFns.length > 0; i++) {\n    recursion(_requestFns.pop());\n  }\n}\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    }).then((res) => {\n      console.log(res);\n    });\n}\n\nconst requestFns = [];\nfor (let i = 0; i < 10; i++) {\n  requestFns.push(createRequest(1000));\n}\n\nconcurrentRequest(requestFns, 3);\n\n复制代码\n')])])]),r("h2",{attrs:{id:"管理全局loading态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#管理全局loading态"}},[e._v("#")]),e._v(" 管理全局loading态")]),e._v(" "),r("h3",{attrs:{id:"背景-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景-4"}},[e._v("#")]),e._v(" "),r("strong",[e._v("背景")])]),e._v(" "),r("p",[e._v("当我们一个页面或组件涉及到多个请求时，可能会对应多个loading态的管理。在某些场景下，我们只希望用一个loading态去管理所有异步请求，当任一存在pending态的请求时，展示全局loading组件，当所有请求都fulfilled或rejected时，隐藏全局loading组件。")]),e._v(" "),r("h3",{attrs:{id:"问题分析-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析-4"}},[e._v("#")]),e._v(" "),r("strong",[e._v("问题分析")])]),e._v(" "),r("p",[e._v("这个问题的关键就是在于我们需要管理所有pending态的请求，并适时更新loading态。")]),e._v(" "),r("h3",{attrs:{id:"实战版源码-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实战版源码-4"}},[e._v("#")]),e._v(" "),r("strong",[e._v("实战版源码")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('/**\n * 管理全局loading态\n */\n\nfunction PromiseManager() {\n  this.pendingPromise = new Set();\n  this.loading = false;\n}\n\n// 给每个pending态的promise生成一个身份标志\nPromiseManager.prototype.generateKey = function () {\n  return `${new Date().getTime()}-${parseInt(Math.random() * 1000)}`;\n};\n\nPromiseManager.prototype.push = function (...requestFns) {\n  for (const requestFn of requestFns) {\n    const key = this.generateKey();\n    this.pendingPromise.add(key);\n    requestFn().finally(() => {\n      this.pendingPromise.delete(key);\n      this.loading = this.pendingPromise.size !== 0;\n    });\n  }\n};\n\n// ----------下面是测试用例------------\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve("done");\n      }, delay);\n    }).then((res) => console.log(res));\n}\n\nconst manager = new PromiseManager();\n\n// 增加多个请求\nmanager.push(createRequest(1000), createRequest(2000), createRequest(3000));\nmanager.push(createRequest(1500));\n\n// 每秒轮询loading态，直到loading为false\nconst id = setInterval(() => {\n  console.log(manager.loading);\n  if (!manager.loading) clearInterval(id);\n}, 1000);\n\n// 增加多个请求\nmanager.push(createRequest(2500));\n复制代码\n')])])]),r("h2",{attrs:{id:"加餐"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#加餐"}},[e._v("#")]),e._v(" 加餐")]),e._v(" "),r("h3",{attrs:{id:"串行化的三种实现方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#串行化的三种实现方式"}},[e._v("#")]),e._v(" "),r("strong",[e._v("串行化的三种实现方式")])]),e._v(" "),r("p",[e._v("使用串行化的常见场景，请求之间有依赖关系或时序关系，如红绿灯。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/**\n * 串行化的三种实现\n **/\n\n// 法一，递归法\nfunction runPromiseInSeq1(requestFns) {\n  function recursion(requestFns) {\n    if (requestFns.length === 0) return;\n    requestFns\n      .shift()()\n      .finally(() => recursion(requestFns));\n  }\n  const _requestFns = [...requestFns];\n  recursion(_requestFns);\n}\n// 法二：迭代法\nasync function runPromiseInSeq2(requestFns) {\n  for (const requestFn of requestFns) {\n    await requestFn();\n  }\n}\n// 法三：reduce\nfunction runPromiseInSeq3(requestFns) {\n  requestFns.reduce((pre, cur) => pre.finally(() => cur()), Promise.resolve());\n}\n\n// 模拟一个异步请求函数\nfunction createRequest(delay) {\n  return () =>\n    new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(delay);\n      }, delay);\n    }).then((res) => {\n      console.log(res);\n    });\n}\n// 执行顺序从左至右\nconst requestFns = [\n  createRequest(3000),\n  createRequest(2000),\n  createRequest(1000),\n];\n// 串行调用\nrunPromiseInSeq1(requestFns);\n// runPromiseInSeq2(requestFns);\n// runPromiseInSeq3(requestFns);\n\n复制代码\n")])])]),r("h3",{attrs:{id:"_20行最简异步链式调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_20行最简异步链式调用"}},[e._v("#")]),e._v(" "),r("strong",[e._v("20行最简异步链式调用")])]),e._v(" "),r("p",[e._v("这里模拟了Promise的异步链式调用，代码出处见文章。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function Promise(fn) {\n  this.cbs = [];\n\n  const resolve = (value) => {\n    setTimeout(() => {\n      this.data = value;\n      this.cbs.forEach((cb) => cb(value));\n    });\n  }\n\n  fn(resolve);\n}\n\nPromise.prototype.then = function (onResolved) {\n  return new Promise((resolve) => {\n    this.cbs.push(() => {\n      const res = onResolved(this.data);\n      if (res instanceof Promise) {\n        res.then(resolve);\n      } else {\n        resolve(res);\n      }\n    });\n  });\n};\n")])])]),r("h2",{attrs:{id:"写在后面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#写在后面"}},[e._v("#")]),e._v(" 写在后面")]),e._v(" "),r("p",[e._v("这位笔名"),r("code",[e._v("鼠子")]),e._v("，是22届的学弟。想要找他交流的话，可以加我微信，我拉你进群，他长期在群里。")]),e._v(" "),r("p",[r("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("个人微信")]),e._v(" "),r("p",[e._v("往期推荐")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MDY1MjIxMA==&mid=2247497006&idx=2&sn=bcd167d3f9ec511e863b18808d31e75e&chksm=cfdbe673f8ac6f650c65b9f9306aa0fe95fd0322e58b23cd023d5eaebefb095ee36b1c42ea48&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("TypeScript 4.4beat版本发布"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MDY1MjIxMA==&mid=2247496983&idx=1&sn=0f6d70881803b6f97a501915e318501d&chksm=cfdbe64af8ac6f5cd04f60f3291676e3165c7b4da4187dee695d492ba64ffca05b177db1fbd0&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("进腾讯了"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=Mzg5MDY1MjIxMA==&mid=2247497139&idx=1&sn=c9e5ca74d903aeccd0862bb3aa44e40f&chksm=cfdbe6eef8ac6ff8d86547accd41d2fe4bc36ff486baab04695ff86d861f23c418aae85c818c&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("张一鸣先生的四年收获与工作感悟"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("收录于话题 #前端面试")]),e._v(" "),r("p",[e._v("14个")]),e._v(" "),r("p",[e._v("下一篇21 道关于性能优化的面试题（附答案）")])])}),[],!1,null,null,null);n.default=s.exports}}]);