(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{466:function(e,r,s){"use strict";s.r(r);var n=s(18),t=Object(n.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"两天时间-实现自己的-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两天时间-实现自己的-promise"}},[e._v("#")]),e._v(" 两天时间，实现自己的 Promise")]),e._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/-2vIKWRPzdXCZlPupw4XcA",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/-2vIKWRPzdXCZlPupw4XcA"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"_01-目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01-目录"}},[e._v("#")]),e._v(" 01. 目录")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("02.自下而上")]),e._v("[1]")]),e._v(" "),s("li",[s("strong",[e._v("03.如何实现")]),e._v("[2]")]),e._v(" "),s("li",[s("strong",[e._v("04.Promise/A+规范")]),e._v("[3]")]),e._v(" "),s("li",[s("strong",[e._v("05.更多优化")]),e._v("[4]")]),e._v(" "),s("li",[s("strong",[e._v("06.源码")]),e._v("[5]")]),e._v(" "),s("li",[s("strong",[e._v("07.小结")]),e._v("[6]")]),e._v(" "),s("li",[s("strong",[e._v("08.其他参考")]),e._v("[7]")])]),e._v(" "),s("h2",{attrs:{id:"_02-自下而上"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_02-自下而上"}},[e._v("#")]),e._v(" 02.自下而上")]),e._v(" "),s("h3",{attrs:{id:"_02-01-基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_02-01-基本概念"}},[e._v("#")]),e._v(" 02.01 基本概念")]),e._v(" "),s("ul",[s("li",[e._v("首先我们来整理一些 "),s("code",[e._v("Promise")]),e._v(" 基本的概念，包括私有状态，内部方法，静态方法等等。")])]),e._v(" "),s("h4",{attrs:{id:"私有属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#私有属性"}},[e._v("#")]),e._v(" 私有属性")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("私有属性包括状态和值 "),s("code",[e._v("PromisState")]),e._v(" "),s("code",[e._v("PromiseResult")]),e._v("，这些属性外部无法访问。")])]),e._v(" "),s("li",[s("p",[e._v("状态属性有以下三种：")])]),e._v(" "),s("li",[s("ul",[s("li",[s("code",[e._v("pending")]),e._v(" 初始化状态")]),e._v(" "),s("li",[s("code",[e._v("fulfilled")]),e._v(" 兑现(完成)")]),e._v(" "),s("li",[s("code",[e._v("rejected")]),e._v(" 拒绝")])])]),e._v(" "),s("li",[s("p",[e._v("值属性，由 "),s("code",[e._v("resolve")]),e._v(" 或 "),s("code",[e._v("reject")]),e._v(" 处理来决定。")])])]),e._v(" "),s("h4",{attrs:{id:"实例方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例方法"}},[e._v("#")]),e._v(" 实例方法")]),e._v(" "),s("ul",[s("li",[s("strong",[s("code",[e._v("then")])]),e._v("[8]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("catch")])]),e._v("[9]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("finally")])]),e._v("[10]")])]),e._v(" "),s("h4",{attrs:{id:"静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[e._v("#")]),e._v(" 静态方法")]),e._v(" "),s("ul",[s("li",[s("strong",[s("code",[e._v("Promise.reject")])]),e._v("[11]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("Promise.resolve")])]),e._v("[12]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("Promise.race")])]),e._v("[13]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("Promise.all")])]),e._v("[14]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("Promise.allSettled")])]),e._v("[15]")]),e._v(" "),s("li",[s("strong",[s("code",[e._v("Promise.any")])]),e._v("[16]")])]),e._v(" "),s("h2",{attrs:{id:"_03-如何实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-如何实现"}},[e._v("#")]),e._v(" 03.如何实现")]),e._v(" "),s("h3",{attrs:{id:"_03-01-基础类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-01-基础类"}},[e._v("#")]),e._v(" 03.01 基础类")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("在罗列所有的状态和方法之后，我们首先来实现一个最基础的 "),s("code",[e._v("Promise")]),e._v(" 类。")])]),e._v(" "),s("li",[s("p",[e._v("最基础的类，包括以下核心几点：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * Promise 内部状态的枚举\n */\nenum PROMISE_STATES {\n  PENDING = 'pending',\n  FULFILLED = 'fulfilled',\n  REJECTED = 'rejected'\n}\n\ntype PromiseStates = PROMISE_STATES.PENDING | PROMISE_STATES.FULFILLED | PROMISE_STATES.REJECTED;\n\nexport const isFunction = (fn: any):boolean => typeof fn === 'function';\nexport const isObject = (obj: any):boolean => typeof obj === 'object';\n\nclass PromiseLike {\n  protected PromiseState: PromiseStates;\n  protected PromiseResult: any;\n\nconstructor(executor) {\n  this.PromiseState = PROMISE_STATES.PENDING;\n  this.PromiseResult = undefined;\n\n  executor(this._resolve, this._reject)\n}\n\n_resolve = (value?: any) => {\n  if (this.PromiseState !== PROMISE_STATES.PENDING) {\n    return;\n  }\n  this.PromiseState = PROMISE_STATES.FULFILLED;\n  this.PromiseResult = value;\n}\n\n_reject = (value?: any) => {\n  if (this.PromiseState !== PROMISE_STATES.PENDING) {\n    return;\n  }\n  this.PromiseState = PROMISE_STATES.REJECTED;\n  this.PromiseResult = value;\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("拥有私有状态，也有着能够改变私有状态的私有方法。")]),e._v(" "),s("li",[e._v("同时接收一个执行器函数作为参数，执行器函数内部则是预先定义好的私有方法。")]),e._v(" "),s("li",[e._v("私有状态一旦改变（兑现或拒绝）后不可逆。")])])])]),e._v(" "),s("h4",{attrs:{id:"resolve-和-reject"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resolve-和-reject"}},[e._v("#")]),e._v(" resolve 和 reject")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("上述代码比较好理解， 我们定义了状态，定义了执行器函数以及相关的两个参数，这两个参数对应的方法分别修改了对应的状态。")])]),e._v(" "),s("li",[s("p",[e._v("但是差点忘了， "),s("code",[e._v("Promise")]),e._v(" 是异步的，意味着这两个函数处理也应当是异步的；这里可以使用 "),s("code",[e._v("setTimeout")]),e._v(" 来模拟异步进程。这部分还可以优化，后面我们会提到。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n  * 使状态变更为 fulfilled\n  * 调用注册的事件，注意调用后进行清除\n  * @param value\n  * @returns\n  */\n_resolve = (value?: any) => {\n  const resolveCb = () => {\n    if (this.PromiseState !== PROMISE_STATES.PENDING) {\n      return;\n    }\n\n    this.PromiseState = FULFILLED;\n    this.PromiseResult = value;\n  }\n\n  // 使任务变成异步的\n  setTimeout(resolveCb, 0);\n}\n\n/**\n * 使状态变更为 rejected\n  * @param value\n  */\n_reject = (value?: any) => {\n  const rejectCb = () => {\n    if (this.PromiseState !== PROMISE_STATES.PENDING) {\n      return;\n    }\n\n    this.PromiseState = REJECTED;\n    this.PromiseResult = value;\n  }\n\n  setTimeout(rejectCb, 0);\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("我们可以接着实现相关的静态方法，因为它们所做的事很简单，就是修改当前的内部状态，于是完全可以直接调用当前类实例化来处理。")])]),e._v(" "),s("li",[s("p",[e._v("重复代码不再罗列，下面是新增的静态方法：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n// ...sth\nstatic resolve(value?: any) {\n  return new PromiseLike((resolve) => resolve(value));\n}\n\nstatic reject(value?: any) {\n  return new PromiseLike((resolve, reject) => reject(value));\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("一个简单的基础类就这样完成了。不过先不要着急，当前的实现显然有许多要完善的地方，甚至也许有错误，让我们进一步来梳理。")])])]),e._v(" "),s("h3",{attrs:{id:"_03-02-原型方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-02-原型方法"}},[e._v("#")]),e._v(" 03.02 原型方法")]),e._v(" "),s("h4",{attrs:{id:"promise-prototype-then"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-then"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.prototype.then")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("相信对 "),s("code",[e._v("Promise")]),e._v(" 有所了解的都知道 "),s("code",[e._v("Promise")]),e._v(" 的 "),s("code",[e._v("then")]),e._v(" 方法以及它的链式调用。本质上，**它是对 "),s("code",[e._v("Thenable")]),e._v(" 接口的具体实现。**这句话很重要，后面会用到。")])]),e._v(" "),s("li",[s("p",[e._v("让我们先来回顾一下 "),s("code",[e._v("then")]),e._v(" 的用法：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.resolve(29).then(function fulfilled(res) {\nconsole.info(res);\nreturn res;\n}, function rejected(err) {\nconsole.error(err);\n});\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[s("code",[e._v("then")]),e._v(" 方法接收两个参数，分别用来处理 "),s("code",[e._v("resolve")]),e._v(" 和 "),s("code",[e._v("reject")]),e._v(" 的结果，称之为完成回调和拒绝回调。默认情况下，同时注册这两个回调方法，一次只可能会调用到其中一个。即使在前一个函数中抛出了异常，第二个异常捕获函数也无法立即捕获。")])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("完成回调，接收先前 "),s("code",[e._v("promise")]),e._v(" 的 "),s("code",[e._v("resolve")]),e._v(" 值作为默认参数，处理对应数据，并返回一个值，作为下一个 "),s("code",[e._v("then")]),e._v(" 内部函数调用的默认参数。")]),e._v(" "),s("li",[e._v("让我们再仔细想想， "),s("code",[e._v("then")]),e._v(" 注册事件的调用次数是否和注册次数相同？是的。假如使用 "),s("code",[e._v("then")]),e._v(" 注册了多个回调函数，则它们会依次执行。这意味着我们得在原先的基础上加上相应的事件队列。")]),e._v(" "),s("li",[e._v("另外别忘了， "),s("code",[e._v("then")]),e._v(" 方法支持"),s("strong",[e._v("链式调用")]),e._v("，我们这里先使用 "),s("code",[e._v("return this")]),e._v(" 的方式来简单实现。")])])]),e._v(" "),s("li",[s("p",[e._v("现在我们对上面的基础类进行改进和修复。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export interface ICallbackFn {\n(value?: any): any;\n}\n\ntype CallbackParams = ICallbackFn | null;\n\nexport interface IExecutorFn {\n(resolve: ICallbackFn,  reject: ICallbackFn): any;\n}\n\nclass PromiseLike {\nprotected PromiseState: PromiseStates;\nprotected PromiseResult: any;\n\nresolveCallbackQueues: Array<ICallbackFn>;\nrejectCallbackQueues: Array<ICallbackFn>;\n\nconstructor(executor: IExecutorFn) {\n  if (!isFunction(executor)) {\n    throw new Error('Promise resolver undefined is not a function');\n  }\n  this.PromiseState = PENDING;\n  this.PromiseResult = undefined;\n\n  // 分别用于两个注册事件保存的数组\n  this.resolveCallbackQueues = [];\n  this.rejectCallbackQueues = [];\n\n  executor(this._resolve, this._reject);\n}\n\n/**\n * 使状态变更为 fulfilled\n* 调用注册的事件，注意调用后进行清除\n* @param value\n* @returns\n*/\n_resolve = (value: any) => {\n  const resolveCb = () => {\n    if (this.PromiseState !== PROMISE_STATES.PENDING) {\n      return;\n    }\n    while (this.resolveCallbackQueues.length) {\n      const fn = this.resolveCallbackQueues.shift();\n      fn && fn(value);\n    }\n    this.PromiseState = FULFILLED;\n    this.PromiseResult = value;\n  }\n\n  // 使任务变成异步的\n  setTimeout(resolveCb, 0);\n}\n\n/**\n * 使状态变更为 rejected\n* @param value\n*/\n_reject = (value: any) => {\n  const rejectCb = () => {\n    if (this.PromiseState !== PROMISE_STATES.PENDING) {\n      return;\n    }\n    while (this.rejectCallbackQueues.length) {\n      const fn = this.rejectCallbackQueues.shift();\n      fn && fn(value);\n    }\n    this.PromiseState = REJECTED;\n    this.PromiseResult = value;\n  }\n\n  setTimeout(rejectCb, 0);\n}\n\n/**\n * 根据当前不同状态来执行对应逻辑\n* 如果在默认状态就是注册对应事件\n* 如果状态变化则是执行对应事件\n* @param onFulfilled\n* @param onRejected\n* @returns\n*/\nthen = (onFulfilled, onRejected) => {\n  switch (this.PromiseState) {\n    case PENDING:\n      isFunction(onFulfilled) && this.resolveCallbackQueues.push(onFulfilled);\n      isFunction(onRejected) && this.rejectCallbackQueues.push(onRejected);\n    case FULFILLED:\n      isFunction(onFulfilled) && onFulfilled(this.PromiseResult);\n      break;\n    case REJECTED:\n      isFunction(onRejected) && onRejected(this.PromiseResult);\n      break;\n  }\n  return this;\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("定义两个数组，分别用来保存完成回调和拒绝回调。")]),e._v(" "),s("li",[e._v("下面罗列核心代码：")])])]),e._v(" "),s("li",[s("p",[e._v("我们丰富了 "),s("code",[e._v("then")]),e._v(" 方法。但是你我都知道，"),s("code",[e._v("return this")]),e._v(" 看起来并不太可靠。")])]),e._v(" "),s("li",[s("p",[e._v("让我们来回顾一点，"),s("strong",[s("code",[e._v("Promise")]),e._v(" 的私有状态一旦改变后不可逆")]),e._v("。如果在这个 "),s("code",[e._v("then")]),e._v(" 方法里抛出异常， "),s("code",[e._v("promise")]),e._v(" 显然会变成拒绝状态，而同一实例的状态在改变后是不能够再次修改的。所以， "),s("code",[e._v("then")]),e._v(" 的链式调用本质上是每次都会生成一个新的实例。")])]),e._v(" "),s("li",[s("p",[e._v("也许再贴一个使用 "),s("code",[e._v("then")]),e._v(" 的例子会让我们有一些启发。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const p = Promise.resolve(123);\nconst p1 = p.then();\nconst p2 = p1.then((val) => val + 123))\nconst p3 = p2.then(console.info));\nconst p4 = p3.then(() => {\nthrow new Error('Oops!');\n});\n// 分别打印 p1 p2 p3 p4\n// Promise {<fulfilled>: 123}\n// Promise {<fulfilled>: 246}\n// Promise {<fulfilled>: undefined}\n// Promise {<rejected>: Error: Oops!\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("这段代码的输出，有助于让我们进一步理解 "),s("code",[e._v("then")]),e._v(" 内部所做的事。")])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("p1: 在没有传入回调函数的时候，它仅仅是将值传递，也就是内部会初始化一个默认的处理函数，这个处理函数只会乖乖地传递值。")]),e._v(" "),s("li",[e._v("p2: 存在完成回调时，可以获取值并进行处理，这个新的值通过"),s("strong",[e._v("返回的形式")]),e._v("继续往后传递。")]),e._v(" "),s("li",[e._v("p3: 如果传入完成回调函数，但没有显式返回值，则最终的 "),s("code",[e._v("promise")]),e._v(" 的值是 "),s("code",[e._v("undefined")]),e._v(".")]),e._v(" "),s("li",[e._v("p4: "),s("code",[e._v("promise")]),e._v(" 状态已经变更成 "),s("code",[e._v("rejected")]),e._v(", 意味着是新的 "),s("code",[e._v("promise")]),e._v(". 符合我们的预期。")])])]),e._v(" "),s("li",[s("p",[e._v("带着上述理解，我们来改进 "),s("code",[e._v("then")]),e._v(" 方法。")])]),e._v(" "),s("li",[s("p",[e._v("首先，需要处理参数异常的情况，也就是传入参数不是函数，或者未传的情况，就给定默认处理函数。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("then = (onFulfilled?: CallbackParams, onRejected?: CallbackParams) => {\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("完成回调负责传递参数。")]),e._v(" "),s("li",[e._v("拒绝回调负责抛出异常。")])])])]),e._v(" "),s("p",[e._v("// 默认处理！！！onFulfilled = isFunction(onFulfilled) ? onFulfilled : value => value; onRejected = isFunction(onRejected) ? onRejected : err => { throw err }; } 复制代码")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("- 我们把这两个兼容处理放在函数内的顶部，这样有助于理解，也可以简化后续的逻辑。\n\n- 下面是具体的内容，其中核心改动已注释说明。\n\n```ts\nclass PromiseLike {\n/**\n * 根据当前不同状态来执行对应逻辑\n* 如果在默认状态就是注册对应事件\n* 如果状态变化则是执行对应事件\n* @param onFulfilled\n* @param onRejected\n* @returns\n*/\nthen = (onFulfilled: CallbackParams, onRejected: CallbackParams) => {\n  // 默认处理！！！\n  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value => value;\n  onRejected = isFunction(onRejected) ? onRejected : err => { throw err };\n  return new PromiseLike((resolve, reject) => {\n    /**\n     * 封装完成回调函数\n    * @param val\n    */\n    const handleFulfilled = (val: any) => {\n      try {\n        const res = onFulfilled(val);\n        resolve(res);\n      } catch (error) {\n        // 如果当前执行逻辑内发生异常，则抛出异常\n        reject(error);\n      }\n    };\n\n    /**\n     * 封装错误回调函数\n    * @param val\n    */\n    const handleRejected = (val: any) => {\n      try {\n        const res = onRejected(val);\n        reject(res);\n      } catch (error) {\n        reject(error);\n      }\n    }\n\n    switch (this.PromiseState) {\n      case PROMISE_STATES.PENDING:\n        this.resolveCallbackQueues.push(handleFulfilled);\n        this.rejectCallbackQueues.push(handleRejected);\n        break;\n      case PROMISE_STATES.FULFILLED:\n        handleFulfilled(this.PromiseResult);\n        break;\n      case PROMISE_STATES.REJECTED:\n        handleRejected(this.PromiseResult);\n        break;\n    }\n  });\n}\n}\n复制代码\n")])])]),s("ul",[s("li",[s("p",[e._v("这个 "),s("code",[e._v("then")]),e._v(" 方法的处理已经接近完善，不过在 "),s("code",[e._v("Promise")]),e._v(" 里有一点容易被人遗忘。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.resolve(41) === Promise.resolve(Promise.resolve(41)); // false\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("在 "),s("code",[e._v("Promise")]),e._v(" 中处理 "),s("code",[e._v("Promise")]),e._v("，内部处理会将其展开来获取其中的值。")]),e._v(" "),s("li",[e._v("下面这个例子出来你就理解了。")])])]),e._v(" "),s("li",[s("p",[e._v("不好意思，走错片场。js 中每个单独定义的引用类型都是不相等的。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const p = Promise.resolve(41);\nPromise.resolve(p) === p; // true\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("再来一次。")])])]),e._v(" "),s("li",[s("p",[e._v("没错，如果我们给 "),s("code",[e._v("promise")]),e._v(" 一个 "),s("code",[e._v("promise")]),e._v(" 值，内部机制会将其展开。这个过程是递归的，这里我们先不展开探讨，但记住有这样的场景需要处理。")])]),e._v(" "),s("li",[s("p",[e._v("可以先定义一个静态方法判断是否是 "),s("code",[e._v("Promise")]),e._v(" 实例，方便后续的判断。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * 判断是否是当前类的实例\n* @param promise\n* @returns\n*/\nstatic is(promise: PromiseType) {\n  return promise instanceof PromiseLike;\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("有了这个方法，我们可以进一步完善上面的 "),s("code",[e._v("then")]),e._v(" 方法。注意观察其中的变化，有注释说明。")])]),e._v(" "),s("li",[s("p",[e._v("为方便阅读，只展示核心方法（只有这里改动）。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("p",[e._v("封装完成回调函数")])]),e._v(" "),s("li",[s("p",[e._v("@param val */ const handleFulfilled = (val) => { try { const res = onFulfilled(val); if (PromiseLike.is(res)) { // 如果参数是 Promise 实例，直接可以把 promise 实例进行传递 res.then(resolve, reject); } else  { resolve(res); } } catch (error) { // 如果当前执行逻辑内发生异常，则抛出异常 reject(error); } }; 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#### `Promise.prototype.catch`\n\n- 在实现 `then` 方法之后，其实 `catch` 的实现是你想象不到的简单。\n\n- 因为本质上 `catch` 方法是 `then` 第二个参数也就是错误回调函数的语法糖。照着这个理解，实现起来就比较容易。\n\n```ts\nclass PromiseLike {\n/**\n * 错误处理\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\n* @param rejectedCb\n* @returns\n*/\ncatch = (rejectedCb: CallbackParams) => {\n  return this.then(null, rejectedCb);\n}\n}\n复制代码\n")])])]),s("h4",{attrs:{id:"promise-prototype-finally"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-prototype-finally"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.prototype.finally")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("实现 "),s("code",[e._v("finally")]),e._v(" 需要我们理解几个点。")])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("前面的状态只要不是 "),s("code",[e._v("pending")]),e._v(", 则一定会进入执行。")]),e._v(" "),s("li",[e._v("类似于 "),s("code",[e._v("then")]),e._v(", 它可以注册多个回调，每个回调函数会依次执行。")]),e._v(" "),s("li",[e._v("回调函数内无法获取内部值。")]),e._v(" "),s("li",[e._v("除非在回调函数内抛出异常会把状态变成 "),s("code",[e._v("rejected")]),e._v("，否则它所做的仅仅是把状态和值传递。")])])]),e._v(" "),s("li",[s("p",[e._v("了解上述几点之后，我们可以复用 "),s("code",[e._v("then")]),e._v(" 方法，并自定义回调函数传入来实现。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\n* @param finallyCb\n* @returns\n*/\nfinally = (finallyCb: CallbackParams) => {\n  return this.then(\n    // 完成回调时，执行注册函数，并且将原来的值传递下去\n    // 封装 Promise 类，再调用 then 方法传递\n    val => PromiseLike.resolve(finallyCb && finallyCb()).then(() => val),\n    // 异常回调时，执行注册函数，并且抛出异常\n    err => PromiseLike.resolve(finallyCb && finallyCb()).then(() => { throw err })\n  );\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("写到这里，几个核心的原型方法我们就实现完毕了。")])]),e._v(" "),s("li",[s("p",[e._v("心急的伙伴可以直接实例化一个对象来尝试，不过 "),s("code",[e._v("Promise")]),e._v(" 当然还不止于此，接下来我们来实现对应的静态方法。")])])]),e._v(" "),s("h3",{attrs:{id:"_03-03-静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-03-静态方法"}},[e._v("#")]),e._v(" 03.03 静态方法")]),e._v(" "),s("ul",[s("li",[e._v("前面已经实现了一个自定义的 "),s("code",[e._v("Promise.is")]),e._v(" 方法来判断实例。这个工具类函数简单实用，可以留着。")]),e._v(" "),s("li",[e._v("还有两个快速实例化 "),s("code",[e._v("Promise")]),e._v(" 类的方法我们也进行了实现："),s("code",[e._v("Promise.resolve")]),e._v(" 和 "),s("code",[e._v("Promise.reject")]),e._v(". 下面来做一点改进。")])]),e._v(" "),s("h4",{attrs:{id:"promise-resolve"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-resolve"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.resolve")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("既然我们定义好了 "),s("code",[e._v("Promise.is")]),e._v(" 方法，加上对 "),s("code",[e._v("Promise")]),e._v(" 的理解进一步加深，知道了如果传入的已经是 "),s("code",[e._v("Promise")]),e._v(" 实例，则不必再进行处理。所以这个方法需要做一点兼容处理。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * 直接实例化 proimse\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\n* @param value\n* @returns\n*/\nstatic resolve(value?: any) {\n  if (PromiseLike.is(value)) {\n    return value;\n  }\n  return new PromiseLike((resolve) => resolve(value));\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("现在我们可以尝试实现 "),s("code",[e._v("Promise")]),e._v(" 提供的剩下两个类方法 "),s("code",[e._v("Promise.all")]),e._v(", "),s("code",[e._v("Promise.race")]),e._v(".")])])]),e._v(" "),s("h4",{attrs:{id:"promise-all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.all")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("该方法是接收一个由 "),s("code",[e._v("Promise")]),e._v(" 实例组成的数组，并返回 "),s("code",[e._v("Promise")]),e._v(" 实例，其值是所有 "),s("code",[e._v("Promise")]),e._v(" 实例的 "),s("code",[e._v("resolve")]),e._v(" 的值组成的数组。")])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("当其中任意一个 "),s("code",[e._v("Promise")]),e._v(" 有 "),s("code",[e._v("reject")]),e._v(" 的值时，"),s("code",[e._v("Promise.all")]),e._v(" 会返回最先 "),s("code",[e._v("rejected")]),e._v("的值。")]),e._v(" "),s("li",[e._v("等到所有 "),s("code",[e._v("Promise")]),e._v(" "),s("code",[e._v("resolve")]),e._v(" 之后，"),s("code",[e._v("Promise")]),e._v(".all 才会返回结果。")]),e._v(" "),s("li",[s("code",[e._v("Promise.all")]),e._v(" 也是支持链式调用的。")])])]),e._v(" "),s("li",[s("p",[e._v("大白话也许有些晦涩，我们直接看案例。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.all([Promise.resolve(1), Promise.reject(2)]); // Promise {<rejected>: 2}\nPromise.all([Promise.resolve(1), Promise.resolve(2)]); // Promise {<fulfilled>: Array(2)} [1, 2]\nPromise.all([]); // Promise {<fulfilled>: Array(2)}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("其中，第三个表达式的结果对理解 "),s("code",[e._v("Promise.race")]),e._v(" 和 "),s("code",[e._v("Promise.all")]),e._v(" 的区别很重要。这点后面会谈。除此之外，结果是显而易见的。")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("Promise.all")]),e._v(" 返回的结果是传入数组的参数的顺序，也可以理解为顺序执行，并填入对应的位置。基于这几点，要实现它就有思路了。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\n* @param promises 严格意义上来说，参数是可迭代对象，为了简化实现这里统一成数组\n* @returns\n*/\nstatic all(promises: Array<ICallbackFn>) {\n  // 支持链式调用\n  return new PromiseLike((resolve, reject) => {\n    const len = promises.length;\n    let resolvedPromisesCount = 0;\n    let resolvedPromisesResult = <any>[];\n    for (let i = 0; i < len; i++) {\n      const currentPromise = promises[i];\n      // 如果不是 Promise 实例，则需要包装一份；\n      // 但因为直接包装 Promise 类的效果是幂等的，所以这里不需要判断，直接处理即可\n      PromiseLike.resolve(currentPromise)\n      .then((res: any) => {\n        resolvedPromisesCount++;\n        resolvedPromisesResult[i] = res;\n        // 当所有值都 resolve 之后， 返回对应数组\n        if (resolvedPromisesCount === len) {\n          resolve(resolvedPromisesResult);\n        }\n      })\n      // 如果有任意一个异常，则直接推出\n      .catch((err: any) => {\n        reject(err);\n      });\n    }\n  });\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("顺序执行所有 "),s("code",[e._v("Promise")]),e._v("，并把结果保存到数组的对应位置，同时统计已执行的数量；当该数量等同于传入的数组长度时，返回由结果组成的数组。")])])]),e._v(" "),s("li",[s("p",[e._v("如同在方法注释里说明的一样，其实 "),s("code",[e._v("Promise.all")]),e._v(" 和 "),s("code",[e._v("Promise.race")]),e._v(" 方法接收的参数都是可迭代对象，并不仅仅是数组。这里为了方便实现，使用数组替代。可迭代对象不在这篇文章的核心讨论范围之内，感兴趣的可以点进上面的链接继续了解。")])])]),e._v(" "),s("h4",{attrs:{id:"promise-race"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.race")])]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("Promise.race")]),e._v(" 和 "),s("code",[e._v("Promise.all")]),e._v(" 有些相似，至少就参数而言，都接收可迭代对象作为参数，也可以链式调用，意味着它也返回一个新的 "),s("code",[e._v("Promise")]),e._v(" 实例。")])]),e._v(" "),s("li",[s("p",[e._v("不同的是，"),s("code",[e._v("Promise.race")]),e._v(" 将会返回第一个 "),s("code",[e._v("Promise.resolve")]),e._v(" 的值，或是第一个 reject 的值，而且这个值并不是数组。")])]),e._v(" "),s("li",[s("p",[e._v("了解到这两点之后，实现起来就有清晰的思路了。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\n* @param promises\n* @returns\n*/\nstatic race(promises: Array<ICallbackFn>) {\n  return new PromiseLike((resolve, reject) => {\n    for (let i = 0; i < promises.length; i++) {\n      const currentPromise = promises[i];\n      PromiseLike.resolve(currentPromise)\n        .then((res: any) => {\n          resolve(res);\n        })\n        .catch((err: any) => {\n          reject(err);\n        });\n    }\n  });\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("遍历顺序执行所有 Promise 并取出第一个 resolve 的值。")])])]),e._v(" "),s("li",[s("p",[e._v("再运行这样一段代码，得到的结果应该并不会让你意外。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Promise.race([]); // Promise {<pending>} 与 Promise.all 的结果不同\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("至此，目前已广泛兼容的两个核心方法我们都已经实现了。这是不是意味着可以愉快的玩耍了呢，当然可以。不过，既然都走到这一步了，我们顺带可以实现更多的 "),s("code",[e._v("Promise")]),e._v(" 方法，一来锻炼动手能力，二来证明学以致用。")])])]),e._v(" "),s("h3",{attrs:{id:"_03-04-其他静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_03-04-其他静态方法"}},[e._v("#")]),e._v(" 03.04 其他静态方法")]),e._v(" "),s("h4",{attrs:{id:"promise-allsettled"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-allsettled"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.allSettled")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("这个方法和 "),s("code",[e._v("Promise.all")]),e._v(" 非常相似，执行所有的 "),s("code",[e._v("Promise")]),e._v(" 实例并返回所有的结果，不论结果如何，都在返回的数组里塞回一个对象。")])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("每个对象只有两个属性 "),s("code",[e._v("status")]),e._v(" 和 "),s("code",[e._v("value")]),e._v(" 或 "),s("code",[e._v("reason")]),e._v("；如果当前 "),s("code",[e._v("proimse")]),e._v(" 是 "),s("code",[e._v("fulfilled")]),e._v(" 则属性是 "),s("code",[e._v("status")]),e._v(" 和 "),s("code",[e._v("value")]),e._v(", 如果当前是 "),s("code",[e._v("rejected")]),e._v(" 则属性是 "),s("code",[e._v("status")]),e._v(" 和 "),s("code",[e._v("reason")]),e._v(".")])])]),e._v(" "),s("li",[s("p",[e._v("对 "),s("code",[e._v("Promise.all")]),e._v(" 稍加改动就可以实现。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("判断计数的逻辑在两个回调函数中都进行，并且对返回值加一层包装。")])])]),e._v(" "),s("li",[s("p",[e._v("https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled")])]),e._v(" "),s("li",[s("p",[e._v("@param promises 严格意义上来说，参数是可迭代对象，为了简化实现这里统一成数组")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ static allSettled(promises: Array) { // 支持链式调用 return new PromiseLike((resolve, reject) => { const len = promises.length; const startTime = Date.now(); let resolvedPromisesCount = 0; let resolvedPromisesResult =[];")]),e._v(" "),s("p",[e._v("for (let i = 0; i < len; i++) { const currentPromise = promises[i]; // 如果不是 Promise 实例，则需要包装一份；// 但因为直接包装 Promise 类的效果是幂等的，所以这里不需要判断，直接处理即可 PromiseLike.resolve(currentPromise) .then((res: any) => { resolvedPromisesCount++; resolvedPromisesResult[i] = { status: PROMISE_STATES.FULFILLED, value: res }; // 当所有 promises 完成后，返回数组；多封装了一个属性用于显示执行时间 if (resolvedPromisesCount === len) { resolvedPromisesResult.duringTime = Date.now() - startTime + 'ms'; resolve(resolvedPromisesResult); } }) // 如果有任意一个异常，则直接推出 .catch((err: any) => { resolvedPromisesCount++; resolvedPromisesResult[i] = { status: PROMISE_STATES.REJECTED, reason: err }; if (resolvedPromisesCount === len) { resolvedPromisesResult.duringTime = Date.now() - startTime + 'ms'; resolve(resolvedPromisesResult); } }); } }); } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#### `Promise.any`\n\n- 这是今年\\(2021\\)刚刚落定草案的新 API。定义和 `Promise.race` 很相似，接收可迭代对象作为参数，可以链式调用。\n\n- 不同的是，它会返回第一个落定的，也就是 `resolve` 的值；如果传入的 `promise` 全都都进入拒绝状态，则它会等到所有拒绝状态都完成后，再返回一个由拒绝错误组成的对象。这个对象是新定义的类型 [AggregateError](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FAggregateError \"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AggregateError\")，这里暂且先不展开，直接使用它。\n\n- 从定义上来看，它和 `Promise.race` 相似，不过从实现上观察，却和 `Promise.all` 更加相似。\n\n -    只需要把计算数量的逻辑搬到错误回调中，并将其返回错误对象即可。\n\n```javascript\nclass PromiseLike {\n/**\n * 2021 年刚纳入规范的 any\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\n* @param promises\n* @returns\n*/\nstatic any(promises: Array<ICallbackFn>) {\n  return new PromiseLike((resolve, reject) => {\n    const len = promises.length;\n    let rejectedPromisesCount = 0;\n    let rejectedPromisesResult = <any>[];\n    for (let i = 0; i < promises.length; i++) {\n      const currentPromise = promises[i];\n      PromiseLike.resolve(currentPromise)\n        .then((res: any) => {\n          resolve(res);\n        })\n        .catch((err: any) => {\n          rejectedPromisesCount++;\n          rejectedPromisesResult[i] = err;\n          if (rejectedPromisesCount === len) {\n            // 如果浏览器支持，则直接抛出这个新对象，否则则直接抛出异常\n            if (isFunction(AggregateError)) {\n              throw new AggregateError(rejectedPromisesResult, 'All promises were rejected');\n            } else {\n              throw (rejectedPromisesResult);\n            }\n          }\n        });\n    }\n  })\n}\n}\n复制代码\n")])])]),s("h2",{attrs:{id:"_04-promise-a-规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_04-promise-a-规范"}},[e._v("#")]),e._v(" 04.Promise/A+规范")]),e._v(" "),s("h3",{attrs:{id:"_04-01-promises-aplus-tests-验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_04-01-promises-aplus-tests-验证"}},[e._v("#")]),e._v(" 04.01 promises-aplus-tests 验证")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("这个库 "),s("strong",[e._v("promises-aplus-tests")]),e._v("[17] 可以用来验证我们实现的 "),s("code",[e._v("Promise")]),e._v(" 是否遵循 "),s("strong",[e._v("Promise/A+规范")]),e._v("[18] 。")])]),e._v(" "),s("li",[s("p",[e._v("使用方式比较简单，注入一个方法即可，这个方法返回的对象包含 "),s("code",[e._v("Promise/resolve/reject")]),e._v(".")])]),e._v(" "),s("li",[s("p",[e._v("由于我们使用类的方式编写，所以直接新增一个静态函数即可。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("class PromiseLike {\n/**\n * 三方库验证\n* @returns\n*/\nstatic deferred() {\n  let defer: any = {};\n  defer.promise = new PromiseLike((resolve, reject) => {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n}\n}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("需要注意的是，要用 "),s("code",[e._v("commonjs")]),e._v(" 规范的方式来导出，否则会出现报错。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("module.exports = PromiseLike;\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("运行 "),s("code",[e._v("npx promises-aplus-tests 目录名")]),e._v(" 进行验证。")])])]),e._v(" "),s("h3",{attrs:{id:"_04-02-并不完美-兼容修复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_04-02-并不完美-兼容修复"}},[e._v("#")]),e._v(" 04.02 并不完美（兼容修复）")]),e._v(" "),s("ul",[s("li",[e._v("运行结果显示，有部分 case 没有通过。糟透了！下面一一提取。")])]),e._v(" "),s("h4",{attrs:{id:"chaining-cycle-detected-for-promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chaining-cycle-detected-for-promise"}},[e._v("#")]),e._v(" 'Chaining cycle detected for promise'")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("这个异常显示，我们不能在 "),s("code",[e._v("promise")]),e._v(" 中使用自身，否则会造成死循环。")])]),e._v(" "),s("li",[s("p",[e._v("举个例子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const p = Promise.resolve(1).then(() => p);\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("运行这段代码，就会得到上述报错。")])]),e._v(" "),s("li",[s("p",[e._v("解决办法并不难，定义变量来保存 "),s("code",[e._v("then")]),e._v(" 函数的返回值，同时在内部方法返回的位置进行兼容处理，如果相等就抛出异常。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const res = onFulfilled(val);\n// 返回的 promise 不可以是当前的 promise 否则会造成死循环\nif (newPromise === res) {\n throw new TypeError('Chaining cycle detected for promise #<Promise>');\n}\n复制代码\n")])])])])]),e._v(" "),s("h4",{attrs:{id:"_2-3-3-otherwise-if-x-is-an-object-or-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-3-otherwise-if-x-is-an-object-or-function"}},[e._v("#")]),e._v(" "),s("code",[e._v("2.3.3: Otherwise, if")]),e._v(" x "),s("code",[e._v("is an object or function")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("再次执行，发现 "),s("code",[e._v("Promise")]),e._v(" 规范对传入参数是对象和函数类型也有着特殊的处理。我们并没有处理，所以出现了上述报错。"),s("strong",[e._v("规范里")]),e._v("[19] 有所定义，我们可以简单理解为如果传入的参数是 "),s("code",[e._v("Thenable")]),e._v(" 的，则需要调用其中的 "),s("code",[e._v("then")]),e._v(" 方法，也就是将其展开调用。上文中自己有提到，终究是逃不过。")])]),e._v(" "),s("li",[s("p",[e._v("之前我们仅仅对 "),s("code",[e._v("Promise")]),e._v(" 的实例进行了特殊处理，现在意识到还需要处理 "),s("code",[e._v("Thenable")]),e._v(" 接口的对象。但因为 "),s("code",[e._v("Promise")]),e._v(" 实例本身就是实现 "),s("code",[e._v("Thenable")]),e._v(" 接口的特殊对象。("),s("code",[e._v("typeof Promise.resolve(1); // object")]),e._v(")，所以实现了对 "),s("code",[e._v("Thenable")]),e._v(" 接口的处理，自然也能涵盖原有的逻辑。")])]),e._v(" "),s("li",[s("p",[e._v("新定义一个单独的方法来实现，以提高可读性。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("ul",[s("li",[e._v("这个函数有些复杂，但每一条逻辑都可以在规范里追溯。")])])]),e._v(" "),s("li",[s("p",[e._v("该实现遵循 Promise/A+ 规范")])]),e._v(" "),s("li",[s("p",[e._v("https://github.com/promises-aplus/promises-spec")])]),e._v(" "),s("li",[s("p",[e._v("@param promise")])]),e._v(" "),s("li",[s("p",[e._v("@param x")])]),e._v(" "),s("li",[s("p",[e._v("@param resolve")])]),e._v(" "),s("li",[s("p",[e._v("@param reject")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ const resolvePromise = (promise: any, x: any, resolve: ICallbackFn, reject: ICallbackFn) =>// 返回的 promise 不可以是当前的 promise 否则会造成死循环 if (newPromise === x) { reject(new TypeError('Chaining cycle detected for promise #')); } // 对可能是 thenable 接口实现的对象判断 if (isObject(x)| isFunction(x)) { if (x === null) { return resolve(x);let thenCb; try { thenCb = x.then; } catch (error) { return reject(error); }")]),e._v(" "),s("p",[e._v("// 如果是 thenable 的对象，则调用其 then 方法 // 这一步涵盖了 Promise 实例的可能性 if (isFunction(thenCb)) { let isCalled = false; try { thenCb.call( x, // 指向当前函数或对象 (y: any) => { // 如果 resolvePromise 和 rejectPromise 都可能被调用 // 则只需调用第一次（resolvePromise 或 rejectPromise），后续无需再执行 if (isCalled) return; isCalled = true; // 传入当前函数，以实现递归展开调用 resolvePromise(promise, y, resolve, reject); }, (r: any) => { // 对应前面任意的调用之后，就不再只需后续逻辑 if (isCalled) return; isCalled = true; reject(r); } ) } catch (error) { if (isCalled) return; reject(error); } } else { resolve(x); } } else { resolve(x); } } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("- 在原先处理数据的地方，换成 `resolvePromise` 函数就可以了。\n\n- 这下是可算是完整通过测试了。\n\n```shell\n872 passing (14s)\n复制代码\n")])])]),s("h2",{attrs:{id:"_05-更多优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-更多优化"}},[e._v("#")]),e._v(" 05.更多优化")]),e._v(" "),s("h3",{attrs:{id:"_05-01-queuemicrosoft-20"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-01-queuemicrosoft-20"}},[e._v("#")]),e._v(" 05.01 queueMicrosoft[20]")]),e._v(" "),s("ul",[s("li",[e._v("学习过程中，意外发现 "),s("code",[e._v("queueMicrosoft")]),e._v(" 这个方法，用于将任务转换成微任务。我们知道 "),s("code",[e._v("setTimeout")]),e._v(" 虽然可以实现异步的效果，但它属于宏任务，与 "),s("code",[e._v("Promise")]),e._v(" 所属的微任务不符。所以可以用 "),s("code",[e._v("queueMicrosoft")]),e._v(" 来替换。")]),e._v(" "),s("li",[e._v("有关使用方式，可以"),s("strong",[e._v("查看这里")]),e._v("[21]")])]),e._v(" "),s("h3",{attrs:{id:"_05-02-typescript-完善"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-02-typescript-完善"}},[e._v("#")]),e._v(" 05.02 typescript 完善")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("前面的例子里已经定义许多接口。这里举个例子完善一哈，更多详细内容可以查看下文的源码。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("export interface IPromiseType {\nthen: IExecutorFn;\ncatch: ICallbackFn;\nfinally: ICallbackFn;\n}\n\nclass PromiseLike implements IPromiseType {}\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("由于自己的 typescript 实践仍在学习中，可能源码中还存在许多值得改进和优化的地方，可以在评论或 issue 中指出，合理的改进建议一定会采纳并实践。")])]),e._v(" "),s("li",[s("p",[e._v("使用版本："),s("code",[e._v('"typescript": "^4.3.5"')])])])]),e._v(" "),s("h3",{attrs:{id:"_05-03-花里胡哨的变种方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_05-03-花里胡哨的变种方法"}},[e._v("#")]),e._v(" 05.03 花里胡哨的变种方法")]),e._v(" "),s("h4",{attrs:{id:"promise-last"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-last"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.last")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("定义一个函数，返回最后一个完成的 "),s("code",[e._v("promise")]),e._v(", 并且可以选择是否需要 "),s("code",[e._v("rejected")]),e._v(" 的 "),s("code",[e._v("promise")]),e._v(".")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("p",[e._v("返回最后一个完成的值，可以自行决定是否忽略异常")])]),e._v(" "),s("li",[s("p",[e._v("如果不忽略，异常优先抛出")])]),e._v(" "),s("li",[s("p",[e._v("如果忽略，返回完成值")])]),e._v(" "),s("li",[s("p",[e._v("@param promises")])]),e._v(" "),s("li",[s("p",[e._v("@param ignoreRejected")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ static last(promises: Array, ignoreRejected: boolean = false) { return new PromiseLike((resolve, reject) => { const len = promises.length; const startTime = Date.now(); let resolvedPromisesCount = 0;")]),e._v(" "),s("p",[e._v("for (let i = 0; i < len; i++) { const currentPromise = promises[i]; PromiseLike.resolve(currentPromise) .then((res: any) => { resolvedPromisesCount++; // 当所有 promises 完成后，返回最后一个值；封装一个属性用于显示执行时间 if (resolvedPromisesCount === len) { isObject(res) && (res.duringTime = Date.now() - startTime + 'ms'); resolve(res); } }) // 如果有任意一个异常，则直接推出 .catch((err: any) => { if (ignoreRejected) { resolvedPromisesCount++; } else { reject(err) } }); } }); } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("- 还可以实现一个它的变种，即返回最后一个更新的值，不论是 `fulfilled` 或者 `rejected` 状态.源码有展示，这里不再赘述。\n\n#### `Promise.wrap`\n\n- 该方法可以将原来的普通异步请求包装成 `Promise` 实例，便于链式调用等。\n\n- 假设有这样一个请求处理函数。\n\n```ts\nfunction fn(url, cb) {\najax(url, cb);\n}\n复制代码\n")])])]),s("ul",[s("li",[s("p",[e._v("想让它变成可以使用链式调用，使用方式见注释。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("p",[e._v("把不是 promise 实例的函数包装成 promise 实例")])]),e._v(" "),s("li",[s("p",[e._v("例如 ajax 请求")])]),e._v(" "),s("li",[s("p",[e._v("const request = Promise.wrap(ajax);")])]),e._v(" "),s("li",[s("p",[e._v("request.then(callback);")])]),e._v(" "),s("li",[s("p",[e._v("@param fn")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ static wrap(fn: any) { if (!isFunction(fn)) { return fn; } return function () { const args: any[] = Array.prototype.slice.call(arguments); return new PromiseLike((resolve) => { fn.apply(null, args.concat(function (res: any, err: any) { res && resolve(res); err && resolve(err); })); }) } } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#### `Promise.sequence`\n\n- 链式调用的能力可以结合数组的 `reduce` 完成串行操作，把函数传入组合成新的函数。\n\n -    这里的参数不涉及 `Promise` 实例，使用链式调用来实现。\n\n```ts\n/**\n* 返回一个函数来执行\n* @param fns\n* @returns\n*/\nstatic sequence(fns: Array<ICallbackFn>) {\nreturn (x: number) => fns.reduce((acc, fn: ICallbackFn) => {\n  if (!isFunction(fn)) {\n    fn = x => x;\n  }\n  return acc.then(fn).catch((err: any) => { throw err });\n}, PromiseLike.resolve(x));\n}\n复制代码\n")])])]),s("ul",[s("li",[s("p",[e._v("假设有多个函数，我们可以通过这样的操作来将它们组合，组合的内容是处理函数。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function addThree(x) {\nreturn x + 3;\n}\nfunction addFive(x) {\nreturn x + 5;\n}\nconst addEight = ProimseLike.sequence([addThree, addFive]);\naddEight(2); // 10\n复制代码\n")])])])]),e._v(" "),s("li",[s("p",[e._v("上面的函数其实已经实现了串行；还可以做一些改动把每个值按顺序保存下来。")])])]),e._v(" "),s("h4",{attrs:{id:"promise-sequencebyorder"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-sequencebyorder"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.sequenceByOrder")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("该方法顺序执行函数，并返回按完成顺序排列的值。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("p",[e._v("串行执行所有 promises,并返回按返回顺序排列的数组")])]),e._v(" "),s("li",[s("p",[e._v("注意接收的参数是返回 promise 实例的函数组成的数组")])]),e._v(" "),s("li",[s("p",[e._v("@param promises")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ static sequenceByOrder(promises: Array) { return new PromiseLike((resolve) => { let promiseResults: any = []; const reduceRes = promises.reduce((prevPromise, currentPromise: ICallbackFn, currentIndex: number) => { return prevPromise.then((val: any) => { promiseResults.push(val); const newVal = currentPromise(val); // 最后一次循环时保存，并剔除第一个值（默认 undefined) if (currentIndex === promises.length - 1) { promiseResults.unshift(); } return newVal; }); }, PromiseLike.resolve()); reduceRes.then((val: any) => { promiseResults.push(val); resolve(promiseResults); }); }); } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#### `Promise.map`\n\n- 定义一个可以处理所有 `promise` 值的函数，类似数组的 `map` 方法。\n\n```ts\n/**\n* 对每个 promise 的值进行特定的处理\n* Promise.map([p1, p2, p3], (val, resolve) => {\n*   resolve(val + 1);\n* })\n* @param promises\n* @param fn\n* @returns\n*/\nstatic map(promises: Array<IPromiseType>, fn: any) {\nreturn PromiseLike.all(promises.map((currentPromise) => {\n  return new PromiseLike((resolve) => {\n    if (!isFunction(fn)) {\n      fn = (val:any, resolve: ICallbackFn) => resolve(val);\n    }\n    fn(currentPromise, resolve);\n  })\n}));\n}\n复制代码\n")])])]),s("h4",{attrs:{id:"promise-observe"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-observe"}},[e._v("#")]),e._v(" "),s("code",[e._v("Promise.observe")])]),e._v(" "),s("ul",[s("li",[s("p",[e._v("定义这样一个函数，用于清理 "),s("code",[e._v("promise")]),e._v(" 相关的副作用，通常用在 "),s("code",[e._v("Promise.race")]),e._v(" 中。假设我们使用 "),s("code",[e._v("Promise.race")]),e._v(" 来设定超时，但仍然希望超时的场景里能够处理数据。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n")])])])]),e._v(" "),s("li",[s("p",[e._v("Promise.race([Promise.observe(p, cleanup // 处理函数), timeoutFn // 超时函数])")])]),e._v(" "),s("li",[s("p",[e._v("@param promise")])]),e._v(" "),s("li",[s("p",[e._v("@param fn")])]),e._v(" "),s("li",[s("p",[e._v("@returns */ static observe(promise: IPromiseType, fn: ICallbackFn) { promise .then((res: any) => { PromiseLike.resolve(res).then(fn); }, (err) => { PromiseLike.resolve(err).then(fn); }); return promise; } 复制代码")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("## 06.源码\n\n### 06.01 部分源码\n\n- 所有源码虽不多，全部张贴出来也比较占版面。下面是 `then` 的完整实现。\n\n```ts\nclass PromiseLike {\n/**\n * 根据当前不同状态来执行对应逻辑\n* 如果在默认状态就是注册对应事件\n* 如果状态变化则是执行对应事件\n* @param onFulfilled\n* @param onRejected\n* @returns\n*/\nthen = (onFulfilled?: CallbackParams, onRejected?: CallbackParams) => {\n  // 默认处理！！！\n  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value => value;\n  onRejected = isFunction(onRejected) ? onRejected : err => { throw err };\n\n  /**\n   * 该实现遵循 Promise/A+ 规范\n  * https://github.com/promises-aplus/promises-spec\n  * @param promise\n  * @param x\n  * @param resolve\n  * @param reject\n  * @returns\n  */\n  const resolvePromise = (promise: IPromiseType, x: any, resolve: ICallbackFn, reject: ICallbackFn) => {\n    // 返回的 promise 不可以是当前的 promise 否则会造成死循环\n    if (newPromise === x) {\n      reject(new TypeError('Chaining cycle detected for promise #<Promise>'));\n    }\n    // 对可能是 thenable 接口实现的对象判断\n    if (isObject(x) || isFunction(x)) {\n      if (x === null) {\n        return resolve(x);\n      }\n      let thenCb;\n      try {\n        thenCb = x.then;\n      } catch (error) {\n        return reject(error);\n      }\n\n      // 如果是 thenable 的对象，则调用其 then 方法\n      // 这一步涵盖了 Promise 实例的可能性\n      if (isFunction(thenCb)) {\n        let isCalled = false;\n        try {\n          thenCb.call(\n            x, // 指向当前函数或对象\n            (y: any) => {\n              // 如果 resolvePromise 和 rejectPromise 都可能被调用\n              // 则只需调用第一次（resolvePromise 或 rejectPromise），后续无需再执行\n              if (isCalled) return;\n              isCalled = true;\n              // 传入当前函数，以实现递归展开调用\n              resolvePromise(promise, y, resolve, reject);\n            },\n            (r: any) => {\n              // 对应前面任意的调用之后，就不再只需后续逻辑\n              if (isCalled) return;\n              isCalled = true;\n              reject(r);\n            }\n          )\n        } catch (error) {\n          if (isCalled) return;\n          reject(error);\n        }\n      } else {\n        resolve(x);\n      }\n    } else {\n      resolve(x);\n    }\n  }\n\n  // 定义变量，用于传参进行比较\n  const newPromise = new PromiseLike((resolve, reject) => {\n    /**\n     * 封装完成回调函数\n    * @param val\n    */\n    const handleFulfilled = (val: any) => {\n      try {\n        const x = onFulfilled && onFulfilled(val);\n        resolvePromise(newPromise, x, resolve, reject);\n      } catch (error) {\n        // 如果当前执行逻辑内发生异常，则抛出异常\n        reject(error);\n      };\n    };\n\n    /**\n     * 封装错误回调函数\n    * @param val\n    */\n    const handleRejected = (val: any) => {\n      try {\n        const x = onRejected && onRejected(val);\n        resolvePromise(newPromise, x, resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    }\n\n    switch (this.PromiseState) {\n      case PROMISE_STATES.PENDING:\n        this.resolveCallbackQueues.push(handleFulfilled);\n        this.rejectCallbackQueues.push(handleRejected);\n        break;\n      case PROMISE_STATES.FULFILLED:\n        handleFulfilled(this.PromiseResult);\n        break;\n      case PROMISE_STATES.REJECTED:\n        handleRejected(this.PromiseResult);\n        break;\n    }\n  });\n\n  return newPromise;\n}\n}\n复制代码\n")])])]),s("h3",{attrs:{id:"_06-02-全部源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_06-02-全部源码"}},[e._v("#")]),e._v(" 06.02 全部源码")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Github 地址")]),e._v("[22]")])]),e._v(" "),s("h2",{attrs:{id:"_07-小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_07-小结"}},[e._v("#")]),e._v(" 07.小结")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("在这次尝试实现 "),s("code",[e._v("Promise")]),e._v(" 的过程中，自己也在边写边学。这是我理解和实践的整个思路，并不一定适用其他人；希望它能作为一种参考，启发或者影响到他人。在写这篇文章之前，我没想到会投入了整整两天时间，却也只是弄懂了些皮毛。而 "),s("code",[e._v("Promise")]),e._v(" 内部显然还有许多值得探讨的地方，涉及的微任务， "),s("code",[e._v("async/await")]),e._v(" 相关，迭代器和生成器；只是目前精力所限，先止于此。后面也许会解析迭代器和生成器的内容。")])]),e._v(" "),s("li",[s("p",[e._v("整个实践，也是自己练习 "),s("code",[e._v("typescipt")]),e._v(" 的过程，这里我使用类的方式编写，主要是便于自己理解；但它也完全可以用函数实现。"),s("code",[e._v("typescript")]),e._v(" 编译后的代码就是函数的实现，而且是 js. 可以直接查看下面的地址了解。另外，其中内容的编译转换也是值得探索的。")])]),e._v(" "),s("li",[s("ul",[s("li",[s("strong",[e._v("Github")]),e._v("**：https://github.com/kyriejoshua/promise-like/blob/master/dist/index.js**")])])])]),e._v(" "),s("p",[e._v("关于本文")]),e._v(" "),s("h1",{attrs:{id:"作者-deadpool-ky"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作者-deadpool-ky"}},[e._v("#")]),e._v(" 作者：deadpool_ky")]),e._v(" "),s("p",[e._v("https://juejin.cn/post/6987674192166518821")])])}),[],!1,null,null,null);r.default=t.exports}}]);