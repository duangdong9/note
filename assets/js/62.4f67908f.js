(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{476:function(n,t,e){"use strict";e.r(t);var s=e(18),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"js-实现-bind-的这五层-你在第几层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-实现-bind-的这五层-你在第几层"}},[n._v("#")]),n._v(" js 实现 bind 的这五层，你在第几层？")]),n._v(" "),e("blockquote",[e("p",[e("a",{attrs:{href:"https://mp.weixin.qq.com/s/SJL5Vn829kjvd1EjyLqIvw",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://mp.weixin.qq.com/s/SJL5Vn829kjvd1EjyLqIvw"),e("OutboundLink")],1)])]),n._v(" "),e("p",[n._v("最近在帮女朋友复习 JS 相关的基础知识，遇到不会的问题，她就会来问我。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/gibGQibkduDnBTzTz0xPSOgfbdvBpicMXcDhc514ibAWQaxvxNibor6avzVGJ7QdIhfCWSlgtAjEmMBbiajSfxhxaWQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("这不是很简单？三下五除二，分分钟解决。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function bind(fn, obj, ...arr) {\n return fn.apply(obj, arr)\n}\n")])])]),e("p",[n._v("于是我就将这段代码发了过去")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/gibGQibkduDnBTzTz0xPSOgfbdvBpicMXcD9zgdveCZctoE3SUPoBIt0lJNeyyiaRXM33B9Io73fnRdazDTVXFZw2g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("这时候立马被女朋友进行了一连串的灵魂拷问。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/gibGQibkduDnBTzTz0xPSOgfbdvBpicMXcDFwLmicKicFcjLlL9WAWNZIe9CQrh4YaWIyZictHtyYLI55qnrhj6Alp9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("p",[n._v("这个时候，我马老师就坐不住了，我不服气，我就去复习了一下 bind，发现太久不写基础代码，还是会需要一点时间复习，这一次我得写一个有深度的 bind，深得马老师的真传，给他分成了五层速记法。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibGQibkduDnBTzTz0xPSOgfbdvBpicMXcD9OanO7qftApAhExF1ia2ajibHTEyHkqSkTb7WbfKDo8tGO9HrAACCibuw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("h2",{attrs:{id:"第一层-绑定在原型上的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一层-绑定在原型上的方法"}},[n._v("#")]),n._v(" 第一层 - 绑定在原型上的方法")]),n._v(" "),e("p",[n._v("这一层非常的简单，得益于 JS 原型链的特性。由于 function xxx 的原型链 指向的是 "),e("code",[n._v("Function.prototype")]),n._v(" , 因此我们在调用 xxx.bind 的时候，调用的是  Function.prototype 上的方法。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype._bind = function() {}\n")])])]),e("p",[n._v("这样，我们就可以在一个构造函数上直接调用我们的bind方法啦~例如像这样。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("funciton myfun(){}\nmyfun._bind();\n")])])]),e("p",[n._v("想要详细理解这方面的可以看这张图和这篇文章（https://github.com/mqyqingfeng/blog/issues/2）")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mmbiz.qpic.cn/sz_mmbiz_png/gibGQibkduDnBTzTz0xPSOgfbdvBpicMXcDFjdpncJoco73RtbcIcbmwCNx4r0TZKBAmaZJgeU8DMiaHI4wXoDyNkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),n._v(" "),e("h2",{attrs:{id:"第二层-改变-this-的指向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第二层-改变-this-的指向"}},[n._v("#")]),n._v(" 第二层 - 改变 this 的指向")]),n._v(" "),e("p",[n._v("这可以说是 bind 最核心的特性了，就是改变 this 的指向，并且返回一个函数。而改变 this , 我们可以通过已知的  apply 和 call 来实现，这里我们就暂且使用 apply 来进行模拟。首先通过 "),e("code",[n._v("self")]),n._v("来保存当前 this，也就是传入的函数。因为我们知道 this 具有 "),e("code",[n._v("隐式绑定")]),n._v("的规则（"),e("strong",[n._v("摘自 《你不知道的JavaScript(上)》2.2.2")]),n._v(" ），")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function foo() {console.log(this.a)}\nvar obj = {a: 2, foo};\nobj.foo(); // 2\n")])])]),e("p",[n._v("通过以上特性，我们就可以来写我们的 _bind 函数。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype._bind = function(thisObj) {\n const self = this;\n return function () {\n    self.apply(thisObj);\n  }\n}\nvar obj = {a:1}\nfunction myname() {console.log(this.a)}\nmyname._bind(obj)(); // 1\n")])])]),e("p",[n._v("可能很多朋友都止步于此了，因为在一般的面试中，特别是一些校招面试中，可能你只需要知道前面两个就差不多了。但是想要在面试中惊艳所有人，仍然是不够的，接下来我们继续我们的探索与研究。")]),n._v(" "),e("h2",{attrs:{id:"第三层-支持柯里化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第三层-支持柯里化"}},[n._v("#")]),n._v(" 第三层 - 支持柯里化")]),n._v(" "),e("p",[n._v("函数柯里化是一个老生常谈的话题，在这里再复习一下。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fn(x) {\n return function (y) {\n  return x + y;\n }\n}\nvar fn1 = fn(1);\nfn1(2) // 3\n")])])]),e("p",[n._v("不难发现，柯里化使用了闭包，当我们执行 fn1 的时候，函数内使用了外层函数的 x， 从而形成了闭包。")]),n._v(" "),e("p",[n._v("而我们的 bind 函数也是类似，我们通过获取当前外部函数的  "),e("code",[n._v("arguments")]),n._v(" ，并且去除了绑定的对象，保存成变量 "),e("code",[n._v("args")]),n._v("，最后 "),e("code",[n._v("return")]),n._v(" 的方法，再一次获取当前函数的  "),e("code",[n._v("arguments")]),n._v(", 最终用 "),e("code",[n._v("finalArgs")]),n._v(" 进行了一次合并。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype._bind = function(thisObj) {\n const self = this;\n  const args = [...arguments].slice(1)\n return function () {\n    const finalArgs = [...args, ...arguments]\n    self.apply(thisObj, finalArgs);\n  }\n}\n")])])]),e("p",[n._v("通过以上代码，让我们 bind 方法，越来越健壮了。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var obj = { i: 1}\nfunction myFun(a, b, c) {\n  console.log(this.i + a + b + c);\n}\nvar myFun1 = myFun._bind(obj, 1, 2);\nmyFun1(3); // 7\n")])])]),e("p",[n._v("一般到了这层，可以说非常棒了，但是再坚持一下下，就变成了完美的答卷。")]),n._v(" "),e("h2",{attrs:{id:"第四层-考虑-new-的调用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第四层-考虑-new-的调用"}},[n._v("#")]),n._v(" 第四层 - 考虑 new 的调用")]),n._v(" "),e("p",[n._v("要知道，我们的方法，通过 bind 绑定之后，依然是可以通过 new 来进行实例化的， "),e("code",[n._v("new")]),n._v(" 的优先级会高于 "),e("code",[n._v("bind")]),n._v("（"),e("strong",[n._v("摘自 《你不知道的JavaScript(上)》2.3 优先级")]),n._v("）。")]),n._v(" "),e("p",[n._v("这一点我们通过原生  bind 和我们第四层的 _bind 来进行验证对比。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 原生\nvar obj = { i: 1}\nfunction myFun(a, b, c) {\n  // 此处用new方法，this指向的是当前函数 myFun \n  console.log(this.i + a + b + c);\n}\nvar myFun1 = myFun.bind(obj, 1, 2);\nnew myFun1(3); // NAN\n\n// 第四层的 bind\nvar obj = { i: 1}\nfunction myFun(a, b, c) {\n  console.log(this.i + a + b + c);\n}\nvar myFun1 = myFun._bind(obj, 1, 2);\nnew myFun1(3); // 7\n")])])]),e("p",[e("strong",[n._v("注意，这里使用的是 "),e("code",[n._v("bind")]),n._v("方法")])]),n._v(" "),e("p",[n._v("因此我们需要在 bind 内部，对 new 的进行处理。而 "),e("code",[n._v("new.target")]),n._v(" 属性，正好是用来检测构造方法是否是通过 "),e("code",[n._v("new")]),n._v(" 运算符来被调用的。")]),n._v(" "),e("p",[n._v("接下来我们还需要自己实现一个 new ，")]),n._v(" "),e("blockquote",[e("p",[n._v("而根据 "),e("code",[n._v("MDN")]),n._v("，"),e("strong",[e("code",[n._v("new")])]),n._v(" 关键字会进行如下的操作：")]),n._v(" "),e("p",[n._v("1.创建一个空的简单JavaScript对象（即"),e("code",[n._v("{}")]),n._v("）；")]),n._v(" "),e("p",[n._v("2.链接该对象（设置该对象的"),e("strong",[n._v("constructor")]),n._v("）到另一个对象 ；")]),n._v(" "),e("p",[n._v("3.将步骤1新创建的对象作为"),e("code",[n._v("this")]),n._v("的上下文 ；")]),n._v(" "),e("p",[n._v("4.如果该函数没有返回对象，则返回"),e("code",[n._v("this")]),n._v("。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype._bind = function(thisObj) {\n const self = this;\n  const args = [...arguments].slice(1);\n return function () {\n    const finalArgs = [...args, ...arguments];\n  // new.target 用来检测是否是被 new 调用\n    if(new.target !== undefined) {\n      // this 指向的为构造函数本身\n      var result = self.apply(this, finalArgs);\n      // 判断改函数是否返回对象\n      if(result instanceof Object) {\n        return reuslt;\n      }\n      // 没有返回对象就返回 this\n      return this;\n    } else {\n      // 如果不是 new 就原来的逻辑\n      return self.apply(thisArg, finalArgs);\n    }\n  }\n}\n")])])]),e("p",[n._v("看到这里，你的造诣已经如火纯情了，但是最后还有一个小细节。")]),n._v(" "),e("h2",{attrs:{id:"第五层-保留函数原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第五层-保留函数原型"}},[n._v("#")]),n._v(" 第五层 - 保留函数原型")]),n._v(" "),e("p",[n._v("以上的方法在大部分的场景下都没有什么问题了，但是，当我们的构造函数有 prototype 属性的时候，就出问题啦。因此我们需要给 prototype 补上，还有就是调用对象必须为函数。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Function.prototype._bind = function (thisObj) {\n  // 判断是否为函数调用\n  if (typeof target !== 'function' || Object.prototype.toString.call(target) !== '[object Function]') {\n    throw new TypeError(this + ' must be a function');\n  }\n  const self = this;\n  const args = [...arguments].slice(1);\n  var bound = function () {\n    var finalArgs = [...args, ...arguments];\n    // new.target 用来检测是否是被 new 调用\n    if (new.target !== undefined) {\n      // 说明是用new来调用的\n      var result = self.apply(this, finalArgs);\n      if (result instanceof Object) {\n        return result;\n      }\n      return this;\n    } else {\n      return self.apply(thisArg, finalArgs);\n    }\n  };\n  if (self.prototype) {\n    // 为什么使用了 Object.create? 因为我们要防止，bound.prototype 的修改而导致self.prototype 被修改。不要写成 bound.prototype = self.prototype; 这样可能会导致原函数的原型被修改。\n    bound.prototype = Object.create(self.prototype);\n    bound.prototype.constructor = self;\n  }\n  return bound;\n};\n")])])]),e("p",[n._v("以上就是一个比较完整的 bind 实现了，如果你想了解更多细节的实践，可以查看。（也是 MDN 推荐的）")]),n._v(" "),e("p",[n._v("https://github.com/Raynos/function-bind")])])}),[],!1,null,null,null);t.default=a.exports}}]);