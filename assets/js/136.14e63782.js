(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{546:function(e,n,s){"use strict";s.r(n);var t=s(18),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"axios怎么封装-才能提升效率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#axios怎么封装-才能提升效率"}},[e._v("#")]),e._v(" axios怎么封装，才能提升效率？")]),e._v(" "),s("blockquote",[s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/8qbSVehFyiVSpBURZYkiNA",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/8qbSVehFyiVSpBURZYkiNA"),s("OutboundLink")],1)])]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("作为前端开发者，每个项目基本都需要和后台交互，目前比较流行的ajax库就是axios了，当然也有同学选择request插件，这个萝卜白菜，各有所爱了。目前虽然axios有config、interceptor和各个请求方式，但是针对一个大型的项目，我们还是需要做二次封装才能快速提升开发效率！")]),e._v(" "),s("p",[e._v("今天我们针对axios库做二次封装，看看是否有简化我们的开发工作。"),s("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/YItGPcJZoxlZdVzngA3gY7PzKHFouWzjkUx3Z7koW3LfopGf9JfbBxmwYvUibCT6PO47sQH80qnnNlQ3zIhEiaCQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),s("h2",{attrs:{id:"创建项目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建项目"}},[e._v("#")]),e._v(" "),s("strong",[e._v("创建项目")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  vue create axios-demo\n")])])]),s("h2",{attrs:{id:"创建目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建目录"}},[e._v("#")]),e._v(" "),s("strong",[e._v("创建目录")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  // 进入到项目空间中\n  cd axios-demo\n  // 在src下创建api目录\n")])])]),s("h2",{attrs:{id:"创建三个文件-index-js-interceptor-js-request-js"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建三个文件-index-js-interceptor-js-request-js"}},[e._v("#")]),e._v(" "),s("strong",[e._v("创建三个文件(index.js/interceptor.js/request.js)")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * index.js\n * api地址管理\n */\nexport default {\n    login:'/user/login',\n    getInfo:'/user/getInfo'\n}\n")])])]),s("p",[e._v("index.js实际上和axios封装没有关系，因为它也属于API这一层，所以我一起创建了，我个人习惯把项目所有url抽取到这里集中管理。")]),e._v(" "),s("h2",{attrs:{id:"封装interceptor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装interceptor"}},[e._v("#")]),e._v(" "),s("strong",[e._v("封装interceptor")])]),e._v(" "),s("p",[e._v("interceptor作用就是拦截，可以针对请求参数和响应结果进行拦截处理，一般在项目当中，我们主要会针对接口常规报错、网络报错、系统超时、权限认证等做拦截处理。")]),e._v(" "),s("p",[e._v("此处我们对通过create创建实例，设置baseUrl，timeout，然后在设置request和response的拦截。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * 生成基础axios对象，并对请求和响应做处理\n * 前后端约定接口返回解构规范\n * {\n *    code:0,\n *    data:\"成功\",\n *    message:\"\"\n * }\n */\nimport axios from 'axios'\nimport { Message } from 'element-ui'\n\n// 创建一个独立的axios实例\nconst service = axios.create({ \n    // 设置baseUr地址,如果通过proxy跨域可直接填写base地址\n    baseURL: '/api',\n    // 定义统一的请求头部\n    headers: {\n        post: {\n            \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\"\n        }\n    },\n    // 配置请求超时时间\n    timeout: 10000, \n    // 如果用的JSONP，可以配置此参数带上cookie凭证，如果是代理和CORS不用设置\n    withCredentials: true\n});\n// 请求拦截\nservice.interceptors.request.use(config => {\n    // 自定义header，可添加项目token\n    config.headers.token = 'token';\n    return config;\n});\n// 返回拦截\nservice.interceptors.response.use((response)=>{\n    // 获取接口返回结果\n    const res = response.data;\n    // code为0，直接把结果返回回去，这样前端代码就不用在获取一次data.\n    if(res.code === 0){\n        return res;\n    }else if(res.code === 10000){\n        // 10000假设是未登录状态码\n        Message.warning(res.message);\n        // 也可使用router进行跳转\n        window.location.href = '/#/login';\n        return res;\n    }else{\n        // 错误显示可在service中控制，因为某些场景我们不想要展示错误\n        // Message.error(res.message);\n        return res;\n    }\n},()=>{\n    Message.error('网络请求异常，请稍后重试!');\n});\nexport default service;\n")])])]),s("p",[e._v("如果是CORS/JSONP需要区分环境，可通过"),s("code",[e._v("process.env.NODE_ENV")]),e._v("来选择使用哪个地址。如果使用的是代理，则Vue项目需要在vue.config.js中的proxy里面增加环境判断。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('process.env.NODE_ENV=== "production" ? "http://www.prod.com/api" : "http://localhost/:3000/api"\n')])])]),s("p",[e._v("以上是针对interceptor做的二次封装，上面我们没有把常规错误放进去，是因为我们想要在后期控制错误是否显示，所以我们会在request中处理。")]),e._v(" "),s("h2",{attrs:{id:"封装axios"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装axios"}},[e._v("#")]),e._v(" "),s("strong",[e._v("封装axios")])]),e._v(" "),s("p",[e._v("创建request文件，针对axios做适合业务发展的封装，很多时候架构师做公共机制都是为了迎合自身项目需要，而并非一味求大做全，所以这个大家要适当调整，比如我们只用get/post请求。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n * request.js\n * 通过promise对axios做二次封装，针对用户端参数，做灵活配置\n */\nimport { Message,Loading } from 'element-ui';\nimport instance from './interceptor'\n\n/**\n * 核心函数，可通过它处理一切请求数据，并做横向扩展\n * @param {url} 请求地址\n * @param {params} 请求参数\n * @param {options} 请求配置，针对当前本次请求；\n * @param loading 是否显示loading\n * @param mock 本次是否请求mock而非线上\n * @param error 本次是否显示错误\n */\nfunction request(url,params,options={loading:true,mock:false,error:true},method){\n    let loadingInstance;\n    // 请求前loading\n    if(options.loading)loadingInstance=Loading.service();\n    return new Promise((resolve,reject)=>{\n        let data = {}\n        // get请求使用params字段\n        if(method =='get')data = {params}\n        // post请求使用data字段\n        if(method =='post')data = {data:params}\n        // 通过mock平台可对局部接口进行mock设置\n        if(options.mock)url='http://www.mock.com/mock/xxxx/api';\n        instance({\n            url,\n            method,\n            ...data\n        }).then((res)=>{\n            // 此处作用很大，可以扩展很多功能。\n            // 比如对接多个后台，数据结构不一致，可做接口适配器\n            // 也可对返回日期/金额/数字等统一做集中处理\n            if(res.status === 0){\n                resolve(res.data);\n            }else{\n                // 通过配置可关闭错误提示\n                if(options.error)Message.error(res.message);\n                reject(res);\n            }\n        }).catch((error)=>{\n            Message.error(error.message)\n        }).finally(()=>{\n            loadingInstance.close();\n        })\n    })\n}\n// 封装GET请求\nfunction get(url,params,options){\n    return request(url,params,options,'get')\n}\n// 封装POST请求\nfunction post(url,params,options){\n    return request(url,params,options,'post')\n}\nexport default {\n    get,post\n}\n")])])]),s("p",[e._v("request.js主要针对axios做二次封装，目的同样是为了拦截所有前端请求，这样可以做前端loading效果、mock、错误拦截、错误弹框显示、数据适配、参数适配、环境适配等工作。")]),e._v(" "),s("blockquote",[s("p",[e._v("")]),e._v(" "),s("p",[e._v("接下来，我们看下如何使用")]),e._v(" "),s("p",[e._v("”")])]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("打开main.js")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 导入插件\nimport request from './api/request'\n// 在原型上扩展,这样不用在每个页面都导入request\nVue.prototype.request = request;\n")])])]),s("ul",[s("li",[s("strong",[e._v("请求调用")])])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  this.request.get('/login',{userName:'admin',userPwd:'admin'}).then((res={})=>{\n        // 此处只接收成功数据，失败数据不返回\n  }).catch(()=>{\n      // catch 可以不要，如果想要捕获异常，就加上去\n  })\n")])])]),s("p",[e._v("如果不做二次封装，我们很难实现以上功能点，这是在公司做了很多个中型后台系统后，总结出来的一些个人经验，我相信您看了之后，会有一些启发和帮助，如果有疑问或者不够完善可以留言或联系我，我进行修订。")])])}),[],!1,null,null,null);n.default=a.exports}}]);