(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{421:function(e,l,t){"use strict";t.r(l);var n=t(18),a=Object(n.a)({},(function(){var e=this,l=e.$createElement,t=e._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"array-原型方法源码实现大解密"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-原型方法源码实现大解密"}},[e._v("#")]),e._v(" Array 原型方法源码实现大解密")]),e._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://muyiy.cn/blog/6/6.3.html#%E5%BC%95%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://muyiy.cn/blog/6/6.3.html#引言"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"引言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[e._v("#")]),e._v(" 引言")]),e._v(" "),t("p",[e._v("几个常用数组方法的使用方式已经在【进阶 6-1 期】 中介绍过了，今天这篇文章主要看看 ECMA-262 规范中是如何定义这些方法的，并且在看完规范后我们用 JS 模拟实现下，透过源码探索一些底层的知识，希望本文对你有所帮助。")]),e._v(" "),t("h2",{attrs:{id:"array-prototype-map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-map"}},[e._v("#")]),e._v(" Array.prototype.map")]),e._v(" "),t("p",[e._v("完整的结构是 "),t("code",[e._v("Array.prototype.map(callbackfn[, thisArg])")]),e._v("，"),t("code",[e._v("map")]),e._v(" 函数接收两个参数，一个是必填项回调函数，另一个是可选项 callbackfn 函数执行时的 this 值。")]),e._v(" "),t("p",[t("code",[e._v("map")]),e._v(" 方法的主要功能就是把原数组中的每个元素按顺序执行一次  "),t("code",[e._v("callbackfn")]),e._v(" 函数，并且把所有返回的结果组合在一起生成一个新的数组，"),t("code",[e._v("map")]),e._v(" 方法的返回值就是这个新数组。")]),e._v(" "),t("p",[e._v("ECMA-262 规范文档实现如下。")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Let O be ? ToObject(this value).")])]),e._v(" "),t("li",[t("p",[e._v("Let len be ? LengthOfArrayLike(O).")])]),e._v(" "),t("li",[t("p",[e._v("If IsCallable(callbackfn) is false, throw a TypeError exception.")])]),e._v(" "),t("li",[t("p",[e._v("If thisArg is present, let T be thisArg; else let T be undefined.")])]),e._v(" "),t("li",[t("p",[e._v("Let A be ? ArraySpeciesCreate(O, len).")])]),e._v(" "),t("li",[t("p",[e._v("Let k be 0.")])]),e._v(" "),t("li",[t("p",[e._v("Repeat, while k < len")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Let Pk be ! ToString(k).")]),e._v(" "),t("li",[e._v("Let kPresent be ? HasProperty(O, Pk).")])])]),e._v(" "),t("li",[t("p",[e._v("If kPresent is true, then")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Let kValue be ? Get(O, Pk).")]),e._v(" "),t("li",[e._v("Let mappedValue be ? Call(callbackfn, T, « kValue, k, O »).")]),e._v(" "),t("li",[e._v("Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).")])])]),e._v(" "),t("li",[t("p",[e._v("Set k to k + 1.")])]),e._v(" "),t("li",[t("p",[e._v("Return A.")])])]),e._v(" "),t("p",[e._v("用 JS 来模拟实现，核心逻辑如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.map = function(callbackfn, thisArg) {\n  // 异常处理\n  if (this == null) {\n      throw new TypeError(\"Cannot read property 'map' of null or undefined\");\n  }\n  // Step 1. 转成数组对象，有 length 属性和 K-V 键值对\n  let O = Object(this)\n  // Step 2. 无符号右移 0 位，左侧用 0 填充，结果非负\n  let len = O.length >>> 0\n  // Step 3. callbackfn 不是函数时抛出异常\n  if (typeof callbackfn !== 'function') {\n    throw new TypeError(callbackfn + ' is not a function')\n  }\n  // Step 4.\n  let T = thisArg\n  // Step 5.\n  let A = new Array(len)\n  // Step 6.\n  let k = 0\n  // Step 7.\n  while(k < len) {\n    // Step 7.1、7.2、7.3\n    // 检查 O 及其原型链是否包含属性 k\n    if (k in O) {\n      // Step 7.3.1\n      let kValue = O[k]\n      // Step 7.3.2 执行 callbackfn 函数\n      // 传入 this, 当前元素 element, 索引 index, 原数组对象 O\n      let mappedValue = callbackfn.call(T, kValue, k, O)\n        // Step 7.3.3 返回结果赋值给新生成数组\n      A[k] = mappedValue\n    }\n    // Step 7.4\n    k++\n  }\n  // Step 8. 返回新数组\n  return A\n}\n\n// 代码亲测已通过\n")])])]),t("p",[e._v("看完代码其实挺简单，核心就是在一个 "),t("code",[e._v("while")]),e._v(" 循环中执行 "),t("code",[e._v("callbackfn")]),e._v("，并传入 4 个参数，回调函数具体的执行逻辑这里并不关心，只需要拿到返回结果并赋值给新数组就好了。")]),e._v(" "),t("p",[e._v("只有 O 及其原型链上包含属性 k 时才会执行  "),t("code",[e._v("callbackfn")]),e._v(" 函数，所以对于稀疏数组 empty 元素或者使用 "),t("code",[e._v("delete")]),e._v(" 删除后的索引则"),t("strong",[e._v("不会被调用")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [1, , 3, , 5]\nconsole.log(0 in arr) // true\ndelete arr[0]\nconsole.log(0 in arr) // false\nconsole.log(arr) // [empty × 2, 3, empty, 5]\narr.map(ele => {\n  console.log(ele) // 3, 5\n})\n")])])]),t("p",[t("code",[e._v("map")]),e._v(" 并不会修改原数组，不过也不是绝对的，如果你在 "),t("code",[e._v("callbackfn")]),e._v(" 中修改了原数组，那还是会改变。那问题来了，修改后会影响到 "),t("code",[e._v("map")]),e._v(" 自身的执行吗？")]),e._v(" "),t("p",[e._v("答案是会的！不过得区分以下几种情况。")]),e._v(" "),t("ul",[t("li",[e._v("原数组新增元素：因为 "),t("code",[e._v("map")]),e._v(" 第一次执行时 length 已经确定了，所以不影响")]),e._v(" "),t("li",[e._v("原数组修改元素：传递给 "),t("code",[e._v("callbackfn")]),e._v(" 的元素是 map 遍历到它们那一瞬间的值，所以可能受影响")]),e._v(" "),t("li",[e._v("修改当前索引之前的元素，不受影响")]),e._v(" "),t("li",[e._v("修改当前索引之后的元素，受影响")]),e._v(" "),t("li",[e._v("原数组删除元素：被删除的元素无法被访问到，所以可能受影响")]),e._v(" "),t("li",[e._v("删除当前索引之前的元素，已经访问过了，所以不受影响")]),e._v(" "),t("li",[e._v("删除当前索引之后的元素，受影响")])]),e._v(" "),t("p",[e._v("简单看下面几个例子，在 "),t("code",[e._v("callbackfn")]),e._v(" 中不要改变原数组，不然会有意想不到的情况发生。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 1、原数组新增元素，不受影响\nlet arr = [1, 2, 3]\nlet result = arr.map((ele, index, array) => {\n  array.push(4);\n  return ele * 2\n})\nconsole.log(result) \n// 2, 4, 6\n// ----------- 完美分割线 -----------\n\n\n// 2、原数组修改当前索引之前的元素，不受影响\nlet arr = [1, 2, 3]\nlet result = arr.map((ele, index, array) => {\n  if (index === 1) {\n    array[0] = 4\n  }\n  return ele * 2\n})\nconsole.log(result) \n// 2, 4, 6\n// ----------- 完美分割线 -----------\n\n\n// 3、原数组修改当前索引之后的元素，受影响\nlet arr = [1, 2, 3]\nlet result = arr.map((ele, index, array) => {\n  if (index === 1) {\n    array[2] = 4\n  }\n  return ele * 2\n})\nconsole.log(result) \n// 2, 4, 8\n")])])]),t("p",[e._v("最后来说说 "),t("code",[e._v("this")]),e._v("，源码中有这么一段 "),t("code",[e._v("callbackfn.call(T, kValue, k, O)")]),e._v("，其中  "),t("code",[e._v("T")]),e._v(" 就是 "),t("code",[e._v("thisArg")]),e._v(" 值，如果没有设置，那就是 undefined。")]),e._v(" "),t("p",[e._v("根据【进阶 3-3 期】  中对于 call 的解读，传入 undefined 时，非严格模式下指向 Window，严格模式下为 undefined。记住这时候回调函数不能用箭头函数，因为箭头函数是没有自己的 this 的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 1、传入 thisArg 但使用箭头函数\nlet name = \'Muyiy\'\nlet obj = {\n    name: \'Hello\',\n    callback: (ele) => {\n        return this.name + ele\n    }\n}\nlet arr = [1, 2, 3]\nlet result = arr.map(obj.callback, obj);\nconsole.log(result) \n// ["1", "2", "3"]，此时 this 指向 window\n// 那为啥不是 "Muyiy1" 这样呢，不急，第 3 步介绍\n// ----------- 完美分割线 -----------\n\n\n// 2、传入 thisArg，使用普通函数\nlet name = \'Muyiy\'\nlet obj = {\n    name: \'Hello\',\n    callback: function (ele) {\n        return this.name + ele\n    }\n}\nlet arr = [1, 2, 3]\nlet result = arr.map(obj.callback, obj);\nconsole.log(result) \n// ["Hello1", "Hello2", "Hello3"]，完美\n// ----------- 完美分割线 -----------\n\n// 3、不传入 thisArg，name 使用 let 声明\nlet name = \'Muyiy\'\nlet obj = {\n    name: \'Hello\',\n    callback: function (ele) {\n        return this.name + ele\n    }\n}\nlet arr = [1, 2, 3]\nlet result = arr.map(obj.callback);\nconsole.log(result)\n// ["1", "2", "3"]\n// 为什么呢，因为 let 和 const 声明的变量不会挂载到 window 上\n// ----------- 完美分割线 -----------\n\n// 4、不传入 thisArg，name 使用 var 声明\nvar name = \'Muyiy\'\nlet obj = {\n    name: \'Hello\',\n    callback: function (ele) {\n        return this.name + ele\n    }\n}\nlet arr = [1, 2, 3]\nlet result = arr.map(obj.callback);\nconsole.log(result)\n// ["Muyiy1", "Muyiy2", "Muyiy3"]\n// 看看，改成 var 就好了\n// ----------- 完美分割线 -----------\n\n// 5、严格模式\n\'use strict\'\nvar name = \'Muyiy\'\nlet obj = {\n    name: \'Hello\',\n    callback: function (ele) {\n        return this.name + ele\n    }\n}\nlet arr = [1, 2, 3]\nlet result = arr.map(obj.callback);\nconsole.log(result)\n// TypeError: Cannot read property \'name\' of undefined\n// 因为严格模式下 this 指向 undefined\n')])])]),t("p",[e._v("上面这部分实操代码介绍了 5 种情况，分别是传入 thisArg 两种情况，非严格模式下两种情况，以及严格模式下一种情况。这部分的知识在之前的文章中都有介绍过，这里主要是温故下。如果这块知识不熟悉，可以详细看我的 博客")]),e._v(" "),t("h2",{attrs:{id:"array-prototype-filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-filter"}},[e._v("#")]),e._v(" Array.prototype.filter")]),e._v(" "),t("p",[e._v("完整的结构是 "),t("code",[e._v("Array.prototype.filter(callbackfn[, thisArg])")]),e._v("，和 "),t("code",[e._v("map")]),e._v(" 是一样的。")]),e._v(" "),t("p",[t("code",[e._v("filter")]),e._v(" 字如其名，它的主要功能就是过滤，"),t("code",[e._v("callbackfn")]),e._v(" 执行结果如果是 true 就返回当前元素，false 则不返回，返回的所有元素组合在一起生成新数组，并返回。如果没有任何元素通过测试，则返回空数组。")]),e._v(" "),t("p",[e._v("所以这部分源码相比 "),t("code",[e._v("map")]),e._v(" 而言，多了一步判断 "),t("code",[e._v("callbackfn")]),e._v(" 的返回值。")]),e._v(" "),t("p",[e._v("ECMA-262 规范文档实现如下。")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Let O be ? ToObject(this value).")])]),e._v(" "),t("li",[t("p",[e._v("Let len be ? LengthOfArrayLike(O).")])]),e._v(" "),t("li",[t("p",[e._v("If IsCallable(callbackfn) is false, throw a TypeError exception.")])]),e._v(" "),t("li",[t("p",[e._v("If thisArg is present, let T be thisArg; else let T be undefined.")])]),e._v(" "),t("li",[t("p",[e._v("Let A be ? ArraySpeciesCreate(O, 0).")])]),e._v(" "),t("li",[t("p",[e._v("Let k be 0.")])]),e._v(" "),t("li",[t("p",[e._v("Let to be 0.")])]),e._v(" "),t("li",[t("p",[e._v("Repeat, while k < len")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Let kValue be ? Get(O, Pk).")]),e._v(" "),t("li",[e._v("Let selected be ! ToBoolean(? Call(callbackfn, T, « kValue, k, O »)).")]),e._v(" "),t("li",[e._v("If selected is true, then")]),e._v(" "),t("li",[e._v("Set k to k + 1.")]),e._v(" "),t("li",[e._v("Perform ? CreateDataPropertyOrThrow(A, ! ToString(to), kValue).")]),e._v(" "),t("li",[e._v("Set to to to + 1.")]),e._v(" "),t("li",[e._v("Let Pk be ! ToString(k).")]),e._v(" "),t("li",[e._v("Let kPresent be ? HasProperty(O, Pk).")]),e._v(" "),t("li",[e._v("If kPresent is true, then")])])]),e._v(" "),t("li",[t("p",[e._v("Return A.")])])]),e._v(" "),t("p",[e._v("用 JS 来模拟实现，核心逻辑如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.filter = function(callbackfn, thisArg) {\n  // 异常处理\n  if (this == null) {\n      throw new TypeError(\"Cannot read property 'map' of null or undefined\");\n  }\n  if (typeof callbackfn !== 'function') {\n    throw new TypeError(callbackfn + ' is not a function')\n  }\n\n  let O = Object(this), len = O.length >>> 0,\n      T = thisArg, A = new Array(len), k = 0\n  // 新增，返回数组的索引\n  let to = 0\n\n  while(k < len) {\n    if (k in O) {\n      let kValue = O[k]\n      // 新增\n      if (callbackfn.call(T, kValue, k, O)) {\n        A[to++] = kValue;\n      }\n    }\n    k++\n  }\n\n  // 新增，修改 length，初始值为 len\n  A.length = to;\n  return A\n}\n\n// 代码亲测已通过\n")])])]),t("p",[e._v("看懂 "),t("code",[e._v("map")]),e._v(" 再看这个实现就简单多了，改动点在于判断 "),t("code",[e._v("callbackfn")]),e._v(" 返回值，新增索引 "),t("code",[e._v("to")]),e._v("，这样主要避免使用 "),t("code",[e._v("k")]),e._v(" 时生成空元素，并在返回之前修改 "),t("code",[e._v("length")]),e._v(" 值。")]),e._v(" "),t("p",[e._v("这部分源码还是挺有意思的，惊喜点在于 "),t("code",[e._v("A.length = to")]),e._v("，之前还没用过。")]),e._v(" "),t("h2",{attrs:{id:"array-prototype-reduce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-reduce"}},[e._v("#")]),e._v(" Array.prototype.reduce")]),e._v(" "),t("p",[t("code",[e._v("reduce")]),e._v(" 可以理解为「归一」，意为海纳百川，万剑归一，完整的结构是 "),t("code",[e._v("Array.prototype.reduce(callbackfn[, initialValue])")]),e._v("，这里第二个参数并不是 thisArg 了，而是初始值 "),t("code",[e._v("initialValue")]),e._v("，关于初始值之前有介绍过。")]),e._v(" "),t("ul",[t("li",[e._v("如果没有提供 "),t("code",[e._v("initialValue")]),e._v("，那么第一次调用 "),t("code",[e._v("callback")]),e._v(" 函数时，"),t("code",[e._v("accumulator")]),e._v("使用原数组中的第一个元素，"),t("code",[e._v("currentValue")]),e._v(" 即是数组中的第二个元素。")]),e._v(" "),t("li",[e._v("如果提供了 "),t("code",[e._v("initialValue")]),e._v("，"),t("code",[e._v("accumulator")]),e._v(" 将使用这个初始值，"),t("code",[e._v("currentValue")]),e._v("使用原数组中的第一个元素。")]),e._v(" "),t("li",[e._v("在没有初始值的空数组上调用 "),t("code",[e._v("reduce")]),e._v(" 将报错。")])]),e._v(" "),t("p",[e._v("ECMA-262 规范文档实现如下。")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Let O be ? ToObject(this value).")])]),e._v(" "),t("li",[t("p",[e._v("Let len be ? LengthOfArrayLike(O).")])]),e._v(" "),t("li",[t("p",[e._v("If IsCallable(callbackfn) is false, throw a TypeError exception.")])]),e._v(" "),t("li",[t("p",[e._v("If len is 0 and initialValue is not present, throw a TypeError exception.")])]),e._v(" "),t("li",[t("p",[e._v("Let k be 0.")])]),e._v(" "),t("li",[t("p",[e._v("Let accumulator be undefined.")])]),e._v(" "),t("li",[t("p",[e._v("If initialValue is present, then")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Set accumulator to initialValue.")])])]),e._v(" "),t("li",[t("p",[e._v("Else,")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Let Pk be ! ToString(k).")]),e._v(" "),t("li",[e._v("Set kPresent to ? HasProperty(O, Pk).")]),e._v(" "),t("li",[e._v("If kPresent is true, then")]),e._v(" "),t("li",[e._v("Set k to k + 1.")]),e._v(" "),t("li",[e._v("Set accumulator to ? Get(O, Pk).")]),e._v(" "),t("li",[e._v("Let kPresent be false.")]),e._v(" "),t("li",[e._v("Repeat, while kPresent is false and k < len")]),e._v(" "),t("li",[e._v("If kPresent is false, throw a TypeError exception.")])])]),e._v(" "),t("li",[t("p",[e._v("Repeat, while k < len")])]),e._v(" "),t("li",[t("ol",[t("li",[e._v("Let kValue be ? Get(O, Pk).")]),e._v(" "),t("li",[e._v("Set accumulator to ? Call(callbackfn, undefined, « accumulator, kValue, k, O »).")]),e._v(" "),t("li",[e._v("Let Pk be ! ToString(k).")]),e._v(" "),t("li",[e._v("Let kPresent be ? HasProperty(O, Pk).")]),e._v(" "),t("li",[e._v("If kPresent is true, then")]),e._v(" "),t("li",[e._v("Set k to k + 1.")])])]),e._v(" "),t("li",[t("p",[e._v("Return accumulator.")])])]),e._v(" "),t("p",[e._v("用 JS 来模拟实现，核心逻辑如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.reduce = function(callbackfn, initialValue) {\n  // 异常处理\n  if (this == null) {\n      throw new TypeError(\"Cannot read property 'map' of null or undefined\");\n  }\n  if (typeof callbackfn !== 'function') {\n    throw new TypeError(callbackfn + ' is not a function')\n  }\n  let O = Object(this)\n  let len = O.length >>> 0\n  let k = 0, accumulator\n\n  // 新增\n  if (initialValue) {\n    accumulator = initialValue\n  } else {\n    // Step 4.\n    if (len === 0) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    // Step 8.\n    let kPresent = false\n    while(!kPresent && (k < len)) {\n      kPresent = k in O\n      if (kPresent) {\n        accumulator = O[k] \n      }\n      k++\n    }\n  }\n\n  while(k < len) {\n    if (k in O) {\n      let kValue = O[k]\n      accumulator = callbackfn.call(undefined, accumulator, kValue, k, O)\n    }\n    k++\n  }\n  return accumulator\n}\n\n// 代码亲测已通过\n")])])]),t("p",[e._v("这部分源码主要多了对于 "),t("code",[e._v("initialValue")]),e._v(" 的处理，有初始值时比较简单，即 "),t("code",[e._v("accumulator = initialValue")]),e._v("，"),t("code",[e._v("kValue = O[0]")]),e._v("。")]),e._v(" "),t("p",[e._v("无初始值处理在 Step 8，循环判断当 O 及其原型链上存在属性 k 时，"),t("code",[e._v("accumulator = O[k]")]),e._v(" 并退出循环，因为 "),t("code",[e._v("k++")]),e._v("，所以 "),t("code",[e._v("kValue = O[k++]")]),e._v("。")]),e._v(" "),t("p",[e._v("更多的数组方法有 "),t("code",[e._v("find")]),e._v("、"),t("code",[e._v("findIndex")]),e._v("、"),t("code",[e._v("forEach")]),e._v(" 等，其源码实现也是大同小异，无非就是在 "),t("code",[e._v("callbackfn.call")]),e._v(" 这部分做些处理，有兴趣的可以看看 TC39 和 MDN 官网，参考部分链接直达。")]),e._v(" "),t("h2",{attrs:{id:"注意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[e._v("#")]),e._v(" 注意")]),e._v(" "),t("p",[t("code",[e._v("forEach")]),e._v(" 的源码和 "),t("code",[e._v("map")]),e._v(" 很相同，在 map 的源码基础上做些改造就是啦。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Array.prototype.forEach = function(callbackfn, thisArg) {\n  // 相同\n  ...\n  while(k < len) {\n    if (k in O) {\n      let kValue = O[k]\n\n      // 这部分是 map\n      // let mappedValue = callbackfn.call(T, kValue, k, O)\n      // A[k] = mappedValue\n\n      // 这部分是 forEach\n      callbackfn.call(T, kValue, k, O)\n    }\n    k++\n  }\n  // 返回 undefined\n  // return undefined\n}\n")])])]),t("p",[e._v("可以看到，不同之处在于不处理 "),t("code",[e._v("callbackfn")]),e._v(" 执行的结果，也不返回。")]),e._v(" "),t("p",[e._v("特意指出来是因为在此之前看到过一种错误的说法，叫做「forEach 会跳过空，但是 map 不跳过」")]),e._v(" "),t("p",[e._v("为什么说 "),t("code",[e._v("map")]),e._v(" 不跳过呢，因为原始数组有 empty 元素时，map 返回的结果也有 empty 元素，所以不跳过，但是这种说法并不正确。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [1, , 3, , 5]\nconsole.log(arr) // [1, empty, 3, empty, 5]\n\nlet result = arr.map(ele => {\n  console.log(ele) // 1, 3, 5\n  return ele\n})\nconsole.log(result) // [1, empty, 3, empty, 5]\n")])])]),t("p",[e._v("看 "),t("code",[e._v("ele")]),e._v(" 输出就会明白 map 也是跳空的，原因就在于源码中的 "),t("code",[e._v("k in O")]),e._v("，这里是检查 O 及其原型链是否包含属性 k，所以有的实现中用 "),t("code",[e._v("hasOwnProperty")]),e._v(" 也是不正确的。")]),e._v(" "),t("p",[e._v("另外 "),t("code",[e._v("callbackfn")]),e._v(" 中不可以使用 break 跳出循环，是因为 break 只能跳出循环，而 "),t("code",[e._v("callbackfn")]),e._v(" 并不是循环体。如果有类似的需求可以使用"),t("code",[e._v("for..of")]),e._v("、"),t("code",[e._v("for..in")]),e._v("、 "),t("code",[e._v("some")]),e._v("、"),t("code",[e._v("every")]),e._v(" 等。")]),e._v(" "),t("p",[t("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),t("p",[e._v("熟悉源码之后很多问题就迎刃而解啦，感谢阅读。")]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[e._v("TC39 Array.prototype.map")]),e._v(" "),t("li",[e._v("TC39 Array.prototype.filter")]),e._v(" "),t("li",[e._v("TC39 Array.prototype.reduce")]),e._v(" "),t("li",[e._v("MDN Array.prototype.map")]),e._v(" "),t("li",[e._v("MDN Array.prototype.filter")]),e._v(" "),t("li",[e._v("MDN Array.prototype.reduce")])]),e._v(" "),t("h3",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("p",[t("code",[e._v("[1]")]),e._v(" 【进阶 6-1 期】: "),t("em",[e._v("https://www.muyiy.cn/blog/6/6.1.html")]),e._v(" "),t("code",[e._v("[2]")]),e._v(" 【进阶 3-3 期】: "),t("em",[e._v("https://muyiy.cn/blog/3/3.3.html")]),e._v(" "),t("code",[e._v("[3]")]),e._v(" 博客: "),t("em",[e._v("https://muyiy.cn/blog/")]),e._v(" "),t("code",[e._v("[4]")]),e._v(" TC39 Array.prototype.map: "),t("em",[e._v("https://tc39.es/ecma262/#sec-array.prototype.map")]),e._v(" "),t("code",[e._v("[5]")]),e._v(" TC39 Array.prototype.filter: "),t("em",[e._v("https://tc39.es/ecma262/#sec-array.prototype.filter")]),e._v(" "),t("code",[e._v("[6]")]),e._v(" TC39 Array.prototype.reduce: "),t("em",[e._v("https://tc39.es/ecma262/#sec-array.prototype.reduce")]),e._v(" "),t("code",[e._v("[7]")]),e._v(" MDN Array.prototype.map: "),t("em",[e._v("https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map")]),e._v(" "),t("code",[e._v("[8]")]),e._v(" MDN Array.prototype.filter: "),t("em",[e._v("https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter")]),e._v(" "),t("code",[e._v("[9]")]),e._v(" MDN Array.prototype.reduce: "),t("em",[e._v("https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce")])])])}),[],!1,null,null,null);l.default=a.exports}}]);