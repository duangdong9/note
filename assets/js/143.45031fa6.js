(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{553:function(e,t,n){"use strict";n.r(t);var a=n(18),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"文件下载-搞懂这9种场景就够了"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件下载-搞懂这9种场景就够了"}},[e._v("#")]),e._v(" 文件下载，搞懂这9种场景就够了")]),e._v(" "),n("blockquote",[n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/R43JRj1e3XWFsxK5fQ30Bw",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://mp.weixin.qq.com/s/R43JRj1e3XWFsxK5fQ30Bw"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("一般在我们工作中，主要会涉及到 9 种文件下载的场景，每一种场景背后都使用不同的技术，其中也有很多细节需要我们额外注意。今天阿宝哥就来带大家总结一下这 9 种场景，让大家能够轻松地应对各种下载场景。阅读本文后，你将会了解以下的内容：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruRbQVsfnaI8hPV253hnNmWCTrbAJcricI4XqbfspQkb2Ho2HuQm4Rdtw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("在浏览器端处理文件的时候，我们经常会用到 Blob 。比如图片本地预览、图片压缩、大文件分块上传及文件下载。在浏览器端文件下载的场景中，比如我们今天要讲到的 "),n("strong",[e._v("a 标签下载")]),e._v("、"),n("strong",[e._v("showSaveFilePicker API 下载")]),e._v("、"),n("strong",[e._v("Zip 下载")]),e._v(" 等场景中，都会使用到 Blob ，所以我们有必要在学习具体应用前，先掌握它的相关知识，这样可以帮助我们更好地了解示例代码。")]),e._v(" "),n("h3",{attrs:{id:"一、基础知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、基础知识"}},[e._v("#")]),e._v(" 一、基础知识")]),e._v(" "),n("h4",{attrs:{id:"_1-1-了解-blob"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-了解-blob"}},[e._v("#")]),e._v(" 1.1 了解 Blob")]),e._v(" "),n("p",[e._v("Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。"),n("strong",[e._v("在 JavaScript 中 Blob 类型的对象表示一个不可变、原始数据的类文件对象。")]),e._v(" 它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 用于数据操作。")]),e._v(" "),n("p",[n("code",[e._v("Blob")]),e._v(" 对象由一个可选的字符串 "),n("code",[e._v("type")]),e._v("（通常是 MIME 类型）和 "),n("code",[e._v("blobParts")]),e._v(" 组成：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}}),e._v("在 JavaScript 中你可以通过 Blob 的构造函数来创建 Blob 对象，Blob 构造函数的语法如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const aBlob = new Blob(blobParts, options);\n")])])]),n("p",[e._v("相关的参数说明如下：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。")])]),e._v(" "),n("li",[n("p",[e._v("options：一个可选的对象，包含以下两个属性：")])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("type —— 默认值为 "),n("code",[e._v('""')]),e._v("，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。")]),e._v(" "),n("li",[e._v("endings —— 默认值为 "),n("code",[e._v('"transparent"')]),e._v("，用于指定包含行结束符 "),n("code",[e._v("\\n")]),e._v(" 的字符串如何被写入。 它是以下两个值中的一个： "),n("code",[e._v('"native"')]),e._v("，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 "),n("code",[e._v('"transparent"')]),e._v("，代表会保持 blob 中保存的结束符不变。")])])])]),e._v(" "),n("h4",{attrs:{id:"_1-2-了解-blob-url"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-了解-blob-url"}},[e._v("#")]),e._v(" 1.2 了解 Blob URL")]),e._v(" "),n("p",[e._v("Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像、下载二进制数据链接等的 URL 源。在浏览器中，我们使用 "),n("code",[e._v("URL.createObjectURL")]),e._v(" 方法来创建 Blob URL，该方法接收一个 "),n("code",[e._v("Blob")]),e._v(" 对象，并为其创建一个唯一的 URL，其形式为 "),n("code",[e._v("blob:<origin>/<uuid>")]),e._v("，对应的示例如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("blob:http://localhost:3000/53acc2b6-f47b-450f-a390-bf0665e04e59\n")])])]),n("p",[e._v("浏览器内部为每个通过 "),n("code",[e._v("URL.createObjectURL")]),e._v(" 生成的 URL 存储了一个 "),n("strong",[e._v("URL → Blob")]),e._v(" 映射。因此，此类 URL 较短，但可以访问 "),n("code",[e._v("Blob")]),e._v("。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 "),n("code",[e._v("<img>")]),e._v("、"),n("code",[e._v("<a>")]),e._v(" 中的 "),n("code",[e._v("Blob")]),e._v("，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。")]),e._v(" "),n("p",[e._v("上述的 Blob URL 看似很不错，但实际上它也有副作用。 "),n("strong",[e._v("虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放")]),e._v("。但是，如果应用程序寿命很长，那么 Blob 在短时间内将无法被浏览器释放。因此，如果你创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。")]),e._v(" "),n("p",[e._v("针对这个问题，你可以调用 "),n("code",[e._v("URL.revokeObjectURL(url)")]),e._v(" 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。")]),e._v(" "),n("p",[e._v("现在你已经了解了 Blob 和 Blob URL，如果你还意犹未尽，想深入理解 Blob 的话，可以阅读 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247484522&idx=1&sn=7028aa65a4dec0f2d0cb847838703bc3&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("你不知道的 Blob"),n("OutboundLink")],1),e._v(" 这篇文章。下面我们开始介绍客户端文件下载的场景。")]),e._v(" "),n("p",[e._v("随着 Web 技术的不断发展，浏览器的功能也越来越强大。这些年出现了很多在线 Web 设计工具，比如在线 PS、在线海报设计器或在线自定义表单设计器等。这些 Web 设计器允许用户在完成设计之后，把生成的文件保存到本地，其中有一部分设计器就是利用浏览器提供的 Web API 来实现客户端文件下载。下面阿宝哥先来介绍客户端下载中，最常见的 "),n("strong",[e._v("a 标签下载")]),e._v("方案。")]),e._v(" "),n("h3",{attrs:{id:"二、a-标签下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、a-标签下载"}},[e._v("#")]),e._v(" 二、a 标签下载")]),e._v(" "),n("p",[n("strong",[e._v("html")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<h3>a 标签下载示例</h3>\n<div>\n  <img src="../images/body.png" />\n  <img src="../images/eyes.png" />\n  <img src="../images/mouth.png" />\n</div>\n<img id="mergedPic" src="http://via.placeholder.com/256" />\n<button onclick="merge()">图片合成</button>\n<button onclick="download()">图片下载</button>\n')])])]),n("p",[e._v("在以上代码中，我们通过 "),n("code",[e._v("img")]),e._v(" 标签引用了以下 3 张素材：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("当用户点击 "),n("strong",[e._v("图片合成")]),e._v(" 按钮时，会将合成的图片显示在 "),n("code",[e._v("img#mergedPic")]),e._v(" 容器中。在图片成功合成之后，用户可以通过点击 "),n("strong",[e._v("图片下载")]),e._v(" 按钮把已合成的图片下载到本地。对应的操作流程如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("由上图可知，整体的操作流程相对简单。接下来，我们来看一下 "),n("strong",[e._v("图片合成")]),e._v(" 和 "),n("strong",[e._v("图片下载")]),e._v(" 的实现逻辑。")]),e._v(" "),n("p",[n("strong",[e._v("js")])]),e._v(" "),n("p",[e._v("图片合成的功能，阿宝哥是直接使用 Github 上 merge-images 这个第三方库来实现。利用该库提供的 "),n("code",[e._v("mergeImages(images, [options])")]),e._v(" 方法，我们可以轻松地实现图片合成的功能。调用该方法后，会返回一个 Promise 对象，当异步操作完成后，合成的图片会以 Data URLs 的格式返回。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const mergePicEle = document.querySelector("#mergedPic");\nconst images = ["/body.png", "/eyes.png", "/mouth.png"].map(\n  (path) => "../images" + path\n);\nlet imgDataUrl = null;\n\nasync function merge() {\n  imgDataUrl = await mergeImages(images);\n  mergePicEle.src = imgDataUrl;\n}\n')])])]),n("p",[e._v("而图片下载的功能是借助 "),n("code",[e._v("dataUrlToBlob")]),e._v(" 和 "),n("code",[e._v("saveFile")]),e._v(" 这两个函数来实现。它们分别用于实现 "),n("strong",[e._v("Data URLs => Blob")]),e._v(" 的转换和文件的保存，具体的代码如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function dataUrlToBlob(base64, mimeType) {\n  let bytes = window.atob(base64.split(",")[1]);\n  let ab = new ArrayBuffer(bytes.length);\n  let ia = new Uint8Array(ab);\n  for (let i = 0; i < bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i);\n  }\n  return new Blob([ab], { type: mimeType });\n}\n\n// 保存文件\nfunction saveFile(blob, filename) {\n  const a = document.createElement("a");\n  a.download = filename;\n  a.href = URL.createObjectURL(blob);\n  a.click();\n  URL.revokeObjectURL(a.href)\n}\n')])])]),n("p",[e._v("因为本文的主题是介绍文件下载，所以我们来重点分析 "),n("code",[e._v("saveFile")]),e._v(" 函数。在该函数内部，我们使用了 "),n("strong",[e._v("HTMLAnchorElement.download")]),e._v(" 属性，该属性值表示下载文件的名称。如果该名称不是操作系统的有效文件名，浏览器将会对其进行调整。此外，该属性的作用是表明链接的资源将被下载，而不是显示在浏览器中。")]),e._v(" "),n("p",[e._v("需要注意的是，"),n("code",[e._v("download")]),e._v(" 属性存在兼容性问题，比如 IE 11 及以下的版本不支持该属性，具体如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("（图片来源：https://caniuse.com/download）")]),e._v(" "),n("p",[e._v("当设置好 a 元素的 "),n("code",[e._v("download")]),e._v(" 属性之后，我们会调用 "),n("code",[e._v("URL.createObjectURL")]),e._v(" 方法来创建 Object URL，并把返回的 URL 赋值给 a 元素的 "),n("code",[e._v("href")]),e._v(" 属性。接着通过调用 a 元素的 "),n("code",[e._v("click")]),e._v(" 方法来触发文件的下载操作，最后还会调用一次 "),n("code",[e._v("URL.revokeObjectURL")]),e._v(" 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。")]),e._v(" "),n("p",[e._v("关于 "),n("strong",[e._v("a 标签下载")]),e._v(" 的内容就介绍到这，下面我们来介绍如何使用新的 Web API —— "),n("code",[e._v("showSaveFilePicker")]),e._v(" 实现文件下载。")]),e._v(" "),n("blockquote",[n("p",[e._v("a 标签下载示例：a-tag")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/a-tag")])]),e._v(" "),n("h3",{attrs:{id:"三、showsavefilepicker-api-下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、showsavefilepicker-api-下载"}},[e._v("#")]),e._v(" 三、showSaveFilePicker API 下载")]),e._v(" "),n("p",[e._v("showSaveFilePicker API 是 "),n("code",[e._v("Window")]),e._v(" 接口中定义的方法，调用该方法后会显示允许用户选择保存路径的文件选择器。该方法的签名如下所示：")]),e._v(" "),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let FileSystemFileHandle = Window.showSaveFilePicker(options);\n")])])])]),e._v(" "),n("p",[e._v("showSaveFilePicker 方法支持一个对象类型的可选参数，可包含以下属性：")]),e._v(" "),n("ul",[n("li",[n("p",[n("code",[e._v("excludeAcceptAllOption")]),e._v("：布尔类型，默认值为 "),n("code",[e._v("false")]),e._v("。默认情况下，选择器应包含一个不应用任何文件类型过滤器的选项（由下面的 "),n("code",[e._v("types")]),e._v(" 选项启用）。将此选项设置为 "),n("code",[e._v("true")]),e._v(" 意味着 "),n("code",[e._v("types")]),e._v(" 选项不可用。")])]),e._v(" "),n("li",[n("p",[n("code",[e._v("types")]),e._v("：数组类型，表示允许保存的文件类型列表。数组中的每一项是包含以下属性的配置对象：")])]),e._v(" "),n("li",[n("ul",[n("li",[n("code",[e._v("description（可选）")]),e._v("：用于描述允许保存文件类型类别。")]),e._v(" "),n("li",[n("code",[e._v("accept")]),e._v("：是一个对象，该对象的 "),n("code",[e._v("key")]),e._v(" 是 MIME 类型，值是文件扩展名列表。")])])])]),e._v(" "),n("p",[e._v("调用 showSaveFilePicker 方法之后，会返回一个 FileSystemFileHandle 对象。有了该对象，你就可以调用该对象上的方法来操作文件。比如调用该对象上的 createWritable 方法之后，就会返回 FileSystemWritableFileStream 对象，就可以把数据写入到文件中。具体的使用方式如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('async function saveFile(blob, filename) {\n  try {\n    const handle = await window.showSaveFilePicker({\n      suggestedName: filename,\n      types: [\n        {\n          description: "PNG file",\n          accept: {\n            "image/png": [".png"],\n          },\n        },\n        {\n          description: "Jpeg file",\n          accept: {\n            "image/jpeg": [".jpeg"],\n          },\n         },\n      ],\n     });\n    const writable = await handle.createWritable();\n    await writable.write(blob);\n    await writable.close();\n    return handle;\n  } catch (err) {\n     console.error(err.name, err.message);\n  }\n}\n\nfunction download() {\n  if (!imgDataUrl) {\n    alert("请先合成图片");\n    return;\n  }\n  const imgBlob = dataUrlToBlob(imgDataUrl, "image/png");\n  saveFile(imgBlob, "face.png");\n}\n')])])]),n("p",[e._v("当你使用以上更新后的 "),n("code",[e._v("saveFile")]),e._v(" 函数，来保存已合成的图片时，会显示以下保存文件选择器：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruoaM2spbCVGicI8oAjbMwxRxr3S4pGVIpAGVibCC4vFKaibrkSUkZeyrYQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("由上图可知，相比 "),n("strong",[e._v("a 标签下载")]),e._v(" 的方式，showSaveFilePicker API 允许你选择文件的下载目录、选择文件的保存格式和更改存储的文件名称。看到这里是不是觉得 showSaveFilePicker API 功能挺强大的，不过可惜的是该 API 目前的兼容性还不是很好，具体如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruibAfheTAklQBHdibHhr50xPzqJXWcXMYdx2rib2yVorH2icZiaNCp25A2Lg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("（图片来源：https://caniuse.com/?search=showSaveFilePicker）")]),e._v(" "),n("p",[e._v("其实 showSaveFilePicker 是 File System Access API 中定义的方法，除了 showSaveFilePicker 之外，还有 showOpenFilePicker 和 showDirectoryPicker 等方法。如果你想在实际项目中使用这些 API 的话，可以考虑使用 "),n("strong",[e._v("GoogleChromeLabs")]),e._v(" 开源的 browser-fs-access 这个库，该库可以让你在支持平台上更方便地使用 File System Access API，对于不支持的平台会自动降级使用 "),n("code",[e._v('<input type="file">')]),e._v(" 和 "),n("code",[e._v("<a download>")]),e._v(" 的方式。")]),e._v(" "),n("p",[e._v("可能大家对 browser-fs-access 这个库会比较陌生，但是如果换成是 FileSaver.js  这个库的话，应该就比较熟悉了。接下来，我们来介绍如何利用 FileSaver.js 这个库实现客户端文件下载。")]),e._v(" "),n("blockquote",[n("p",[e._v("showSaveFilePicker API 下载示例：save-file-picker")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/save-file-picker")])]),e._v(" "),n("h3",{attrs:{id:"四、filesaver-下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、filesaver-下载"}},[e._v("#")]),e._v(" 四、FileSaver 下载")]),e._v(" "),n("p",[e._v("FileSaver.js 是在客户端保存文件的解决方案，非常适合在客户端上生成文件的 Web 应用程序。它是 HTML5 版本的 saveAs() FileSaver 实现，支持大多数主流的浏览器，其兼容性如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruiasMiaW6jTgMT8ynYZ1ES1P4EvFDBIibXrVZN1ldw6BjP5Pndiadiap8QsQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("（图片来源：https://github.com/eligrey/FileSaver.js）")]),e._v(" "),n("p",[e._v("在引入 FileSaver.js 这个库之后，我们就可以使用它提供的 "),n("code",[e._v("saveAs")]),e._v(" 方法来保存文件。该方法对应的签名如下所示：")]),e._v(" "),n("blockquote",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("FileSaver saveAs(\n Blob/File/Url, \n optional DOMString filename, \n optional Object { autoBom }\n)\n")])])])]),e._v(" "),n("p",[e._v("saveAs 方法支持 3 个参数，第 1 个参数表示它支持 "),n("code",[e._v("Blob/File/Url")]),e._v(" 三种类型，第 2 个参数表示文件名（可选），而第 3 个参数表示配置对象（可选）。如果你需要 FlieSaver.js 自动提供 Unicode 文本编码提示（参考：字节顺序标记），则需要设置 "),n("code",[e._v("{ autoBom: true}")]),e._v("。")]),e._v(" "),n("p",[e._v("了解完 saveAs 方法之后，我们来举 3 个具体的使用示例：")]),e._v(" "),n("p",[n("strong",[e._v("1. 保存文本")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let blob = new Blob(["大家好，我是阿宝哥!"], { type: "text/plain;charset=utf-8" });\nsaveAs(blob, "hello.txt");\n')])])]),n("p",[n("strong",[e._v("2. 保存线上资源")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('saveAs("https://httpbin.org/image", "image.jpg");\n')])])]),n("p",[e._v("如果下载的 URL 地址与当前站点是同域的，则将使用 "),n("code",[e._v("a[download]")]),e._v(" 方式下载。否则，会先使用 "),n("strong",[e._v("同步的 HEAD 请求")]),e._v(" 来判断是否支持 CORS 机制，若支持的话，将进行数据下载并使用 Blob URL 实现文件下载。如果不支持 CORS 机制的话，将会尝试使用 "),n("code",[e._v("a[download]")]),e._v("方式下载。")]),e._v(" "),n("p",[e._v("标准的 W3C File API Blob 接口并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 Blob.js 来解决兼容性问题。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ruCuOj2S2NNwtV4WCrYTkp0Vbpmsb2W0kl7Oq3aQBbH8aQMpw0katAQg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("（图片来源：https://caniuse.com/?search=blob）")]),e._v(" "),n("p",[n("strong",[e._v("3. 保存 canvas 画布内容")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let canvas = document.getElementById("my-canvas");\ncanvas.toBlob(function(blob) {\n  saveAs(blob, "abao.png");\n});\n')])])]),n("p",[e._v("需要注意的是 "),n("code",[e._v("canvas.toBlob()")]),e._v(" 方法并非在所有浏览器中都可用，对于这个问题，你可以考虑使用 canvas-toBlob.js 来解决兼容性问题。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/jQmwTIFl1V3HLqFKg1vzTdm8KOKE95ru0najESdoiaUyt2XEWlYXibrAibuv4F4D5fOeMd90KzIDXu96AibYEOGjUA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),e._v(" "),n("p",[e._v("（图片来源：https://caniuse.com/?search=toBlob）")]),e._v(" "),n("p",[e._v("介绍完 saveAs 方法的使用示例之后，我们来更新前面示例中的 "),n("code",[e._v("download")]),e._v(" 方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function download() {\n  if (!imgDataUrl) {\n    alert("请先合成图片");\n    return;\n  }\n  const imgBlob = dataUrlToBlob(imgDataUrl, "image/png");\n  saveAs(imgBlob, "face.png");\n}\n')])])]),n("p",[e._v("很明显，使用 saveAs 方法之后，下载已合成的图片就很简单了。如果你对 FileSaver.js 的工作原理感兴趣的话，可以阅读 聊一聊 15.5K 的 FileSaver，是如何工作的？ 这篇文章。前面介绍的场景都是直接下载单个文件，其实我们也可以在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包并下载到本地。")]),e._v(" "),n("blockquote",[n("p",[e._v("FileSaver 下载示例：file-saver")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/file-saver")])]),e._v(" "),n("h3",{attrs:{id:"五、zip-下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#五、zip-下载"}},[e._v("#")]),e._v(" 五、Zip 下载")]),e._v(" "),n("p",[e._v("在 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247493294&idx=1&sn=85642a71feae9f1df2abf1110f721054&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("文件上传，搞懂这8种场景就够了"),n("OutboundLink")],1),e._v(" 这篇文章中，阿宝哥介绍了如何利用 JSZip 这个库提供的 API，把待上传目录下的所有文件压缩成 ZIP 文件，然后再把生成的 ZIP 文件上传到服务器。同样，利用 JSZip 这个库，我们可以实现在客户端同时下载多个文件，然后把已下载的文件压缩成 Zip 包，并下载到本地的功能。对应的操作流程如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("在以上 Gif 图中，阿宝哥演示了把 3 张素材图，打包成 Zip 文件并下载到本地的过程。接下来，我们来介绍如何使用 JSZip 这个库实现以上的功能。")]),e._v(" "),n("p",[n("strong",[e._v("html")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<h3>Zip 下载示例</h3>\n<div>\n  <img src="../images/body.png" />\n  <img src="../images/eyes.png" />\n  <img src="../images/mouth.png" />\n</div>\n<button onclick="download()">打包下载</button>\n')])])]),n("p",[n("strong",[e._v("js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const images = ["body.png", "eyes.png", "mouth.png"];\nconst imageUrls = images.map((name) => "../images/" + name);\n\nasync function download() {\n  let zip = new JSZip();\n  Promise.all(imageUrls.map(getFileContent)).then((contents) => {\n    contents.forEach((content, i) => {\n      zip.file(images[i], content);\n    });\n    zip.generateAsync({ type: "blob" }).then(function (blob) {\n      saveAs(blob, "material.zip");\n    });\n  });\n}\n\n// 从指定的url上下载文件内容\nfunction getFileContent(fileUrl) {\n  return new JSZip.external.Promise(function (resolve, reject) {\n    // 调用jszip-utils库提供的getBinaryContent方法获取文件内容\n    JSZipUtils.getBinaryContent(fileUrl, function (err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n')])])]),n("p",[e._v("在以上代码中，当用户点击 "),n("strong",[e._v("打包下载")]),e._v(" 按钮时，就会调用 "),n("code",[e._v("download")]),e._v(" 函数。在该函数内部，会先调用 "),n("code",[e._v("JSZip")]),e._v(" 构造函数创建 "),n("code",[e._v("JSZip")]),e._v(" 对象，然后使用 Promise.all 函数来确保所有的文件都下载完成后，再调用 "),n("code",[e._v("file(name, data [,options])")]),e._v(" 方法，把已下载的文件添加到前面创建的 "),n("code",[e._v("JSZip")]),e._v(" 对象中。最后通过 "),n("code",[e._v("zip.generateAsync")]),e._v(" 函数来生成 Zip 文件并使用 FileSaver.js 提供的 "),n("code",[e._v("saveAs")]),e._v(" 方法保存 Zip 文件。")]),e._v(" "),n("blockquote",[n("p",[e._v("Zip 下载示例：Zip")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/jszip")])]),e._v(" "),n("h3",{attrs:{id:"六、附件形式下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#六、附件形式下载"}},[e._v("#")]),e._v(" 六、附件形式下载")]),e._v(" "),n("p",[e._v("在服务端下载的场景中，附件形式下载是一种比较常见的场景。在该场景下，我们通过设置 "),n("code",[e._v("Content-Disposition")]),e._v(" 响应头来指示响应的内容以何种形式展示，是以内联（inline）的形式，还是以附件（attachment）的形式下载并保存到本地。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Content-Disposition: inline\nContent-Disposition: attachment\nContent-Disposition: attachment; filename="mouth.png"\n')])])]),n("p",[e._v("而在 HTTP 表单的场景下， "),n("code",[e._v("Content-Disposition")]),e._v(" 也可以作为 "),n("strong",[e._v("multipart body")]),e._v(" 中的消息头：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Content-Disposition: form-data\nContent-Disposition: form-data; name="fieldName"\nContent-Disposition: form-data; name="fieldName"; filename="filename.jpg"\n')])])]),n("p",[e._v("第 1 个参数总是固定不变的 "),n("code",[e._v("form-data")]),e._v("；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号（"),n("code",[e._v("=")]),e._v("）连接，参数值用双引号括起来。参数之间用分号（"),n("code",[e._v(";")]),e._v("）分隔。")]),e._v(" "),n("p",[e._v("了解完 "),n("code",[e._v("Content-Disposition")]),e._v(" 的作用之后，我们来看一下如何实现以附件形式下载的功能。Koa 是一个简单易用的 Web 框架，它的特点是优雅、简洁、轻量、自由度高。所以我们选择它来搭建文件服务，并使用 @koa/router 中间件来处理路由：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// attachment/file-server.js\nconst fs = require("fs");\nconst path = require("path");\nconst Koa = require("koa");\nconst Router = require("@koa/router");\n\nconst app = new Koa();\nconst router = new Router();\nconst PORT = 3000;\nconst STATIC_PATH = path.join(__dirname, "./static/");\n\n// http://localhost:3000/file?filename=mouth.png\nrouter.get("/file", async (ctx, next) => {\n  const { filename } = ctx.query;\n  const filePath = STATIC_PATH + filename;\n  const fStats = fs.statSync(filePath);\n  ctx.set({\n    "Content-Type": "application/octet-stream",\n    "Content-Disposition": `attachment; filename=${filename}`,\n    "Content-Length": fStats.size,\n  });\n  ctx.body = fs.createReadStream(filePath);\n});\n\n// 注册中间件\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (error) {\n    // ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录\n    ctx.status = error.code === "ENOENT" ? 404 : 500;\n    ctx.body = error.code === "ENOENT" ? "文件不存在" : "服务器开小差";\n  }\n});\napp.use(router.routes()).use(router.allowedMethods());\n\napp.listen(PORT, () => {\n  console.log(`应用已经启动：http://localhost:${PORT}/`);\n});\n')])])]),n("p",[e._v("以上的代码被保存在 "),n("code",[e._v("attachment")]),e._v(" 目录下的 "),n("code",[e._v("file-server.js")]),e._v(" 文件中，该目录下还有一个 "),n("code",[e._v("static")]),e._v(" 子目录用于存放静态资源。目前 "),n("code",[e._v("static")]),e._v(" 目录下包含以下 3 个 png 文件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("├── file-server.js\n└── static\n    ├── body.png\n    ├── eyes.png\n    └── mouth.png\n")])])]),n("p",[e._v("当你运行 "),n("code",[e._v("node file-server.js")]),e._v(" 命令成功启动文件服务器之后，就可以通过正确的 URL 地址来下载 "),n("code",[e._v("static")]),e._v(" 目录下的文件。比如在浏览器中打开 "),n("code",[e._v("http://localhost:3000/file?filename=mouth.png")]),e._v(" 这个地址，你就会开始下载 "),n("code",[e._v("mouth.png")]),e._v(" 文件。而如果指定的文件不存在的话，就会返回文件不存在。")]),e._v(" "),n("p",[e._v("Koa 内核很简洁，扩展功能都是通过中间件来实现。比如常用的路由、CORS、静态资源处理等功能都是通过中间件实现。因此要想掌握 Koa 这个框架，核心是掌握它的中间件机制。若你想深入了解 Koa 的话，可以阅读 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247486886&idx=1&sn=63bffec358b77986558e868d1adc2183&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何更好地理解中间件和洋葱模型"),n("OutboundLink")],1),e._v(" 这篇文章。")]),e._v(" "),n("p",[e._v("在编写 HTML 网页时，对于一些简单图片，通常会选择将图片内容直接内嵌在网页中，从而减少不必要的网络请求，但是图片数据是二进制数据，该怎么嵌入呢？绝大多数现代浏览器都支持一种名为 Data URLs 的特性，允许使用 Base64 对图片或其他文件的二进制数据进行编码，将其作为文本字符串嵌入网页中。所以文件也可以通过 Base64 的格式进行传输，接下来我们将介绍如何下载 Base64 格式的图片。")]),e._v(" "),n("blockquote",[n("p",[e._v("附件形式下载示例：attachment")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/attachment")])]),e._v(" "),n("h3",{attrs:{id:"七、base64-格式下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#七、base64-格式下载"}},[e._v("#")]),e._v(" 七、base64 格式下载")]),e._v(" "),n("p",[n("strong",[e._v("Base64")]),e._v(" 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2⁶ = 64 ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。相应的转换过程如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[n("strong",[e._v("Base64 常用在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。")]),e._v(" 在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 /，共 64 个字符，等号 = 用来作为后缀用途。")]),e._v(" "),n("p",[e._v("Base64 的相关内容就先介绍到这，如果你想进一步了解 Base64 的话，可以阅读 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247489632&idx=1&sn=68f123f9be1ac5a47528bf0b682e8bfe&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文读懂base64编码"),n("OutboundLink")],1),e._v(" 这篇文章。下面我们来看一下具体实现代码：")]),e._v(" "),n("h4",{attrs:{id:"_7-1-前端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-前端代码"}},[e._v("#")]),e._v(" 7.1 前端代码")]),e._v(" "),n("p",[n("strong",[e._v("html")])]),e._v(" "),n("p",[e._v("在以下 HTML 代码中，我们通过 "),n("code",[e._v("select")]),e._v(" 元素来让用户选择要下载的图片。当用户切换不同的图片时，"),n("code",[e._v("img#imgPreview")]),e._v(" 元素中显示的图片会随之发生变化。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<h3>base64 下载示例</h3>\n<img id="imgPreview" src="./static/body.png" />\n<select id="picSelect">\n   <option value="body">body.png</option>\n   <option value="eyes">eyes.png</option>\n   <option value="mouth">mouth.png</option>\n</select>\n<button onclick="download()">下载</button>\n')])])]),n("p",[n("strong",[e._v("js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const picSelectEle = document.querySelector("#picSelect");\nconst imgPreviewEle = document.querySelector("#imgPreview");\n\npicSelectEle.addEventListener("change", (event) => {\n  imgPreviewEle.src = "./static/" + picSelectEle.value + ".png";\n});\n\nconst request = axios.create({\n  baseURL: "http://localhost:3000",\n  timeout: 60000,\n});\n\nasync function download() {\n  const response = await request.get("/file", {\n    params: {\n      filename: picSelectEle.value + ".png",\n    },\n  });\n  if (response && response.data && response.data.code === 1) {\n    const fileData = response.data.data;\n    const { name, type, content } = fileData;\n    const imgBlob = base64ToBlob(content, type);\n    saveAs(imgBlob, name);\n  }\n}\n')])])]),n("p",[e._v("在用户选择好需要下载的图片并点击下载按钮时，就会调用以上代码中的 "),n("code",[e._v("download")]),e._v(" 函数。在该函数内部，我们利用 axios 实例的 "),n("code",[e._v("get")]),e._v(" 方法发起 HTTP 请求来获取指定的图片。因为返回的是 base64 格式的图片，所以在调用 FileSaver 提供的 "),n("code",[e._v("saveAs")]),e._v(" 方法前，我们需要将 base64 字符串转换成 blob 对象，该转换是通过以下的 "),n("code",[e._v("base64ToBlob")]),e._v(" 函数来完成，该函数的具体实现如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function base64ToBlob(base64, mimeType) {\n  let bytes = window.atob(base64);\n  let ab = new ArrayBuffer(bytes.length);\n  let ia = new Uint8Array(ab);\n  for (let i = 0; i < bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i);\n  }\n  return new Blob([ab], { type: mimeType });\n}\n")])])]),n("h4",{attrs:{id:"_7-2-服务端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-服务端代码"}},[e._v("#")]),e._v(" 7.2 服务端代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// base64/file-server.js\nconst fs = require("fs");\nconst path = require("path");\nconst mime = require("mime");\nconst Koa = require("koa");\nconst cors = require("@koa/cors");\nconst Router = require("@koa/router");\n\nconst app = new Koa();\nconst router = new Router();\nconst PORT = 3000;\nconst STATIC_PATH = path.join(__dirname, "./static/");\n\nrouter.get("/file", async (ctx, next) => {\n  const { filename } = ctx.query;\n  const filePath = STATIC_PATH + filename;\n  const fileBuffer = fs.readFileSync(filePath);\n  ctx.body = {\n    code: 1,\n    data: {\n      name: filename,\n      type: mime.getType(filename),\n      content: fileBuffer.toString("base64"),\n    },\n  };\n});\n\n// 注册中间件\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (error) {\n    ctx.body = {\n      code: 0,\n      msg: "服务器开小差",\n    };\n  }\n});\napp.use(cors());\napp.use(router.routes()).use(router.allowedMethods());\n\napp.listen(PORT, () => {\n  console.log(`应用已经启动：http://localhost:${PORT}/`);\n});\n')])])]),n("p",[e._v("在以上代码中，对图片进行 Base64 编码的操作是定义在 "),n("code",[e._v("/file")]),e._v(" 路由对应的路由处理器中。当该服务器接收到客户端发起的文件下载请求，比如 "),n("code",[e._v("GET /file?filename=body.png HTTP/1.1")]),e._v(" 时，就会从 "),n("code",[e._v("ctx.query")]),e._v(" 对象上获取 "),n("code",[e._v("filename")]),e._v(" 参数。该参数表示文件的名称，在获取到文件的名称之后，我们就可以拼接出文件的绝对路径，然后通过 Node.js 平台提供的 "),n("code",[e._v("fs.readFileSync")]),e._v(" 方法读取文件的内容，该方法会返回一个 Buffer 对象。在成功读取文件的内容之后，我们会继续调用 Buffer 对象的 "),n("code",[e._v("toString")]),e._v(" 方法对文件内容进行 Base64 编码，最终所下载的图片将以 Base64 格式返回到客户端。")]),e._v(" "),n("blockquote",[n("p",[e._v("base64 格式下载示例：base64")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/base64")])]),e._v(" "),n("h3",{attrs:{id:"八、chunked-下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#八、chunked-下载"}},[e._v("#")]),e._v(" 八、chunked 下载")]),e._v(" "),n("p",[e._v("分块传输编码主要应用于如下场景，即要传输大量的数据，但是在请求在没有被处理完之前响应的长度是无法获得的。例如，当需要用从数据库中查询获得的数据生成一个大的 HTML 表格的时候，或者需要传输大量的图片的时候。")]),e._v(" "),n("p",[e._v("要使用分块传输编码，则需要在响应头配置 "),n("code",[e._v("Transfer-Encoding")]),e._v(" 字段，并设置它的值为 "),n("code",[e._v("chunked")]),e._v(" 或 "),n("code",[e._v("gzip, chunked")]),e._v("：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Transfer-Encoding: chunked\nTransfer-Encoding: gzip, chunked\n")])])]),n("p",[e._v("响应头 "),n("code",[e._v("Transfer-Encoding")]),e._v(" 字段的值为 "),n("code",[e._v("chunked")]),e._v("，表示数据以一系列分块的形式进行发送。需要注意的是 "),n("code",[e._v("Transfer-Encoding")]),e._v(" 和 "),n("code",[e._v("Content-Length")]),e._v(" 这两个字段是互斥的，也就是说响应报文中这两个字段不能同时出现。下面我们来看一下分块传输的编码规则：")]),e._v(" "),n("ul",[n("li",[e._v("每个分块包含分块长度和数据块两个部分；")]),e._v(" "),n("li",[e._v("分块长度使用 16 进制数字表示，以 "),n("code",[e._v("\\r\\n")]),e._v(" 结尾；")]),e._v(" "),n("li",[e._v("数据块紧跟在分块长度后面，也使用 "),n("code",[e._v("\\r\\n")]),e._v(" 结尾，但数据不包含 "),n("code",[e._v("\\r\\n")]),e._v("；")]),e._v(" "),n("li",[e._v("终止块是一个常规的分块，表示块的结束。不同之处在于其长度为 0，即 "),n("code",[e._v("0\\r\\n\\r\\n")]),e._v("。")])]),e._v(" "),n("p",[e._v("了解完分块传输的编码规则，我们来看如何利用分块传输编码实现文件下载。")]),e._v(" "),n("h4",{attrs:{id:"_8-1-前端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-前端代码"}},[e._v("#")]),e._v(" 8.1 前端代码")]),e._v(" "),n("p",[n("strong",[e._v("html5")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<h3>chunked 下载示例</h3>\n<button onclick="download()">下载</button>\n')])])]),n("p",[n("strong",[e._v("js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const chunkedUrl = "http://localhost:3000/file?filename=file.txt";\n\nfunction download() {\n  return fetch(chunkedUrl)\n    .then(processChunkedResponse)\n    .then(onChunkedResponseComplete)\n    .catch(onChunkedResponseError);\n}\n\nfunction processChunkedResponse(response) {\n  let text = "";\n  let reader = response.body.getReader();\n  let decoder = new TextDecoder();\n\n  return readChunk();\n\n  function readChunk() {\n    return reader.read().then(appendChunks);\n  }\n\n  function appendChunks(result) {\n    let chunk = decoder.decode(result.value || new Uint8Array(), {\n      stream: !result.done,\n    });\n    console.log("已接收到的数据：", chunk);\n    console.log("本次已成功接收", chunk.length, "bytes");\n    text += chunk;\n    console.log("目前为止共接收", text.length, "bytes\\n");\n    if (result.done) {\n      return text;\n    } else {\n      return readChunk();\n    }\n  }\n}\n\nfunction onChunkedResponseComplete(result) {\n  let blob = new Blob([result], {\n    type: "text/plain;charset=utf-8",\n  });\n  saveAs(blob, "hello.txt");\n}\n\nfunction onChunkedResponseError(err) {\n  console.error(err);\n}\n')])])]),n("p",[e._v("当用户点击 "),n("strong",[e._v("下载")]),e._v(" 按钮时，就会调用以上代码中的 "),n("code",[e._v("download")]),e._v(" 函数。在该函数内部，我们会使用 Fetch API 来执行下载操作。因为服务端的数据是以一系列分块的形式进行发送，所以在浏览器端我们是通过流的形式进行接收。即通过 "),n("code",[e._v("response.body")]),e._v(" 获取可读的 ReadableStream，然后用 "),n("code",[e._v("ReadableStream.getReader()")]),e._v(" 创建一个读取器，最后调用 "),n("code",[e._v("reader.read")]),e._v(" 方法来读取已返回的分块数据。")]),e._v(" "),n("p",[e._v("因为 "),n("code",[e._v("file.txt")]),e._v(" 文件的内容是普通文本，且 "),n("code",[e._v("result.value")]),e._v(" 的值是 Uint8Array 类型的数据，所以在处理返回的分块数据时，我们使用了 TextDecoder 文本解码器。一个解码器只支持一种特定文本编码，例如 "),n("code",[e._v("utf-8")]),e._v("、"),n("code",[e._v("iso-8859-2")]),e._v("、"),n("code",[e._v("koi8")]),e._v("、"),n("code",[e._v("cp1261")]),e._v("，"),n("code",[e._v("gbk")]),e._v(" 等等。")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("如果收到的分块非 "),n("strong",[e._v("终止块")]),e._v("，"),n("code",[e._v("result.done")]),e._v(" 的值是 "),n("code",[e._v("false")]),e._v("，则会继续调用 "),n("code",[e._v("readChunk")]),e._v("方法来读取分块数据。而当接收到 "),n("strong",[e._v("终止块")]),e._v(" 之后，表示分块数据已传输完成。此时，"),n("code",[e._v("result.done")]),e._v(" 属性就会返回 "),n("code",[e._v("true")]),e._v("。从而会自动调用 "),n("code",[e._v("onChunkedResponseComplete")]),e._v(" 函数，在该函数内部，我们以解码后的文本作为参数来创建 Blob 对象。之后，继续使用 FileSaver 库提供的 "),n("code",[e._v("saveAs")]),e._v(" 方法实现文件下载。")]),e._v(" "),n("p",[e._v("这里我们用 "),n("strong",[e._v("Wireshark")]),e._v(" 网络包分析工具，抓了个数据包。具体如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("从图中我们可以清楚地看到在 "),n("strong",[e._v("HTTP chunked response")]),e._v(" 下面包含了 **Data chunk（数据块）**和 "),n("strong",[e._v("End of chunked encoding（终止块）")]),e._v("。接下来，我们来看一下服务端的代码。")]),e._v(" "),n("h4",{attrs:{id:"_8-2-服务端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-服务端代码"}},[e._v("#")]),e._v(" 8.2 服务端代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const fs = require("fs");\nconst path = require("path");\nconst Koa = require("koa");\nconst cors = require("@koa/cors");\nconst Router = require("@koa/router");\n\nconst app = new Koa();\nconst router = new Router();\nconst PORT = 3000;\n\nrouter.get("/file", async (ctx, next) => {\n  const { filename } = ctx.query;\n  const filePath = path.join(__dirname, filename);\n  ctx.set({\n    "Content-Type": "text/plain;charset=utf-8",\n  });\n  ctx.body = fs.createReadStream(filePath);\n});\n\n// 注册中间件\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (error) {\n    // ENOENT（无此文件或目录）：通常是由文件操作引起的，这表明在给定的路径上无法找到任何文件或目录\n    ctx.status = error.code === "ENOENT" ? 404 : 500;\n    ctx.body = error.code === "ENOENT" ? "文件不存在" : "服务器开小差";\n  }\n});\napp.use(cors());\napp.use(router.routes()).use(router.allowedMethods());\n\napp.listen(PORT, () => {\n  console.log(`应用已经启动：http://localhost:${PORT}/`);\n});\n')])])]),n("p",[e._v("在 "),n("code",[e._v("/file")]),e._v(" 路由处理器中，我们先通过 "),n("code",[e._v("ctx.query")]),e._v(" 获得 "),n("code",[e._v("filename")]),e._v(" 文件名，接着拼接出该文件的绝对路径，然后通过 Node.js 平台提供的 "),n("code",[e._v("fs.createReadStream")]),e._v(" 方法创建可读流。最后把已创建的可读流赋值给 "),n("code",[e._v("ctx.body")]),e._v(" 属性，从而向客户端返回图片数据。")]),e._v(" "),n("p",[e._v("现在我们已经知道可以利用分块传输编码（Transfer-Encoding）实现数据的分块传输，那么有没有办法获取指定范围内的文件数据呢？对于这个问题，我们可以利用 HTTP 协议的范围请求。接下来，我们将介绍如何利用 HTTP 范围请求来下载指定范围的数据。")]),e._v(" "),n("blockquote",[n("p",[e._v("chunked 下载示例：chunked")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/chunked")])]),e._v(" "),n("h3",{attrs:{id:"九、范围下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#九、范围下载"}},[e._v("#")]),e._v(" 九、范围下载")]),e._v(" "),n("p",[e._v("HTTP 协议范围请求允许服务器只发送 HTTP 消息的一部分到客户端。范围请求在传送大的媒体文件，或者与文件下载的断点续传功能搭配使用时非常有用。如果在响应中存在 "),n("code",[e._v("Accept-Ranges")]),e._v(" 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。")]),e._v(" "),n("p",[e._v("在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 "),n("strong",[e._v("206 Partial Content")]),e._v(" 状态码。假如所请求的范围不合法，那么服务器会返回 "),n("strong",[e._v("416 Range Not Satisfiable")]),e._v(" 状态码，表示客户端错误。服务器允许忽略 Range 首部，从而返回整个文件，状态码用 200 。")]),e._v(" "),n("p",[n("strong",[e._v("Range 语法：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Range: <unit>=<range-start>-\nRange: <unit>=<range-start>-<range-end>\nRange: <unit>=<range-start>-<range-end>, <range-start>-<range-end>\nRange: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>\n")])])]),n("ul",[n("li",[n("code",[e._v("unit")]),e._v("：范围请求所采用的单位，通常是字节（bytes）。")]),e._v(" "),n("li",[n("code",[e._v("<range-start>")]),e._v("：一个整数，表示在特定单位下，范围的起始值。")]),e._v(" "),n("li",[n("code",[e._v("<range-end>")]),e._v("：一个整数，表示在特定单位下，范围的结束值。"),n("strong",[e._v("这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。")])])]),e._v(" "),n("p",[e._v("了解完 "),n("code",[e._v("Range")]),e._v(" 语法之后，我们来看一下实际的使用示例：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('# 单一范围\n$ curl http://i.imgur.com/z4d4kWk.jpg -i -H "Range: bytes=0-1023"\n# 多重范围\n$ curl http://www.example.com -i -H "Range: bytes=0-50, 100-150"\n')])])]),n("h4",{attrs:{id:"_9-1-前端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-前端代码"}},[e._v("#")]),e._v(" 9.1 前端代码")]),e._v(" "),n("p",[n("strong",[e._v("html")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<h3>范围下载示例</h3>\n<button onclick="download()">下载</button>\n')])])]),n("p",[n("strong",[e._v("js")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('async function download() {\n  try {\n    let rangeContent = await getBinaryContent(\n      "http://localhost:3000/file.txt",\n       0, 100, "text"\n    );\n    const blob = new Blob([rangeContent], {\n      type: "text/plain;charset=utf-8",\n    });\n    saveAs(blob, "hello.txt");\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction getBinaryContent(url, start, end, responseType = "arraybuffer") {\n  return new Promise((resolve, reject) => {\n    try {\n      let xhr = new XMLHttpRequest();\n      xhr.open("GET", url, true);\n      xhr.setRequestHeader("range", `bytes=${start}-${end}`);\n      xhr.responseType = responseType;\n      xhr.onload = function () {\n        resolve(xhr.response);\n      };\n        xhr.send();\n    } catch (err) {\n        reject(new Error(err));\n    }\n  });\n}\n')])])]),n("p",[e._v("当用户点击 "),n("strong",[e._v("下载")]),e._v(" 按钮时，就会调用 "),n("code",[e._v("download")]),e._v(" 函数。在该函数内部会通过调用 "),n("code",[e._v("getBinaryContent")]),e._v(" 函数来发起范围请求。对应的 HTTP 请求报文如下所示：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("GET /file.txt HTTP/1.1\nHost: localhost:3000\nConnection: keep-alive\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\nAccept: */*\nAccept-Encoding: identity\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,id;q=0.7\nRange: bytes=0-100\n")])])]),n("p",[e._v("而当服务器接收到该范围请求之后，会返回对应的 HTTP 响应报文：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("HTTP/1.1 206 Partial Content\nVary: Origin\nAccess-Control-Allow-Origin: null\nAccept-Ranges: bytes\nLast-Modified: Fri, 09 Jul 2021 00:17:00 GMT\nCache-Control: max-age=0\nContent-Type: text/plain; charset=utf-8\nDate: Sat, 10 Jul 2021 02:19:39 GMT\nConnection: keep-alive\nContent-Range: bytes 0-100/2590\nContent-Length: 101\n")])])]),n("p",[e._v("从以上的 HTTP 响应报文中，我们见到了前面介绍的 "),n("strong",[e._v("206")]),e._v(" 状态码和 "),n("strong",[e._v("Accept-Ranges")]),e._v(" 首部。此外，通过 "),n("code",[e._v("Content-Range")]),e._v(" 首部，我们就知道了文件的总大小。在成功获取到范围请求的响应体之后，我们就可以使用返回的内容作为参数，调用 Blob 构造函数创建对应的 Blob 对象，进而使用 FileSaver 库提供的 saveAs 方法来下载文件了。")]),e._v(" "),n("h4",{attrs:{id:"_9-2-服务端代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-2-服务端代码"}},[e._v("#")]),e._v(" 9.2 服务端代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const Koa = require("koa");\nconst cors = require("@koa/cors");\nconst serve = require("koa-static");\nconst range = require("koa-range");\n\nconst PORT = 3000;\nconst app = new Koa();\n\n// 注册中间件\napp.use(cors());\napp.use(range);\napp.use(serve("."));\n\napp.listen(PORT, () => {\n  console.log(`应用已经启动：http://localhost:${PORT}/`);\n});\n')])])]),n("p",[e._v("服务端的代码相对比较简单，范围请求是通过 koa-range 中间件来实现的。由于篇幅有限，阿宝哥就不展开介绍了。感兴趣的小伙伴，可以自行阅读该中间件的源码。其实范围请求还可以应用在大文件下载的场景，如果文件服务器支持范围请求的话，客户端在下载大文件的时候，就可以考虑使用大文件分块下载的方案。")]),e._v(" "),n("blockquote",[n("p",[e._v("范围下载示例：range")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/range")])]),e._v(" "),n("h3",{attrs:{id:"十、大文件分块下载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#十、大文件分块下载"}},[e._v("#")]),e._v(" 十、大文件分块下载")]),e._v(" "),n("p",[e._v("相信有些小伙伴已经了解大文件上传的解决方案，在上传大文件时，为了提高上传的效率，我们一般会使用 Blob.slice 方法对大文件按照指定的大小进行切割，然后在开启多线程进行分块上传，等所有分块都成功上传后，再通知服务端进行分块合并。")]),e._v(" "),n("p",[e._v("那么对大文件下载来说，我们能否采用类似的思想呢？其实在服务端支持 "),n("code",[e._v("Range")]),e._v(" 请求首部的条件下，我们也是可以实现大文件分块下载的功能，具体处理方案如下图所示：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("因为在 JavaScript 中如何实现大文件并发下载？ 这篇文章中，阿宝哥已经详细介绍了大文件并发下载的方案，所以这里就不展开介绍了。我们只回顾一下大文件并发下载的完整流程：")]),e._v(" "),n("p",[n("img",{attrs:{src:"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",alt:"图片"}})]),e._v(" "),n("p",[e._v("其实在大文件分块下载的场景中，我们使用了 async-pool 这个库来实现并发控制。该库提供了 ES7 和 ES6 两种不同版本的实现，代码很简洁优雅。如果你想了解 async-pool 是如何实现并发控制的，可以阅读 JavaScript 中如何实现并发控制？ 这篇文章。")]),e._v(" "),n("blockquote",[n("p",[e._v("大文件分块下载示例：big-file")]),e._v(" "),n("p",[e._v("https://github.com/semlinker/file-download-demos/tree/main/big-file")])]),e._v(" "),n("h3",{attrs:{id:"十一、总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#十一、总结"}},[e._v("#")]),e._v(" 十一、总结")]),e._v(" "),n("p",[e._v("本文阿宝哥详细介绍了文件下载的 9 种场景，希望阅读完本文后，你对 9 种场景背后使用的技术有一定的了解。其实在传输文件的过程中，为了提高传输效率，我们可以使用 "),n("code",[e._v("gzip")]),e._v("、"),n("code",[e._v("deflate")]),e._v(" 或 "),n("code",[e._v("br")]),e._v(" 等压缩算法对文件进行压缩。由于篇幅有限，阿宝哥就不展开介绍了，如果你感兴趣的话，可以阅读 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247492234&idx=1&sn=f4d0ae2014cd90845e08eb8ffb8422c2&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP 传输大文件的几种方案"),n("OutboundLink")],1),e._v(" 这篇文章。")]),e._v(" "),n("p",[e._v("有了文件下载的场景，怎么能缺少文件上传的场景呢？如果你还没阅读过 "),n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247493294&idx=1&sn=85642a71feae9f1df2abf1110f721054&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("文件上传，搞懂这 8 种场景就够了"),n("OutboundLink")],1),e._v(" 这篇文章，建议你有空的时候，可以一起了解一下。这里再次感谢掘友们一直以来的支持，如果你们还想了解其他方面的内容，欢迎给阿宝哥留言哟。")]),e._v(" "),n("h3",{attrs:{id:"十二、参考资源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#十二、参考资源"}},[e._v("#")]),e._v(" 十二、参考资源")]),e._v(" "),n("ul",[n("li",[e._v("MDN — showSaveFilePicker")]),e._v(" "),n("li",[e._v("MDN — Content-Disposition")]),e._v(" "),n("li",[e._v("The File System Access API: simplifying access to local files")]),e._v(" "),n("li",[e._v("Reading and writing files and directories with the browser-fs-access library")]),e._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247493294&idx=1&sn=85642a71feae9f1df2abf1110f721054&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("文件上传，搞懂这8种场景就够了"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247490849&idx=1&sn=9d062c04baeb629d9b69a9fb4e7c3599&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript 中如何实现大文件并发下载？"),n("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);